<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>snowFlakeXue</title>
  <icon>https://www.gravatar.com/avatar/4543c26cc38d80588b9c8a253b44cc58</icon>
  <subtitle>Work hard for what you desire.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="snowFlakeXue.github.io/"/>
  <updated>2019-11-10T01:46:39.222Z</updated>
  <id>snowFlakeXue.github.io/</id>
  
  <author>
    <name>Liu Xue</name>
    <email>liuxue82@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>两级页表</title>
    <link href="snowFlakeXue.github.io/2019/11/06/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/"/>
    <id>snowFlakeXue.github.io/2019/11/06/两级页表/</id>
    <published>2019-11-06T05:53:30.000Z</published>
    <updated>2019-11-10T01:46:39.222Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;分页存储中的页表是单级页表，它有两个很严重的问题&lt;/p&gt;
&lt;p&gt;1.页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框&lt;/p&gt;
&lt;p&gt;2.没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面&lt;br&gt;第二个问题需要用到虚拟技术，以后再说&lt;/
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>变址机构</title>
    <link href="snowFlakeXue.github.io/2019/11/06/%E5%8F%98%E5%9D%80%E6%9C%BA%E6%9E%84/"/>
    <id>snowFlakeXue.github.io/2019/11/06/变址机构/</id>
    <published>2019-11-06T01:50:02.000Z</published>
    <updated>2019-11-10T01:46:39.230Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本变址机构&quot;&gt;&lt;a href=&quot;#基本变址机构&quot; class=&quot;headerlink&quot; title=&quot;基本变址机构&quot;&gt;&lt;/a&gt;基本变址机构&lt;/h2&gt;&lt;p&gt;基本变址机构(两次访存)解决分页存储地址转换问题的，通常会在系统中放置一个页表寄存器来存放页表在内存中的起始地址F和页表长度M,进程未执行时，页表的始址和页表长度会放在进程控制快中，当进程调度时，操作系统内核会把他们放在页表寄存器里，具体流程看下图&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>动态分区分配算法</title>
    <link href="snowFlakeXue.github.io/2019/11/05/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>snowFlakeXue.github.io/2019/11/05/动态分区分配算法/</id>
    <published>2019-11-05T07:25:58.000Z</published>
    <updated>2019-11-06T01:56:27.279Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足要求时，应选择哪个分区&lt;/p&gt;
&lt;h2 id=&quot;首次适应算法-First-Fit&quot;&gt;&lt;a href=&quot;#首次适应算法-First-Fit&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存空间的分配与回收</title>
    <link href="snowFlakeXue.github.io/2019/11/04/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>snowFlakeXue.github.io/2019/11/04/内存空间的分配与回收/</id>
    <published>2019-11-04T14:30:07.000Z</published>
    <updated>2019-11-10T01:46:39.223Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;连续分配管理方式&quot;&gt;&lt;a href=&quot;#连续分配管理方式&quot; class=&quot;headerlink&quot; title=&quot;连续分配管理方式&quot;&gt;&lt;/a&gt;连续分配管理方式&lt;/h2&gt;&lt;p&gt;连续分配：指为用户进程分配的必须是一个连续的内存空间&lt;/p&gt;
&lt;font
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存扩充</title>
    <link href="snowFlakeXue.github.io/2019/11/04/%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85/"/>
    <id>snowFlakeXue.github.io/2019/11/04/内存扩充/</id>
    <published>2019-11-04T11:41:35.000Z</published>
    <updated>2019-11-06T01:56:23.617Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;覆盖与交换是内存扩充的两种方法&lt;/p&gt;
&lt;h2 id=&quot;覆盖技术&quot;&gt;&lt;a href=&quot;#覆盖技术&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存的基础知识</title>
    <link href="snowFlakeXue.github.io/2019/11/04/%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>snowFlakeXue.github.io/2019/11/04/内存的基础知识/</id>
    <published>2019-11-04T05:58:50.000Z</published>
    <updated>2019-11-10T01:46:39.234Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是内存？有何作用&quot;&gt;&lt;a href=&quot;#什么是内存？有何作用&quot; class=&quot;headerlink&quot; title=&quot;什么是内存？有何作用&quot;&gt;&lt;/a&gt;什么是内存？有何作用&lt;/h2&gt;&lt;p&gt;内存是用于存放数据的硬件，程序执行前需先放到内存中才能被CPU处理&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>调度算法</title>
    <link href="snowFlakeXue.github.io/2019/11/03/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>snowFlakeXue.github.io/2019/11/03/调度算法/</id>
    <published>2019-11-03T13:29:44.000Z</published>
    <updated>2019-11-04T06:58:04.074Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先来先服务算法-FCFS-First-Come-First-Serve-考虑等待时间&quot;&gt;&lt;a href=&quot;#先来先服务算法-FCFS-First-Come-First-Serve-考虑等待时间&quot; class=&quot;headerlink&quot; title=&quot;先来先服务算法(FCFS,First Come First Serve)(考虑等待时间)&quot;&gt;&lt;/a&gt;先来先服务算法(FCFS,First Come First Serve)(考虑等待时间)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/11/03/调度算法/1.jpg&quot; alt=&quot;FCFS&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>调度算法的评价指标</title>
    <link href="snowFlakeXue.github.io/2019/10/31/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>snowFlakeXue.github.io/2019/10/31/调度算法的评价指标/</id>
    <published>2019-10-31T05:35:20.000Z</published>
    <updated>2019-11-04T06:58:04.053Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;相对于操作系统则看重平均，就是除以作业数&lt;/p&gt;
&lt;h2 id=&quot;CPU利用率-CPU贵，希望他利用率高一点&quot;&gt;&lt;a href=&quot;#CPU利用率-CPU贵，希望他利用率高一点&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程调度</title>
    <link href="snowFlakeXue.github.io/2019/10/31/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>snowFlakeXue.github.io/2019/10/31/进程调度/</id>
    <published>2019-10-31T03:06:32.000Z</published>
    <updated>2019-10-31T05:34:31.843Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程调度的时机&quot;&gt;&lt;a href=&quot;#进程调度的时机&quot; class=&quot;headerlink&quot; title=&quot;进程调度的时机&quot;&gt;&lt;/a&gt;进程调度的时机&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/31/进程调度/1.jpg&quot; alt=&quot;时机&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>处理机调度的概念和层次</title>
    <link href="snowFlakeXue.github.io/2019/10/31/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1/"/>
    <id>snowFlakeXue.github.io/2019/10/31/处理机调度的概念和层次/</id>
    <published>2019-10-31T01:14:23.000Z</published>
    <updated>2019-10-31T03:04:09.907Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;调度的基本概念&quot;&gt;&lt;a href=&quot;#调度的基本概念&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>哲学家进餐问题</title>
    <link href="snowFlakeXue.github.io/2019/10/31/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/"/>
    <id>snowFlakeXue.github.io/2019/10/31/哲学家进餐问题/</id>
    <published>2019-10-31T00:24:20.000Z</published>
    <updated>2019-10-31T01:05:13.398Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：在一张圆桌上坐着5位哲学家，在每两位哲学家中间放一只筷子，桌子中间是一碗米饭，哲学家只要两个动作，要么思考，要么吃饭，但哲学家只有拿起两只筷子才能正常吃饭，如果筷子在别人手里，这位哲学家就被阻塞，当进餐完毕之后，放下筷子继续思考&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>吸烟者问题</title>
    <link href="snowFlakeXue.github.io/2019/10/30/%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>snowFlakeXue.github.io/2019/10/30/吸烟者问题/</id>
    <published>2019-10-30T04:08:41.000Z</published>
    <updated>2019-10-30T05:23:01.080Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：假设系统中有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起一支烟，抽烟者需要三种材料：烟草，纸和胶水，三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水，供应者无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉他完成了，供应者就会放另外两种材料到桌子上，这个过程一直重复(让三个抽烟者轮流抽烟)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>读者写者问题</title>
    <link href="snowFlakeXue.github.io/2019/10/30/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>snowFlakeXue.github.io/2019/10/30/读者写者问题/</id>
    <published>2019-10-30T03:18:08.000Z</published>
    <updated>2019-10-31T00:29:41.488Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：有读者和写者两组并发进程，共享一个文件。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>多消费者-多生产者问题</title>
    <link href="snowFlakeXue.github.io/2019/10/30/%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>snowFlakeXue.github.io/2019/10/30/多消费者-多生产者问题/</id>
    <published>2019-10-29T22:15:11.000Z</published>
    <updated>2019-10-30T03:14:18.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;先给出问题背景：桌子上有一个盘子，每次只能向其中放入一个水果，爸爸专向盘子里放苹果，妈妈专向盘子里放橘子，儿子专等着吃盘子里的橘子，女儿专等着吃盘子里的苹果。只有字盘子是空的时候，爸爸或妈妈才能向盘子里放水果；只有在盘子里有自己想要的水果时，儿子或女儿才能取出盘子里的水果吃掉。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>生产者-消费者问题</title>
    <link href="snowFlakeXue.github.io/2019/10/29/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>snowFlakeXue.github.io/2019/10/29/生产者-消费者问题/</id>
    <published>2019-10-28T22:40:07.000Z</published>
    <updated>2019-10-29T06:43:12.463Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;所谓生产者-消费者问题实际上就是有一个缓冲区，生产者生产好了放进去，消费者可以从缓冲区中取出来产品用，但是需要注意的是肯定是要保证各进程都是互斥的，生产者和消费者要互斥不用多说，假设现在有两个生产者想要把产品放进缓冲区，如果都想放在同一个地方怎么办，因此一定要保证互斥性，那互斥的初始信号量是1，因此我们要设置一个互斥信号量 &lt;code&gt;semaphore mutex = 1;&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>信号量机制</title>
    <link href="snowFlakeXue.github.io/2019/10/28/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"/>
    <id>snowFlakeXue.github.io/2019/10/28/信号量机制/</id>
    <published>2019-10-28T05:02:13.000Z</published>
    <updated>2019-10-28T11:55:11.134Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为啥要引入信号量机制，关于实现进程互斥我们有四种软件实现方法，三种硬件实现方法，但是要么就是不能让上锁和检查一气呵成出现问题，要么就是上述所有方法都有的一个通病：不能实现让权等待。那么，就是信号量机制诞生的意义啦。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程同步与互斥</title>
    <link href="snowFlakeXue.github.io/2019/10/18/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <id>snowFlakeXue.github.io/2019/10/18/进程同步与互斥/</id>
    <published>2019-10-18T07:22:13.000Z</published>
    <updated>2019-10-28T05:01:19.209Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程同步&quot;&gt;&lt;a href=&quot;#进程同步&quot; class=&quot;headerlink&quot; title=&quot;进程同步&quot;&gt;&lt;/a&gt;进程同步&lt;/h2&gt;&lt;p&gt;我们知道为了实现并发，进程就有了异步性这个概念，异步性就是以不可预知的速度和方向进行的，但是有的时候我希望各个进程是可以共同合作的，就是有一定顺序的进行，就比方说管道通信，我就想先写再读而不是不知道是先读还是先写，这个时候就要引入进程同步来解决这个问题。&lt;/p&gt;
&lt;p&gt;进程同步：有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的顺序&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="snowFlakeXue.github.io/2019/10/17/%E7%BA%BF%E7%A8%8B/"/>
    <id>snowFlakeXue.github.io/2019/10/17/线程/</id>
    <published>2019-10-17T11:38:32.000Z</published>
    <updated>2019-10-18T06:49:10.112Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;什么是线程？我们首先得说说为什么要引进线程-&amp;gt;从程序到进程，我们实现了进程并发让我的qq和网易云可以同时运行，但是我想用QQ一边视频，一边打字聊天，一边看QQ空间怎么办呢。QQ这个进程里的代码是顺序执行的，我是不是也得让这些小操作也可以并发执行才行，这个时候就得引出我们的线程了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="snowFlakeXue.github.io/2019/10/15/%E8%BF%9B%E7%A8%8B/"/>
    <id>snowFlakeXue.github.io/2019/10/15/进程/</id>
    <published>2019-10-15T14:30:23.000Z</published>
    <updated>2019-10-18T06:49:28.954Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程的定义-强调动态性&quot;&gt;&lt;a href=&quot;#进程的定义-强调动态性&quot; class=&quot;headerlink&quot; title=&quot;进程的定义(强调动态性)&quot;&gt;&lt;/a&gt;进程的定义(强调动态性)&lt;/h2&gt;&lt;p&gt;进程是能和其他程序并行执行的&lt;font color=&quot;red&quot;&gt;程序段&lt;/font&gt;在某数据集合上的一次运行过程，它是系统资源分配和调度的基本单位。&lt;/p&gt;
&lt;p&gt;话说为什么要引入进程呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="snowFlakeXue.github.io/2019/10/15/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>snowFlakeXue.github.io/2019/10/15/系统调用/</id>
    <published>2019-10-15T13:14:53.000Z</published>
    <updated>2019-10-15T13:55:46.701Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;什么是系统调用&quot;&gt;&lt;a href=&quot;#什么是系统调用&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>
