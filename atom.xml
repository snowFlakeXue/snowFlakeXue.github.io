<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>snowFlakeXue</title>
  <icon>https://www.gravatar.com/avatar/4543c26cc38d80588b9c8a253b44cc58</icon>
  <subtitle>Work hard for what you desire.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="snowFlakeXue.github.io/"/>
  <updated>2019-10-18T07:56:16.290Z</updated>
  <id>snowFlakeXue.github.io/</id>
  
  <author>
    <name>Liu Xue</name>
    <email>liuxue82@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程同步与互斥</title>
    <link href="snowFlakeXue.github.io/2019/10/18/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <id>snowFlakeXue.github.io/2019/10/18/进程同步与互斥/</id>
    <published>2019-10-18T07:22:13.000Z</published>
    <updated>2019-10-18T07:56:16.290Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;进程同步&quot;&gt;&lt;a href=&quot;#进程同步&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="snowFlakeXue.github.io/2019/10/17/%E7%BA%BF%E7%A8%8B/"/>
    <id>snowFlakeXue.github.io/2019/10/17/线程/</id>
    <published>2019-10-17T11:38:32.000Z</published>
    <updated>2019-10-18T06:49:10.112Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;什么是线程？我们首先得说说为什么要引进线程-&amp;gt;从程序到进程，我们实现了进程并发让我的qq和网易云可以同时运行，但是我想用QQ一边视频，一边打字聊天，一边看QQ空间怎么办呢。QQ这个进程里的代码是顺序执行的，我是不是也得让这些小操作也可以并发执行才行，这个时候就得引出我们的线程了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="snowFlakeXue.github.io/2019/10/15/%E8%BF%9B%E7%A8%8B/"/>
    <id>snowFlakeXue.github.io/2019/10/15/进程/</id>
    <published>2019-10-15T14:30:23.000Z</published>
    <updated>2019-10-18T06:49:28.954Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程的定义-强调动态性&quot;&gt;&lt;a href=&quot;#进程的定义-强调动态性&quot; class=&quot;headerlink&quot; title=&quot;进程的定义(强调动态性)&quot;&gt;&lt;/a&gt;进程的定义(强调动态性)&lt;/h2&gt;&lt;p&gt;进程是能和其他程序并行执行的&lt;font color=&quot;red&quot;&gt;程序段&lt;/font&gt;在某数据集合上的一次运行过程，它是系统资源分配和调度的基本单位。&lt;/p&gt;
&lt;p&gt;话说为什么要引入进程呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="snowFlakeXue.github.io/2019/10/15/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>snowFlakeXue.github.io/2019/10/15/系统调用/</id>
    <published>2019-10-15T13:14:53.000Z</published>
    <updated>2019-10-15T13:55:46.701Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;什么是系统调用&quot;&gt;&lt;a href=&quot;#什么是系统调用&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>中断和异常</title>
    <link href="snowFlakeXue.github.io/2019/10/14/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>snowFlakeXue.github.io/2019/10/14/中断和异常/</id>
    <published>2019-10-14T13:37:34.000Z</published>
    <updated>2019-10-15T13:16:11.958Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;中断机制的诞生&quot;&gt;&lt;a href=&quot;#中断机制的诞生&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="snowFlakeXue.github.io/2019/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>snowFlakeXue.github.io/2019/10/12/操作系统概述/</id>
    <published>2019-10-12T12:24:12.000Z</published>
    <updated>2019-10-18T06:50:15.851Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是操作系统&quot;&gt;&lt;a href=&quot;#什么是操作系统&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统&quot;&gt;&lt;/a&gt;什么是操作系统&lt;/h2&gt;&lt;p&gt;  操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="snowFlakeXue.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>词法作用域</title>
    <link href="snowFlakeXue.github.io/2019/08/30/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>snowFlakeXue.github.io/2019/08/30/词法作用域/</id>
    <published>2019-08-30T02:06:54.000Z</published>
    <updated>2019-08-31T00:02:30.657Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;作用域有两种模型，一种是词法作用域，一种是动态作用域，而js用的就是词法作用域。词法作用域就是在词法化时的作用域，变量及代码块写在哪就是在哪，当词法分析器处理代码时不会改变作用域。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我不知道的javascript" scheme="snowFlakeXue.github.io/categories/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是作用域</title>
    <link href="snowFlakeXue.github.io/2019/08/27/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>snowFlakeXue.github.io/2019/08/27/什么是作用域/</id>
    <published>2019-08-27T14:08:35.000Z</published>
    <updated>2019-08-30T02:10:53.840Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一·编译原理&quot;&gt;&lt;a href=&quot;#一·编译原理&quot; class=&quot;headerlink&quot; title=&quot;一·编译原理&quot;&gt;&lt;/a&gt;一·编译原理&lt;/h2&gt;&lt;p&gt;javascript是一种“解释执行”语言。它跟传统的编译语言编译时间不一样但编译的步骤基本相似且javascript的要更为复杂。因为与其他编译语言不同，他不需要提前进行编译，就导致了他没有太多时间进行优化，他只是在代码执行前进行几毫秒的编译。所以，他就想各种方法来进行性能优化，比如JIT（延迟编译）甚至实施重编译。&lt;/p&gt;
    
    </summary>
    
      <category term="我不知道的javascript" scheme="snowFlakeXue.github.io/categories/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>map</title>
    <link href="snowFlakeXue.github.io/2019/08/01/map/"/>
    <id>snowFlakeXue.github.io/2019/08/01/map/</id>
    <published>2019-08-01T08:46:35.000Z</published>
    <updated>2019-08-01T09:02:34.715Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;map也是种数据结构，他与json，set这两种数据结构相比，更灵活，效率更高&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>Set和WeakSet</title>
    <link href="snowFlakeXue.github.io/2019/08/01/Set%E5%92%8CWeakSet/"/>
    <id>snowFlakeXue.github.io/2019/08/01/Set和WeakSet/</id>
    <published>2019-08-01T03:02:01.000Z</published>
    <updated>2019-08-01T05:57:47.963Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Set和WeakSet都是数据结构而不是数据类型，他俩很相似，前者要放数组在他的数据结构里，后者要放对象在他的数据结构里。而放的方式，两者又有细微的差距。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>Symbol在对象中作用</title>
    <link href="snowFlakeXue.github.io/2019/08/01/%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E4%BD%9C%E7%94%A8/"/>
    <id>snowFlakeXue.github.io/2019/08/01/在对象中作用/</id>
    <published>2019-08-01T01:52:17.000Z</published>
    <updated>2019-08-01T02:27:53.055Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;symbol是ES6中新添加的一种数据类型，他属于原始数据类型，也就是存放在栈中，是按值传递。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>对象</title>
    <link href="snowFlakeXue.github.io/2019/07/25/%E5%AF%B9%E8%B1%A1/"/>
    <id>snowFlakeXue.github.io/2019/07/25/对象/</id>
    <published>2019-07-25T02:21:58.000Z</published>
    <updated>2019-08-01T02:27:44.151Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;对象赋值&quot;&gt;&lt;a href=&quot;#对象赋值&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>函数和数组补漏</title>
    <link href="snowFlakeXue.github.io/2019/07/24/%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84%E8%A1%A5%E6%BC%8F/"/>
    <id>snowFlakeXue.github.io/2019/07/24/函数和数组补漏/</id>
    <published>2019-07-24T01:39:01.000Z</published>
    <updated>2019-07-24T02:41:24.826Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;对象的函数解构&quot;&gt;&lt;a href=&quot;#对象的函数解构&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>箭头函数和扩展</title>
    <link href="snowFlakeXue.github.io/2019/07/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95/"/>
    <id>snowFlakeXue.github.io/2019/07/23/箭头函数和扩展/</id>
    <published>2019-07-23T04:01:45.000Z</published>
    <updated>2019-07-23T04:52:51.299Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;默认值&quot;&gt;&lt;a href=&quot;#默认值&quot; class=&quot;headerlink&quot; title=&quot;默认值&quot;&gt;&lt;/a&gt;默认值&lt;/h2&gt;&lt;p&gt;在ES6中给我们提供了可以在函数参数中使用默认值的操作，在学习箭头函数之前就先用ES5方法写函数&lt;/p&gt;
&lt;figure
        
      
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>数组知识</title>
    <link href="snowFlakeXue.github.io/2019/07/21/%E6%95%B0%E7%BB%84%E7%9F%A5%E8%AF%86/"/>
    <id>snowFlakeXue.github.io/2019/07/21/数组知识/</id>
    <published>2019-07-21T02:47:56.000Z</published>
    <updated>2019-08-01T02:27:46.445Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在ES6中新增了一些数组方法来简化代码量。ES6把所有对数组的操作都归结与Array.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;json数组格式转换&quot;&gt;&lt;a href=&quot;#json数组格式转换&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>数字的操作</title>
    <link href="snowFlakeXue.github.io/2019/07/20/%E6%95%B0%E5%AD%97%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>snowFlakeXue.github.io/2019/07/20/数字的操作/</id>
    <published>2019-07-20T12:50:38.000Z</published>
    <updated>2019-07-20T13:18:08.993Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;ES6中将数字的方法都用Number.来开始，因为这样随着以后的完善可以扩展出很多但是又都归结于Number.下面先回顾下二进制，八进制，再介绍些可以直接用的很方便的方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串操作</title>
    <link href="snowFlakeXue.github.io/2019/07/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>snowFlakeXue.github.io/2019/07/20/字符串操作/</id>
    <published>2019-07-20T09:41:54.000Z</published>
    <updated>2019-07-20T10:22:23.626Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;字符串的操作是很重要的，但ES5的方法容易出错还比较麻烦，ES6的字符串模板，字符串查找，字符串复制就很好的解决了这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>扩展运算符和rest运算符</title>
    <link href="snowFlakeXue.github.io/2019/07/20/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>snowFlakeXue.github.io/2019/07/20/扩展运算符和rest运算符/</id>
    <published>2019-07-20T02:57:55.000Z</published>
    <updated>2019-07-20T09:07:41.457Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;扩展运算符和rest运算符都是三个点…,可以当做没什么区别，但各有各的用处。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="snowFlakeXue.github.io/2019/07/19/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>snowFlakeXue.github.io/2019/07/19/变量的解构赋值/</id>
    <published>2019-07-19T09:36:47.000Z</published>
    <updated>2019-07-19T11:14:23.214Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;解构赋值就是把变量（数组，对象，字符串中的元素拿出来）-&amp;gt;解构，再赋值，应用很多，还在初学阶段就只是把它结构出来打印下来还不会应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>声明方式</title>
    <link href="snowFlakeXue.github.io/2019/07/18/%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/"/>
    <id>snowFlakeXue.github.io/2019/07/18/声明方式/</id>
    <published>2019-07-18T08:21:28.000Z</published>
    <updated>2019-07-18T08:54:04.853Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在ES5中声明变量只有var一种形式，是局部啊还是全局啊很麻烦去区别。ES6就将声明方式升级了那么一下子，全局用var，局部用let,常量用const&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="snowFlakeXue.github.io/categories/ES6/"/>
    
    
  </entry>
  
</feed>
