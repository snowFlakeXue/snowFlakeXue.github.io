<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[day2]]></title>
    <url>%2F2019%2F05%2F05%2Fday2%2F</url>
    <content type="text"><![CDATA[程序运行时，程序计数器指向一个地址值，然后顺序结构的话，每进行一条指令，程序计数器上的值加一 其实cpu处理程序很有意思，像是比较累加寄存器和通用寄存器中的值，他实际上会进行减法运算，通过正负零来判断谁大谁小 运算结果存放在标志寄存器，无论结果是什么都会存放进去，同时标志寄存器还负责存放溢出和奇偶判断 分支结构是用的跳转指令，即运行时程序计数器不是单纯的一条指令加一 函数调用，实际上是先把调用处以下的指令先存放在栈，然后进行call到函数体进行，处理完函数体后，再回到调用处，把栈上存放的指令读入到程序计数器上，再接着往下 说到划分内存，实际上要用到基址寄存器和变址寄存器，我们所说的实际地址值就是基址寄存器的值加上变址寄存器的值，而变址寄存器实际上就是我们所熟悉的数组的索引 正，0，负实际上存在32位的标志寄存器上的前三位]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运算符和语句]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[js语句的格式 要养成每条语句后都写分号的习惯 在js代码中，空白没意义，为了让代码更直观更易于维护，可尝试养成在等号前后，加号等前后写空格的习惯赋值语句 由左边变量，赋值变量和右边被赋给的值组成 右边的表达式可以是直接量值var vm = 35;一个变量和直接量再加上运算符的组合var value = vm + 27;函数的调用var nvalue = escape();一行可以包含多个赋值语句var a = b = c = 23; 二元运算符 二元运算符有加(+)减(-)乘(*)除(/)取余(%)注意在js中除法保存的是浮点数而不是截取的整数 这里重点说一下加法运算符，在字符串那里要特别注意，当两个运算数中有字符串时会优先将+解析为连接运算符12var vm = &quot;3.99&quot; + 2.7;document.write(vm); 结果：3.992.7 而对于其他的二元运算符，只要两个操作数中的字符串内只有数字就可以计算12var vm = &quot;3&quot; * 2;document.write(vm); 结果：6 为了在用加号时规避这种错误，最好采用parseInt或者parseFloat函数显式地转化一下字符串12var vm = parseInt(&apos;3&apos;) + 3;document.write(vm); 结果：6 一元运算符 一元运算符有负值运算符，自增运算符，自减运算符12345var vm = 2;var value = -vm;document.write(value);var nvalue = ++value;document.write(nvalue); 结果：-2-1 注意自增自减都有前置后置之分，前置是先自己变值在赋值，后置是先赋值在自己变值逻辑运算符，三元运算符，各种语句需要注意的因为有了c++基础就不多说什么事if循环啊啥的，记一点容易犯错的 注意短值运算，就是与的话当第一个表达式返回0，就不往下看了，这个直接就是假；是或的话当第一个表达式返回1，直接就是真，考虑到cpu等内存占用，应该把重要的依据放在前面 注意===和==区别，前面的是等同，现在已经广泛应用，因为当时字符串和数值比较，会先隐式地把字符串转化为数值型，用等同则返回false,用等于则返回true switch语句，注意写break,default;当多种情况是同一入口时，最好用如下形式： 1234case a:case b:case c:document.write(&quot;hhhhh&quot;); 注意if语句的条件里千万不能写等于号，最次也得写个== 当想至少进行一次循环时，选do···while而不用while 注意一下for循环中的for in型，在后面会用到比如遍历数组啥的，以后再说，先简单举个栗子1234object(&quot;a&quot;:b,&quot;c&quot;:d)for(x in object)&#123; txt += object[x] ;&#125; 结果：cd]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day1]]></title>
    <url>%2F2019%2F05%2F04%2Fday1%2F</url>
    <content type="text"><![CDATA[CPU和内存是由很多的晶体管组成，他俩合称IC（集成电路） CPU由寄存器，运算器，控制器和时钟组成 程序运行过程：首先由程序员用高级语言写出程序，然后把程序编译成机器语言（即exe文件），然后将这个exe文件在内存上存一个副本，然后再在CPU上解析运行 将CPU的解析和运行过程放大来讲，是时钟先发出时钟信号，cpu开始工作啦，他先让寄存器去抓内存上的数据，然后运算器进行运算，然后控制器通过运算结果来控制整个计算机，其实也就是控制输入输出什么的 实际上，对于程序员来说可以把CPU简单的理解为是很多很多寄存器的集合体，寄存器有很多种，不仅是他们存储的类型上，比如有的是存数值这种数据的，有的他是存地址这样的数据 汇编语言是由助记符组成的（比如将addition写成add），他和机器语言实际上是一一对应的，每一个机器语言实际上都有对应的汇编语言。因而，我们把将汇编语言转换成机器语言成为汇编过程，把机器语言转换为汇编语言称为反汇编过程 其实，编译器汇编器这种的并不是我们所想的一种组件什么的，他其实就是一个程序 我们可以简单地把程序运行的过程就当成是各种寄存器之间的处理，因此我们只要知道CPU是寄存器的集合体就好 内存，我们叫主储存器，现在一般都是DRAM（动态随机存储器），就是储存数据啊啥的，1个字节是8位，每个都有地址]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型与变量]]></title>
    <url>%2F2019%2F05%2F04%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[标识符 标识符只能由数字，字母，$符和下划线表示 首字符必须是字母或$符或下划线，切记不能是数字 在所使用的的作用域内，每个变量的标识符是唯一的 可在变量标识符中使用Unicode的字母和数字，官网链接 可使用转义序列 区分大小写 不得使用js关键字，ECMA 262规范的保留字，浏览器中典型的保留字，具体如下图 js关键字 ECMA 262规范的保留字 浏览器中典型的保留字 尽量使用有意义的，提高可维护性 一些小规范：①项目的集合名称应用复数②对象名首字母大写③函数和变量以小写字母开始并使用驼峰法,也可每个单词间用下划线作用域 局部变量：在一个函数内定义，初始化，函数结束时变量不存在 全局变量：在所有地方都可访问，包括引入的js库 要养成写var的习惯，因为当你想要定义一个局部变量但没有写var就会被当做全局变量，也就是说全局变量可不写var但最好也要写字符串型 单引号和双引号作用一样，不做区别；但是当需要嵌套时不能同型套同型，只能是单引号套双引号或双引号套单引号 字符串中可包括转义序列，例如 \n \\ \&#39; \&quot; 可使用escape函数和unescape函数进行编码和解码，但需要注意的是这两个函数不能处理非ASCII码字符，这是可使用encodeURI和decodeURI函数，下面是使用escape函数和unescape函数的示例12document.write(escape(&quot;sbadkf65488$%^&quot;));document.write(unescape(&quot;sbadkf65488%24%25%5E&quot;)); 结果：sbadkf65488%24%25%5Esbadkf65488$%^ 空字符串是一种特殊情形，一般用来初始化 字符串连接:12var year=2019;document.write(&quot;今年是&quot;+year+&quot;年&quot;); 结果：今年是2019年 toString函数，将其他类型转换为字符串类型123document.write(boo.toString());//显示数据类型document.write(typeof boo.toString()); 布尔型 只有true和false两种，不能用引号包起来 Boolean函数,将其他类型转化为布尔型。需要注意的是没有toBoolean函数了，是Boolean函数！！！！还有强调一下有管字符串转成布尔型，当是空字符串时返回false，当是一个及以上空格时返回true,具体实践如下1234var s=Boolean(&quot;&quot;);document.write(s);var r=Boolean(&quot; &quot;);document.write(r); 结果：falsetrue 数值型 js中数字是浮点型，需要注意的是，js的计算能力不是很强，所以在数字方面一般不是很精确 可取数范围是-2e31到2e31;js中规定正无穷用Infinity表示，负无穷用-Infinity表示；当某函数出现溢出时则会返回一个Infinity（正无穷） parseFloat()和parseInt(),这两个函数都可用于在字符串中提取出数字，但需要注意的是只能提取出第一个字符就是数字的字符串否则报错，其次，parseInt()只取整数部分，注意事项截取而不是四舍五入;这两个函数还可将八进制或十六进制数转化为十进制，只需在后面加一个参数默认为10，具体例子如下1234var str1=parseInt(&quot;0x5F&quot;,16);document.write(str1);var str2=parseFloat(&quot;171.8cm&quot;);document.write(str2); 结果：95171.8 isFinite函数，用来判断无穷大，当值是无穷大或NaN时返回false,否则返回true Number函数，将其他数据类型转换为数值型,注意字符串类型，只有在字符串内全部是数字时才有用，否则返回NaN12var str2=Number(&quot;171.8cm&quot;);document.write(str2); 结果：NaN 常量const 变量名 = 值； 只定义一次 null与undefinedjavaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺 javaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 null值则是表示空对象指针 其实，null就给他理解成一个空对象，暂时赋给一个变量，而undefined就是当访问为初始化的变量时返回undefined]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[myBlog]]></title>
    <url>%2F2019%2F05%2F04%2FmyBlog%2F</url>
    <content type="text"><![CDATA[嘻嘻嘻。 吼吼吼。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
