<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[扩展运算符和rest运算符]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[扩展运算符和rest运算符都是三个点…,可以当做没什么区别，但各有各的用处。 扩展运算符 第一个用处就是在定义函数时不知道有几个参数，这个时候扩展运算符就可以登场了,下面的arg只是表示参数的意思，可以改成其他字符 1234567function func(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);&#125;func(1,2,3); 输出的结果是1,2,3,undefined。 看看转换成的ES5语法，真的为我们简化了很多东西 1234567function func() &#123; console.log(arguments.length &lt;= 0 ? undefined : arguments[0]); console.log(arguments.length &lt;= 1 ? undefined : arguments[1]); console.log(arguments.length &lt;= 2 ? undefined : arguments[2]); console.log(arguments.length &lt;= 3 ? undefined : arguments[3]);&#125;func(1, 2, 3); 而且我们可以看到他考虑到了undefned，就不会引起报错，如果我们用常规的ES5写，像下面这样，就会引发报错 1234567function func(a, b, c) &#123; console.log(a); console.log(b); console.log(c); console.log(d);&#125;func(1, 2, 3); 第二个用处就是在赋值数组的时候，其实在ES5中我们以为的赋值数组并不是赋值，他没有分配新的内存空间，可以理解为C++中的引用，当我们改变被赋值的数组，实际上我们不希望原来的数组也被改变，但是他会被改变，而用了ES6的对象扩展运算符就能很好的解决这个问题。 12345let arr1 = [1,2,3];let arr2 = [...arr1];arr2.push(4);console.log(arr2);console.log(arr1); 这时打印结果就是我们想看到的。而如果用ES5的方法(arr2 = arr1),arr1也会被改变，因此使用扩展运算符避免了很多麻烦，不报错的逻辑问题才是最可怕的。 rest运算符rest是剩下的意思，那他的用途跟扩展运算符不太一样的就是当参数你已知前面的几个后面不知道的时候就是rest上场的时候 1234567function func(first,...arg)&#123; console.log(arg.length); for(let val of arg)&#123; console.log(val); &#125;&#125;func(1,2,3,4,5); 这样我就能得到我除了已知的剩下的有几个参数，分别是什么。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[解构赋值就是把变量（数组，对象，字符串中的元素拿出来）-&gt;解构，再赋值，应用很多，还在初学阶段就只是把它结构出来打印下来还不会应用 数组解构赋值数组解构两边格式要对应，举个栗子 我们来看看正确的范例 12let [a,[b,c],d] = [1,[2,3],4];console.log(b); 下面是转换出来的ES5代码，看上去很和谐，打印出来的是我们想要的结果-&gt;2 123456var a = 1, b = 2, c = 3, d = 4;console.log(b); 下面是错误范例 12let [a,[b,c],d] = [1,2,3,4];console.log(b); 下面是转换好的ES5代码，我们可以看到相当的不和谐 12345678var _ref = [1, 2, 3, 4], a = _ref[0], _ref$ = _slicedToArray(_ref[1], 2), b = _ref$[0], c = _ref$[1], d = _ref[2];console.log(b); 下面再来看看赋默认值，这里着重讲一下undefined和null，当你赋值成undefined就是什么都没有的意思，并没有覆盖掉默认值，而你赋值成null则返回的就是空null，他会覆盖掉你的默认值，再就是当你又没给默认值又没赋值时输出的是undefined 12let [a,b=2] = [1,null];console.log(b); 打印出来的是null 12let [a,b=2] = [1,undefined];console.log(b); 打印出来的是2 对象解构赋值对象的解构赋值与数组的不同就在于他不是顺序的，必须要前后名字一样才能对应上，数组后面我们知道是没有名字的，栗子如下 12let &#123;a,b&#125; = &#123;a:1,b:2&#125;;console.log(b); 输出的结果是2 12let &#123;a,c&#125; = &#123;a:1,b:2&#125;;console.log(b); 这时将报b is undefined的错 接下来是一个容易出错的地方，就是如果你是先定义了变量后来才对他解构赋值，那对于这个报错，一个括号就可以解决 123let a;(&#123;a&#125;=&#123;a:1&#125;);console.log(a); 结果如你所愿会打印出1 字符串解构赋值字符串解构赋值并不常用但存在就有他存在的道理，这里简单的写个栗子 12let [a,b,c] = 'xue';console.log(a); 结果也是如愿的x，这里说一下能用单引就用单引，可以减少解析时的负担。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[声明方式]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在ES5中声明变量只有var一种形式，是局部啊还是全局啊很麻烦去区别。ES6就将声明方式升级了那么一下子，全局用var，局部用let,常量用const 一· const先来说说这个const,因为我想把let和var放在一起来讲。const嘛，C++里也有，大家都知道这是声明常量的，就是有一个量你不想动他，但是可能时间长了你忘了我之前想的是不能动他，这个时候如果当初你早早的就把他用const方式声明他就不怕犯错啦。一动就报错，下面举个栗子看看 123const a = 1;var a = 2;console.log(a); 我们可以看到我先把a给用const形式声明了，接下来我用全局var方式要把a给改了，这个时候我打印a，人家我npm run build都不给我转换成功了，报错如下 这样就规避了很多麻烦，报错比不报错好多了。 二· let与var接下来就是let和var这两个方式了，这两种方式各有各的好处，但是推荐去尝试多用用let，因为这样在一些函数体里呀，循环里呀，你用了局部的形式不至于找不到错误找好久，因为你用局部的了，后面你做错事了他会给你报错。有报错信息，找错误就方便很多。在这里我就不证明var是全局的,let是局部的了。我写一个栗子。像在C++里我再循环里声明了一个i，他是局部的，我拿出来就不能用了，这个循环之后我还可以声明一个i，但是不影响我之前那个循环里的i，我不污染数据。想想在js里，我要是用var，好多循环，我都用i，然后循环外部我有把i改来改去是不是就乱套了。 1234for(let i=0;i&lt;10;i++)&#123;console.log(i);&#125;console.log(i); 我们看到找不到i,这就是用let的好处,局部就是局部，谁也动不了。下面再看看npm run build后也给我们人性化的区分了一下。 1234for (var _i = 0; _i &lt; 10; _i++) &#123; console.log(_i);&#125;console.log(i);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[环境搭建]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ES6有很多新特性简化了一些东西，但是因为还是有浏览器不兼容他，因此环境搭建就包括了将ES6转换成ES5以及简化转换命令 首先看看初始的文件目录 src下的index.js使我们写ES6代码的地方 dist是用来存放转换好的es5代码的地方 index.html是入口文件，要引入的是src目录下的js文件 1&lt;script src="dist/index.js/"&gt;&lt;/script&gt; 初始化项目 1npm init -y -y是直接生成项目的操作，就不用你一步步确认来修改项目，在执行完该命令后会生成一个package.json，可以自行改一下author,discription这两项 基本配置 全局安装babel-cli 1npm install -g babel-cli 本地安装babel-preset-es2015 和 babel-cli 1npm install --save-dev babel-preset-es2015 babel-cli 在根目录下新建.babelrc 123456&#123; "presets":[ "es2015" ], "plugins":[]&#125; 这时就可以用命令来讲我们写好的ES6转换成ES5 1babel src/index.js -o dist/index.js 到目前为止，我们的目的已经达到了，但是我想不要每次都输那么长的命令来转换，我们可以讲package.json中的&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;修改为&quot;build&quot;:&quot;babel src/index.js -o dist/index.js&quot; 以后就可以直接用npm run build来转换]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[actions]]></title>
    <url>%2F2019%2F06%2F03%2Factions%2F</url>
    <content type="text"><![CDATA[actions虽然功能上和mutations一样都是修改状态的，但mutations是同步的，actions是异步修改状态，那什么是异步，就好像你在网上购物付完款了你就什么不用管了，想做什么做什么，而你买的东西则会被卖家按部就班的操作最后运输到你面前，而同步就好像是你在商场买电器，必须等店员去仓库取货然后跟着你回家，你才能做其他事。在编程中，同步就是你必须执行完我这个步骤你才能往下走，就像mutations的操作，而actions是我调了之后会像是在另一个支路去完成我要的这个任务，而我本来的这个支路就可以接着往下走 1import &#123;mapState, mapMutations,mapActions&#125; from 'vuex' 1234methods: &#123; ...mapMutations(['add', 'reduce']), ...mapActions(['addAction','reduceAction']) &#125;, 12&lt;button @click="addAction"&gt;+&lt;/button&gt; &lt;button @click="reduceAction"&gt;-&lt;/button&gt; 123456789101112const actions = &#123; addAction(context)&#123; context.commit('add',10); setTimeout(()=&gt;&#123;context.commit('reduce',1)&#125;,3000); console.log("我比reduce先执行"); &#125;, reduceAction(&#123;commit&#125;)&#123; commit('reduce',1) &#125;&#125;//context：上下文对象，这里你可以理解称store本身。//&#123;commit&#125;：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。 需要注意的是这里我们加了个验证异步，你可以看到就算没执行setTimeout，控制台还是马上输出了]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[getters]]></title>
    <url>%2F2019%2F06%2F03%2Fgetters%2F</url>
    <content type="text"><![CDATA[getters实际上就是对数据进行的一种提前处理加工过滤，就像之前那加减按钮那个例子，我就可以用getters让她每次进行加减之前先加12 12345678910const getters = &#123; count:function(state)&#123; return state.count+=12; &#125;&#125;export default new Vuex.Store(&#123; state, mutations, getters&#125;) 1import &#123;mapState, mapMutations, mapGetters&#125; from 'vuex' 12345computed: &#123; ...mapState(['count']), ...mapGetters(['count']) &#125;, 注意这里用到的…是es6语法，为了避免前面的被后面的覆盖掉,而且我直接用的mapGetters这个简写方法了]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mutations修改状态]]></title>
    <url>%2F2019%2F06%2F03%2Fmutations%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[首先说一下传值 12345678const mutations = &#123; add(state,num)&#123; state.count+=num &#125;, reduce(state,num)&#123; state.count-=num &#125;&#125; 12&lt;button @click="$store.commit('add',2)"&gt;+&lt;/button&gt;&lt;button @click="$store.commit('reduce',3)"&gt;-&lt;/button&gt; 然后跟上篇一样在调用的时候写法太烦，类似的我们用mapMutations 12 import &#123;mapState,mapMutations&#125; from'vuex'methods:mapMutations(['add','reduce']), 12&lt;button @click="add(1)"&gt;+&lt;/button&gt;&lt;button @click="reduce(1)"&gt;-&lt;/button&gt;]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[state访问状态对象]]></title>
    <url>%2F2019%2F06%2F02%2Fstate%E8%AE%BF%E9%97%AE%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在之前的小栗子里虽然已经可以实现功能，但是在接受数据时，那么一大长串很烦，下面就用三种方法可以直接写花括号就能访问，其中第三种是最常用的 第一种 123456computed:&#123; //这是es6语法，就是个函数 count()&#123; return this.$store.state.count &#125; &#125; 第二种 先引入mapState 12import &#123;mapState&#125; from 'vuex'//注意一定不能忘了花括号 12345//对象&#123;&#125;computed:mapState(&#123; //es6中的箭头函数 count:state=&gt;state.count &#125;) 第三种,采用数组形式[]，同样也要先引入mapState 1computed:mapState(['count'])]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex入门]]></title>
    <url>%2F2019%2F06%2F02%2Fvuex%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[vuex是专门为vue服务的管理状态的一个东西，也可以说是管理data中需要共用的属性，下面这个小栗子就是个入门，里面的很多东西具体的意思会在后面补充，也许这个栗子做完之后会觉得比以前做的麻烦，但是我们主要是想用一个公共的思想他可以被任意一个component调用 怎么安装vuex就不说了，首先在src下建一个vuex文件夹，在它下面建一个store.js来做仓库，以后我们主要就在这个下面引入vuex的操作，剑豪之后首先引入vue和vuex 12import Vue from 'vue';import Vuex from 'vuex'; 再加一行代码就可以使用vuex了 1Vue.use(Vuex); 在仓库中放共用的数据，state也可以说是状态 123const state = &#123; count:1&#125; 加两个方法，这里就放在可修改的mutations里 12345678const mutations = &#123; add(state)&#123; state.count++ &#125;, reduce(state)&#123; state.count-- &#125;&#125; 暴露出去 1234export default new Vuex.Store(&#123; state, mutations&#125;) 要注意mutations是固定写法 下面就要在想应用vuex的组件里动手了 123456789&lt;div&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;hr /&gt; &lt;p&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/P&gt; &lt;button @click="$store.commit('add')"&gt;+&lt;/button&gt; &lt;button @click="$store.commit //注意必须写单引号才行 ('reduce')"&gt;-&lt;/button&gt;&lt;/div&gt; 注意调用的写法 1234567891011121314&lt;script&gt; import store from '@/vuex/store' //注意是写在暴露前面的 export default&#123; name:'Hi1', data()&#123; return&#123; message:'Hello Vuex!' &#125; &#125;, store //在data后 &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程式导航]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[编程式导航就是取代router-link方法来写导航，他是运用javascript逻辑来写，这里常用的就是前进后退到某一页 123&lt;button @click="goForward"&gt;前进&lt;/button&gt;&lt;button @click="goBack"&gt;后退&lt;/button&gt;&lt;button @click="goHome"&gt;回首页&lt;/button&gt; 123456789101112methods:&#123; goForward:function()&#123; this.$router.go(1); &#125;, goBack:function()&#123; this.$router.go(-1); &#125;, goHome:function()&#123; this.$router.push('/'); //注意这里是push不是go了，然后里面写什么路径就能跳到哪了 &#125; &#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由中的钩子函数]]></title>
    <url>%2F2019%2F05%2F28%2F%E8%B7%AF%E7%94%B1%E4%B8%AD%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[路由中的钩子函数我们一般只用两种，他们可以写在index.js中，也可写在模板，但是写在index.js中只能写beforeEnter不能写离开的钩子函数，而且在模板里能写两个都要在中间加一个Route,无论哪种书写方式，都要注意是使用三个参数的箭头函数，一定要写next(),它相当于一个开关，有了他才能接着跳转 index.js 12345beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125; Hi.vue 12345678910beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125;, beforeRouteLeave:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mode设置和404处理]]></title>
    <url>%2F2019%2F05%2F28%2Fmode%E8%AE%BE%E7%BD%AE%E5%92%8C404%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先此mode非彼mode，这里的mode 是指在用户浏览器你上url形式的,如果喜欢简洁的就用history,如果要有井号的就用hash全品个人喜好，那就在index.js下引入mode 1mode:'history'//或hash 404处理就是在用户输错地址或者你自己随便写个to到标签是错的，为了更好的用户体验而设置的 index.js 1234&#123; path:'*',//*就表示404页面 component:Error//写这步就意味着要建个Error.vue和import一下&#125; Error.vue 12345678910111213141516&lt;template&gt;&lt;div&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;h2&gt;找不到此页面&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'Error', data:function()&#123; return&#123; message:'Error:404' &#125; &#125; &#125;&lt;/script&gt; App.vue 1&lt;router-link to="/sdfgsadh"&gt;我是瞎写的&lt;/router-link&gt;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由过渡动画]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%B7%AF%E7%94%B1%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[路由过渡动画就是在切换路由的时候加点动画效果，这里就是把router-view用transition包起来，然后给他个name叫fade， 然后fade有四个类名，就通过这四个类名给路由加动画即可，更酷炫的效果需要有css和js功底，当然也可以用插件，然后还有个mode属性,他只有两个值，一个是in-out一个是out-in顾名思义就知道什么意思了，这里我们用out-in更好看一点 123&lt;transition name="fade" mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 12345678910111213.fade-enter &#123; opacity:0;&#125;.fade-leave&#123; opacity:1;&#125;.fade-enter-active&#123; transition:opacity 0.5s;&#125;.fade-leave-active&#123; opacity:0; transition:opacity 0.5s;&#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[alias别名]]></title>
    <url>%2F2019%2F05%2F27%2Falias%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[alias别名的作用与redirect的重定向差不多，只不过alias更友好一点，他不会在用户那边地址栏上把url改了 index.js 123456&#123; path: '/Hi1', name: 'Hi1', component:Hi1, alias:'/liu'&#125; App.vue 12&lt;router-link to="/Hi1"&gt;Hi1&lt;/router-link&gt;&lt;router-link to="/liu"&gt;goHi1&lt;/router-link&gt; 还有一个坑要说一下，就是不要再根目录(path:’/‘)下用别名，会出错]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重定向]]></title>
    <url>%2F2019%2F05%2F27%2F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[重定向实质上就是在路径不同的情况下我想跳转到同一页面的需求，下面将展示传参数和不穿参数的两种重定向，操作很简单,在index.js中就是把想要定位的路径复制到redirect里 index.js 1234567 &#123; path: '/gohome', redirect:'/' &#125;,&#123; path: '/gohi/:newsId(\\d+)/:newsTitle', redirect:'/Hi/:newsId(\\d+)/:newsTitle'&#125; 尤其要注意的是千万不要多写个name App.vue 12&lt;router-link to="/gohome"&gt;回首页&lt;/router-link&gt;&lt;router-link to="/gohi/34/aaaam"&gt;Hi&lt;/router-link&gt;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL传值]]></title>
    <url>%2F2019%2F05%2F27%2FURL%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[虽然现在前后端分离，之间的数据传递用接口，但是url传值方法还是很常用的 第一步：在index.js文件的路径中添加想传的值 12345&#123; path: '/Hi/:newsId(\\d+)/:newsTitle', name: 'Hi', component:Hi&#125; 可以看到我只需要在path后加:/就好，同时还用()方式在里面加了个正则表达式，规定只允许传递过来的是数字，当非数字时就不显示 第二步：在App.vue中通过router-link传递值 1&lt;router-link to="/Hi/12/hhhhhh"&gt;Hi&lt;/router-link&gt; 注意到，我的id传的是数字才行 第三步：在Hi.vue中接收值 12&lt;p&gt;&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; $route.params.newsTitle &#125;&#125;&lt;/p&gt; 特别要注意的是，只能是params，别写成Hi了，因为在vue中params就是用来传参数的量]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单页面多路由]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%A4%9A%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue提供的路由非常方便我们把页面分开成几个部分分别操作，下面就动手简单做一个第一步：在App.vue中加两个路由，为了方便看效果，简单分别给他们写个内联样式 123&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name = "right" style="background-color:red;width:50%;height:100px;float:right"&gt;&lt;/router-view&gt;&lt;router-view name = "left" style="background-color:black;width:50%;height:100px;float:left"&gt;&lt;/router-view&gt; 注意只能有一个路由不写name，他是默认值defaut 第二步：在index.js配置路由，import就不多说了，只要加路由必须写import才能生效 123456789&#123; path: '/', name: 'HelloWorld', components: &#123; default:HelloWorld, right:Hi1, left:Hi2 &#125; &#125; 注意这里的坑，要把component改成components,conponents对象里的都没有引号 至此，单页面多路由我们就做出来了，但是再深化一下，我们再加个导航，实现让两个路由调换一下位置，这主要是之前的知识，直接放一下代码 index.js 12345678&#123; path: '/Hi', name: 'Hi', components: &#123; default:Hi, right:Hi2, left:Hi1 &#125; App.vue 1234&lt;div&gt; &lt;router-link to="/"&gt;首页&lt;/router-link&gt;| &lt;router-link to="/Hi"&gt;Hi&lt;/router-link&gt;&lt;/div&gt; 结果图：]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[参数传递]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[vue-router中提供了两种传参方式，一种是name传递法，另一种是绑定to的传递方法。第一种不常用,因为第一种的name实际上用在第二种的参数上 name传值法 第一步：完善name 在上个博客我们配置了index.js，他是这样的 123456789101112131415161718export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', name:'Hi', component:Hi, children:[ &#123;path:'/',component:Hi&#125;, &#123;path:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 现在我们要把它写成这样的 1234567891011121314151617export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', component:Hi, children:[ &#123;path:'/',name:'Hi',component:Hi&#125;, &#123;path:'Hi1',name:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',name:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 因为如果我们不把这个name给完善了会报错，首先Hi1,Hi2没有name更别说传值了，其次在vue中，当一个路由有了子路由，并且子路由中有一个是自己本身，那么这个路由写的name将不起作用，所以应在子路由里写上他的name 第二步：在App.vue上插值来接收值 1&lt;p&gt;&#123;&#123;$route.name&#125;&#125;&lt;/p&gt; 绑定to传值 第一步：在App.js上动手 1&lt;router-link :to="&#123;name:'Hi1',params:&#123;username:'liuxue'&#125;&#125;"&gt;Hi1页面&lt;/router-link&gt; 注意看这里才是name真正的用武之地啊。还有vue中统一用params来传递参数，他是一个对象形式 第二步：在Hi.vue上接收值 1&lt;p&gt;&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt; 多一嘴，一定要记得在.vue里面写的都是大的套小的形式，一定要放在个div里才行 现在来看看综合商量个博客实际的效果，就拿Hi1来分析分析一下 可见vue的父子关系多么清晰，一定是先入口文件再父文件再子文件]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[子路由]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%AD%90%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[子路由的应用可以说还是很广的，也就是说当我给某个组件设置了子路由，那么每当我点击这个子路由，这个组件都会显示，就好像淘宝里的推荐，当我选中一类时他会给你推荐相似的，而我这一类会一直留在界面上，只是在下面展示我的各个子路由，下面就来操作一下子路由的配置方法 第一步： 还是新建新的组件，就不多说了第二步：去到要配置子路由的组件123456&lt;template&gt; &lt;div class="Hi"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 一定一定要注意我们引入路由机制的这个标签位置很重要，他必须写在一个有内容的的大标签里（这里是div），不然你一写这个标签就会疯狂报错 第三步：去index.js配置123456789101112131415161718192021222324252627import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Hi from '@/components/Hi'import Hi1 from '@/components/Hi1'import Hi2 from '@/components/Hi2'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', name:'Hi', component:Hi, children:[ &#123;path:'/',component:Hi&#125;, &#123;path:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 首先：一定要import 然后就去写子路由器配置了，他是写在指定的那个component底下，他也是个数组，根据每个路由都是一个对象相应的去写，因为现在还用不上name，所以这里先省略了name，特别要注意的是，path的写法，后两个是没有/的 第四步：去入口文件App.vue改写模板123456&lt;div&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/Hi&quot;&gt;Hi页面&lt;/router-link&gt; &lt;router-link to=&quot;/Hi/Hi1&quot;&gt;Hi1页面&lt;/router-link&gt; &lt;router-link to=&quot;/Hi/Hi2&quot;&gt;Hi2页面&lt;/router-link&gt; &lt;/div&gt; 实际上就是加了后两行]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F05%2F26%2Fvue-router%2F</url>
    <content type="text"><![CDATA[vue-router是vue的很重要的一部分，他不是物理的那种路由器啊啥的，可以把他理解为像a标签，但是因为vue-cli开发出来的实际上是单页面应用，所以用a标签是不够用的，因此vue帮我们配置了这么一个功能，首先就先了解一下要用到的几个重要文件 配置文件讲解 components这是vue的公共组件他的格式是: 123456789101112131415&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: '', data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/*scoped代表只给这个页面设的css样式,否则将应用到所有页面*/&lt;/style&gt; App.vue这是页面的入口文件，也就是主页面，你引入东西都得放进去才能显示，也就是前面提到的单页面应用的那个单页面 123456789101112131415161718192021222324&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 说明引入路由机制，在印后的配置子路由时会用到也就是说把它加在哪个页面，哪个页面就可以使用路由机制 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; index.js是router下的文件也就是配置路由的文件 12345678910111213141516import Vue from 'vue' //引入Vueimport Router from 'vue-router'//引入bue-routerimport HelloWorld from '@/components/HelloWorld'//引入根目录下的HelloWorld.vue组件Vue.use(Router)//Vue全局使用Routerexport default new Router(&#123; routes: [//配置路由，这里是数组，每个链接都是一个对象 &#123; path: '/',//链接路径 name: 'HelloWorld',//路由名称 component: HelloWorld//对应组件模板 &#125; ]&#125;) 下面进入正题，我们自己来写路由，也就可以写个导航啦，下面一起来看看三步走 第一步：新建新的组件在components下新建个Hi.vue，里面内容直接复制稍微改下，因为我们就是想学学这个，所以就把msg改改，class，name改改就好了。至此，第一步就走完了 第二步：配置index.js路由12345678910111213141516171819202122import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Hi from '@/components/Hi'// 直接复制上面的改改就行了Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; // 说白了就是新建个对象，剩下的改改就行了 path:'/Hi', name:'Hi', component:Hi &#125; ]&#125;) 第三步：在App.vue引入我们新写的组件12345678910&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;div&gt; &lt;router-link to="/"&gt;首页&lt;/router-link&gt; &lt;router-link to="/Hi"&gt;Hi页面&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 注意两个点，第一个：应该用div包着这两个，因为这样既起了换行作用，又符合vue的大的包小的原则；第二个：这里面有陌生的标签，这个标签可以把他理解成a标签，这就是vue给我们准备好的，尤其注意to里面的路径必须和index.js中写的path一样]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义组件]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;liuxue&gt; &lt;!-- 用 key value形式传递数据 --&gt; &lt;p slot="url"&gt;&#123;&#123;liuxueData.url&#125;&#125;&lt;/p&gt; &lt;p slot="name"&gt;&#123;&#123;liuxueData.name&#125;&#125;&lt;/p&gt; &lt;p slot="skill"&gt;&#123;&#123;liuxueData.skill&#125;&#125;&lt;/p&gt; &lt;/liuxue&gt; &lt;/div&gt; &lt;template id="liu"&gt; &lt;!-- Vue2.0规定必须用大的包个小的 --&gt; &lt;div&gt; &lt;!-- 接收数据 --&gt; &lt;p&gt;博客地址：&lt;slot name="url"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;slot name="name"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;技能：&lt;slot name="skill"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var liuxue = &#123; template:'#liu' &#125; var app = new Vue(&#123; el:'#app', data:&#123; liuxueData:&#123; url:'snowFlakeXue.github.io', name:'liuxue', skill:'前端' &#125; &#125;, components:&#123; 'liuxue':liuxue &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实例事件]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在构造器外添加事件$on 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;button @click="add"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;button onclick="reduce()"&gt;reduce&lt;/button&gt;&lt;/p&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++ &#125; &#125; &#125;) app.$on('reduce',function()&#123; this.count--; console.log('构造器外方法被调用') &#125;) function reduce()&#123; app.$emit('reduce') &#125; //当按钮在作用域外用$emit调用 once事件$once 1&lt;p&gt;&lt;button onclick="reduceOnce()"&gt;reduceOnce&lt;/button&gt;&lt;/p&gt; 1234567app.$once('reduceOnce',function()&#123; this.count--; console.log('只执行一次的方法被调用') &#125;) function reduceOnce()&#123; app.$emit('reduceOnce') &#125; off事件$off 1&lt;p&gt;&lt;button onclick="off()"&gt;off&lt;/button&gt;&lt;/p&gt; 123function off()&#123; app.$off('reduceOnce') &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实例方法]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;button onclick="destroy()"&gt;销毁&lt;/button&gt; &lt;button onclick="reload()"&gt;更新&lt;/button&gt; &lt;button onclick="tick()"&gt;修改&lt;/button&gt; &lt;script&gt; var app = Vue.extend(&#123; template:`&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`, data: function()&#123; return &#123; message:'hello world' &#125; &#125;, mounted:function()&#123; console.log('我被挂载了') &#125;, destroyed:function()&#123; console.log('我被销毁了') &#125;, updated:function()&#123; console.log('我被更新了') &#125; &#125;) //挂载方法 var vm = new app().$mount('#app'); //销毁方法 function destroy()&#123; vm.$destroy(); &#125; //更新方法 function reload()&#123; vm.$forceUpdate(); &#125; //修改方法 function tick()&#123; vm.message = 'hello Vue', vm.$nextTick(function()&#123; console.log('我被修改了') &#125;) &#125; &lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[实例入门]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[实例就是在构造器外部操作构造器内部的属性和方法，他让Vue可以和其他框架一起使用和jQuary一起使用 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message:'hello world' &#125;, mounted:function()&#123; $('#app').html('hello Vue') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 实例调用自定义方法 1app.add();]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[delimiters选项]]></title>
    <url>%2F2019%2F05%2F25%2Fdelimiters%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[delimiters是用在当我们想修改一些东西比如我不想用花括号来绑定值时使用,他一般在数组里有两个元素，第一个是改变后的前面的，另一个是改变后后面的部分 123456789101112131415161718&lt;div id="app"&gt; &lt;p&gt;$&#123;count&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, delimiters:['$&#123;','&#125;'] &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[extends选项]]></title>
    <url>%2F2019%2F05%2F25%2Fextends%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[extends方法和mixins差不多，是个扩展选项，只是在构造器里写的时候他是个对象（只能有一个对象），而mixins可以写一个数组 123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var addLog = &#123; updated:function()&#123; console.log('我是扩展出来的') &#125;, methods:&#123; add:function()&#123; this.count++; console.log('我是扩展出来的方法') &#125; &#125; &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, updated:function()&#123; console.log('原生') &#125;, extends:addLog &#125;) &lt;/script&gt; 需要注意的是，扩展出来的方法并没有执行，这个是与mixins一样，因为他与构造器内的方法重名了因而不能执行]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mixins选项]]></title>
    <url>%2F2019%2F05%2F25%2Fmixins%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[mixins是混入选项操作，一般用于在你写完构造器后想加些东西却不想污染构造器时使用，一种是当很多地方需要用时作为全局的使用，随时可以调用，同时下面的栗子中构造器原生的updated和构造器内的和全局的还有顺序规则，需要注意的是如果构造器内的mixin的名和构造器内方法的名字重了，就不存mixin了 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //全局的 Vue.mixin(&#123; updated:function()&#123; console.log('全局mixin') &#125; &#125;) var addLog = &#123; updated:function()&#123; console.log('mixin') &#125; &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, //原生 updated:function()&#123; console.log('原生') &#125;, //构造器内 mixins:[addLog] &#125;) &lt;/script&gt; 顺序：全局 构造器内 原生]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[watch选项]]></title>
    <url>%2F2019%2F05%2F25%2Fwatch%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[watch选项用于监控数据变化，一种是直接在构造器内用watch选项，一种是为了避免耦合度在构造器外使用 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &lt;p&gt;今日温度是：&#123;&#123;temperature&#125;&#125;℃&lt;/p&gt; &lt;p&gt;今日穿衣建议是：&#123;&#123;clothingAdvice&#125;&#125;&lt;/p&gt; &lt;button @click="raiseTemperature"&gt;升高温度&lt;/button&gt; &lt;button @click="reduceTemperature"&gt;降低温度&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var clothingAdvice=['T恤','夹克','棉服'] //在实际开发中一般是采用这种数组写法直接从数据库调 var app = new Vue(&#123; el:'#app', data:&#123; temperature:14, clothingAdvice:'夹克' &#125;, methods:&#123; raiseTemperature:function()&#123; this.temperature+=5; &#125;, reduceTemperature:function()&#123; this.temperature-=5; &#125; &#125;, watch:&#123; //注意watch这里需要两个参数，一个是新的值(newVal),一个是旧的值(oldVal) temperature:function(newVal,oldVal)&#123; if(this.temperature&gt;=20)&#123; this.clothingAdvice=clothingAdvice[0]; &#125; else if(this.temperature&gt;=0&amp;&amp;this.temperature&lt;20)&#123; this.clothingAdvice=clothingAdvice[1]; &#125; else this.clothingAdvice=clothingAdvice[2]; &#125; &#125; &#125;) &lt;/script&gt; 12345678910//要写在构造器下面，因为用到实例化appapp.$watch('temperature',function(newVal,oldVal)&#123; if(this.temperature&gt;=20)&#123; this.clothingAdvice=clothingAdvice[0]; &#125; else if(this.temperature&gt;=0&amp;&amp;this.temperature&lt;20)&#123; this.clothingAdvice=clothingAdvice[1]; &#125; else this.clothingAdvice=clothingAdvice[2]; &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[methods选项]]></title>
    <url>%2F2019%2F05%2F24%2Fmethods%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[methods方法一般跟@click这样的绑定，下面有三个栗子，分别是简单的传值绑定，组件绑定，实例外绑定 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add(2)"&gt;add&lt;/button&gt; &lt;!-- .native的意思实质上就是调用原生的js方法，这个技巧很常用 --&gt; &lt;btn @click.native="add(3)"&gt;&lt;/btn&gt; &lt;/div&gt; &lt;button onclick="app.add(4)"&gt;实例化外&lt;/button&gt; &lt;script&gt; var btn=&#123; template:`&lt;button&gt;add组件&lt;/button&gt;` &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, components:&#123; 'btn':btn &#125;, methods:&#123; add:function(num)&#123; if(num !='')&#123; this.count+=num &#125; else this.num++ &#125; &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[computed选项]]></title>
    <url>%2F2019%2F05%2F24%2Fcomputed%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[computed选项一般用来改变原来的值得形式，使data选项里的值尽量的整洁简单，因此我们一般用computed选项来给绑定的值进行改变大小写啊，添加修饰啊。下面就举一个将新闻日期倒过来的小栗子，因为数据输入时是旧时间到新时间，而我们想要的是先看到新时间的新闻，所以在computed中使用computed就很有必要 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;newMessage&#125;&#125;&lt;/p&gt; &lt;ul&gt; &lt;li v-for="item in reverseNews"&gt;&#123;&#123;item.title&#125;&#125;-&#123;&#123;item.date&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message:100, news:[&#123;title:'新闻1', date:'2019/01/24'&#125;, &#123;title:'新闻2', date:'2019/01/25'&#125;, &#123;title:'新闻3', date:'2019/01/26'&#125;, &#123;title:'新闻4', date:'2019/01/27'&#125;] &#125;, computed:&#123; newMessage:function()&#123; return this.message='￥'+this.message+'元'; &#125;, reverseNews:function()&#123; return this.news.reverse(); &#125; &#125; &#125;) ; &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[propsData]]></title>
    <url>%2F2019%2F05%2F24%2FpropsData%2F</url>
    <content type="text"><![CDATA[实际上propsData他不是挂载个属性，它是一个选项，甚至说这很不常用，完全可以用组件实现，但是要认识他，他是个传递数据的选项 1234567891011121314&lt;div id="summer"&gt;&lt;/div&gt; &lt;script&gt; var summer = Vue.extend(&#123; template:`&lt;h2&gt;&#123;&#123;message&#125;&#125;-&#123;&#123;food&#125;&#125;&lt;/h2&gt;`, data:function()&#123; return&#123; message:'summer' &#125; &#125;, props:['food'] &#125;) new summer(&#123;propsData:&#123;food:'iceCream'&#125;&#125;).$mount('#summer') //注意写法sss &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[keyframes]]></title>
    <url>%2F2019%2F05%2F23%2Fkeyframes%2F</url>
    <content type="text"><![CDATA[与transition不同，这个可以在一开始就进行动画演示，无需操作，这在CSS动画中是很重要的部分，他可以让你任意调动，说白了，这个关键帧动画实际上就是多个补间动画,另外还有一种逐帧动画，它是一种特殊的关键帧动画，只不过他没有补间动画是一帧一帧的，但是他资源使用大，因此除了另两个动画搞不定的情况下尽量不要使用，因为他包含于keyframes里，因此说CSS设置动画实质上就两种transition和keyframes 12345678910111213141516171819202122232425&lt;style&gt; .container&#123; width:50px; height:50px; background-color: red; animation: run 1s ; &#125; @keyframes run&#123; 0%&#123; width:100px; &#125; 10%&#123; width: 20px; &#125; 50%&#123; width: 200px; &#125; 100%&#123; width:300px; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; 栗子中的run是动画名要与下面的@keyframes后的对应好了 当然transition里可以用的这里也可以用，比如说可以加上像linear这样的 1animation: run 1s linear ; 当只有前后两个节点时一般会写成from to来代替0% 100% 12345678@keyframes run&#123; from&#123; width:100px; &#125; to&#123; width:300px; &#125; &#125; 还有一些有意思的animation属性 设置动画倒着开始 1animation-direction: reverse; 设置动画不要回来了 1animation-fill-mode: forwards; 设置动画循环次数，这里的infinite是无数次 1animation-iteration-count: infinite; 设置动画停止 1animation-play-state: paused; 逐帧动画 123456789101112131415161718192021222324&lt;style&gt; .container&#123; width:100px; height:100px; border: 1px solid red; background:url("http://images2015.cnblogs.com/blog/733006/201611/733006-20161103171828065-1874183143.png") no-repeat; animation: run 1s ; animation-timing-function: steps(1); &#125; @keyframes run&#123; 0%&#123; background-position:0px 0px; &#125; 50%&#123; background-position:0px -80px; &#125; 100%&#123; background-position:0px 0px; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; 其实就是加个 12animation-timing-function: steps(1);/* 只能是1 */]]></content>
      <categories>
        <category>CSS动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[transition]]></title>
    <url>%2F2019%2F05%2F23%2Ftransition%2F</url>
    <content type="text"><![CDATA[transition(过渡)是用来设置补间动画的即自动填补两个画面中间的部分，但必须有前后变化，比如下面的栗子中，就得有个hover 123456789101112131415161718&lt;style&gt; .container&#123; width:50px; height:50px; background-color: red; transition: width 1s,background-color 1s; transition-delay: 2s; transition-timing-function: ease-in-out; &#125; .container:hover&#123; width:300px; height:50px; background-color: green; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; transition-property和transition-duration一般一起用，第一个表示做动画的属性，第二个表示动画进行时间，当多个属性同时使用动画时就用逗号隔开,也可以写成all 1s 1transition: width 1s,background-color 1s; transition-delay 只有一个时间参数使用来设置延迟的 transition-timing-function是用来定义动画进行方式，就是先快后慢啊还是匀速啊啥的，常见方式如下 具体实例如下 ease-in-out: linear: ease-in ease-out 一个需要翻墙的工具，用来自制动画方式]]></content>
      <categories>
        <category>CSS动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件标签]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[组件标签就是&lt;component&gt;&lt;/component&gt;,是vue自己定义的，可以用这个实现动态选择组件，详情看下面的小栗子 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt; &lt;component :is="ok"&gt;&lt;/component&gt; &lt;!-- vue中用v-bind:is实现动态组件 --&gt; &lt;button @click="changeComponent"&gt;changeComponent&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var componentA = &#123; template:`&lt;h2 style="color:red"&gt;A&lt;/h2&gt;` &#125; var componentB = &#123; template:`&lt;h2 style="color:green"&gt;B&lt;/h2&gt;` &#125; var componentC= &#123; template:`&lt;h2 style="color:pink"&gt;C&lt;/h2&gt;` &#125; var app = new Vue(&#123; el:'#app', data:&#123; ok:'componentA' &#125;, components:&#123; 'componentA':componentA, 'componentB':componentB, 'componentC':componentC &#125;, methods:&#123; changeComponent:function()&#123; if(this.ok==componentA)&#123; this.ok=componentB &#125; else if(this.ok==componentB)&#123; this.ok=componentC &#125; else this.ok = componentA &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[父子组件关系]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[下面我将举个小栗子来说明父子组件关系123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;panda&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; //子组件对象，必须写在父组件对象上面否则说他没定义 //在构造器外定义局部注册组件 var city = &#123; template: `&lt;h2&gt;四川是中国的城市&lt;/h2&gt;` &#125; //父组件对象 var panda = &#123; template: ` &lt;div&gt; &lt;h2&gt;熊猫来自四川&lt;/h2&gt; &lt;city&gt;&lt;/city&gt; &lt;/div&gt; `, components:&#123; 'city':city //注意写法 &#125; &#125; var app = new Vue(&#123; el:'#app', components:&#123; 'panda':panda//注意写法 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件属性设置]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[组件属性(props)的设置有两个坑，第一个坑是组件属性命名一定不能有-只能化成驼峰式，第二个坑是props是数组，不能写成对象形式而且他是写在template底下的； 组件属性设置有两种，一种是直接属性，一种是绑定data 直接设置属性 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;panda here="China"&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', components:&#123; 'panda':&#123; template:`&lt;h2&gt;我来自&#123;&#123;here&#125;&#125;&lt;/h2&gt;`, props:['here'] &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 绑定data 12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &lt;panda :here="message"&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data:&#123; message:'China' &#125;, components:&#123; 'panda':&#123; template:`&lt;h2&gt;我来自&#123;&#123;here&#125;&#125;&lt;/h2&gt;`, props:['here'] &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识组件]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%88%9D%E8%AF%86%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件实际上就是创建html不存在的标签，非常常用 注册全局组件123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app"&gt; &lt;are&gt;&lt;/are&gt;&lt;!--只能在vue实例化里用--&gt; &lt;/div&gt; &lt;div id="pp"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;script&gt; Vue.component('are',&#123; template:`&lt;h2&gt;我们&lt;/h2&gt;` &#125;) //不论构造器里有没有数据都要写这样才算实例化成功 var app = new Vue(&#123; el:'#app', data:&#123; &#125; &#125;) var pp = new Vue(&#123; el:'#pp', data:&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：都能用组件 注册局部组件1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id="app"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;div id="pp"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; &#125;, components:&#123; //注意引号 'are':&#123; template:`&lt;h2&gt;hello&lt;/h2&gt;` &#125; &#125; &#125;) var pp = new Vue(&#123; el:'#pp', data:&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：只有第一个才能用组件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[制作模板]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%88%B6%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Vue的模板(template)有三种创建方式 在Vue构造器内，这种情况只在template中语句少的时候适用，注意模板将会代替message1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`&lt;h2&gt;我是一个标签模板&lt;/h2&gt;` //注意是Tab键上面那个，为了避免和单引双引冲突 &#125;) &lt;/script&gt;&lt;/body&gt;``` ---### 在html里```html&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;!-- 注意不是放在实例化里 --&gt; &lt;template id="app2"&gt; &lt;h2&gt;我是一个模板&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`#app2`//设置响应 &#125;) &lt;/script&gt;&lt;/body&gt; 在js里,可从外部引用，在script标签后加一个src即可1234567891011121314151617&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script type="x-template" id="app3"&gt; &lt;h2&gt;我是模板&lt;/h2&gt; &lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`#app3` &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生命周期]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期又叫钩子函数，就是在某个节点进行某个操作，这里讲的是构造器里的生命周期，总共有十个，有两个需结合组件学习(activated,deactivated)，所以先学八个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;!-- 注意是onclick不是@click --&gt; &lt;button onclick="app.$destroy()"&gt;销毁&lt;/button&gt; &lt;script&gt; var app=new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, //注意要写在构造器里 beforeCreate:function()&#123; console.log('1-beforeCreat') &#125;, created:function()&#123; console.log('2- created') &#125;, beforeMount:function()&#123; console.log('3-beforeMount') &#125;, mounted:function()&#123; console.log('4-mounted') &#125;, beforeUpdate:function()&#123; console.log('5-beforeUpdate') &#125;, updated:function()&#123; console.log('6-updated') &#125;, beforeDestroy:function()&#123; console.log('7-beforeDestroy') &#125;, destroyed:function()&#123; console.log('8-destroyed') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.set]]></title>
    <url>%2F2019%2F05%2F18%2FVue-set%2F</url>
    <content type="text"><![CDATA[先举个调用构造器外数据的小栗子 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;button onclick="add()"&gt;add&lt;/button&gt; &lt;!-- 因为按钮在vue实例外，所以采用原声js方法onclick --&gt; &lt;script&gt; var outData = &#123; count: 1, goods: 'car' &#125; //注意这个数据放在vue构造器外 function add()&#123; // Vue.set(outData,'count',2) 且该方法只能让他变成2 //app.count++ outData.count++ &#125; var app = new Vue(&#123; el: '#app', data:outData//构造器外数据 &#125;) &lt;/script&gt;&lt;/body&gt; 由上述代码可见，想要调用构造器外数据由三种方法可行，那么为什么vue.set还有他存在的意义而且在开发中还很常用呢？看下面栗子 123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app" &gt; &#123;&#123;count&#125;&#125; &lt;ul&gt; &lt;li v-for="item in arr"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;button onclick="add()"&gt;add&lt;/button&gt; &lt;script&gt; var outData = &#123; count: 1, arr: ["aaa","bbb","ccc"] &#125; function add()&#123; // outData.count++, //outData.arr[1]="b" Vue.set(outData.arr,1,'b')//注意中间1的写法 &#125; var app = new Vue(&#123; el: '#app', data:outData &#125;) &lt;/script&gt;&lt;/body&gt; 解析：当不用Vue.set时，如果不设置改变count值，因为js本身限制，vue也就检测不到数组的改变包括数组长度或数组内元素变化，这个时候vue.set的存在就显得很必要，不用设置count变化,vue也能检测到数组变化，因此在上面代码的注释都取消，不用vue.set也行，但显然当我们不想引入count时，vue.set是最好的选择]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day4]]></title>
    <url>%2F2019%2F05%2F17%2Fday4%2F</url>
    <content type="text"><![CDATA[将二进制转换为小数，同样是各位乘以位权 计算机运算出错原因： 因此不是所有的十进制小数都可以用二进制表示，而计算机底层使用的都是二进制数，由此看来当计算一些不能直接化成二进制小数的将会像10/3一样，无限循环而不准确 为了避免这种出错可以把小数化成一定倍数好计算]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.extend]]></title>
    <url>%2F2019%2F05%2F17%2FVue-extend%2F</url>
    <content type="text"><![CDATA[因为还没学组件所以下面的将是一个简单的扩展实例构造器的小栗子，一般情况下扩展实例构造器是要和组件一起使用的1234567891011121314151617&lt;body&gt;&lt;!-- 最好写id形式，不要直接用标签 --&gt; &lt;div id="author"&gt;&lt;/div&gt; &lt;script&gt; //定义扩展构造器 var authorUrl = Vue.extend(&#123; template:'&lt;p&gt;&lt;a :href="authorUrl"&gt;&#123;&#123;authorName&#125;&#125;&lt;/a&gt;&lt;/p&gt;', data:function()&#123;//在Vue.extend里的data必须是函数 return&#123; authorName: 'liuxue', authorUrl:'https://snowFlakeXue.github.io' &#125; &#125; &#125;); //挂载（.$mount）到一个元素上 new authorUrl().$mount('#author'); &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义指令]]></title>
    <url>%2F2019%2F05%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[先举个小栗子要注意的是，vue提供的Vue-directive来自定义值令方法时要把这段代码写在vue实例化之前否则会报错，同时指令命名不能用驼峰法否则也会报错，V大写！ 代码里一些不熟悉的将在下面详细的讲讲 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="app"&gt; &lt;div v-change_color="color"&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;button @click="add"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.directive('change_color',function(el,binding,vnode)&#123; el.style='color:'+binding.value; &#125;); new Vue(&#123; el:'#app', data: &#123; num: 1, color:'red' &#125;, methods:&#123; add:function()&#123; this.num++; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 钩子函数（也叫生命周期） bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted:被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新 conponentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用 钩子函数的参数el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 binding的属性：(只包括了常用的，剩下的去官网找) name：指令名，不包括 v- 前缀。 expression：字符串形式的指令表达式 value：指令的绑定值 123456//注意引号 Vue.directive('change_color',function(el,binding,vnode)&#123; console.log(binding.value); console.log(binding.name); console.log(binding.expression); &#125;); vnode: Vue编译生成的虚拟节点。 上面小栗子的改写12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="app"&gt; &lt;div v-change_color="color"&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;button @click="add"&gt;add&lt;/button&gt; &lt;/div&gt; /*注意这个销毁应在app外，点销毁之后app就不运行了点add也不加一了 注意下面这个app是js中vue的app*/ &lt;button onclick="app.$destroy()"&gt;销毁&lt;/button&gt; &lt;script&gt; Vue.directive('change_color',&#123; bind:function(el,binding,vnode)&#123; console.log('1-bind'); el.style='color:'+binding.value; &#125;, inserted:function()&#123; console.log('2-inserted'); &#125;, update:function()&#123; console.log('3-update'); &#125;, componentUpdated:function()&#123; console.log('4-componentUpdated'); &#125;, unbind:function()&#123; console.log('5-unbind'); &#125; &#125; ); var app = new Vue(&#123; el:'#app', data: &#123; num: 1, color:'red' &#125;, methods:&#123; add:function()&#123; this.num++; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[其他指令]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-pre v-cloak v-once 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-pre 原样输出，不渲染--&gt; &lt;p v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;!-- v-cloak 页面加载完才显示，一般速度很快看不出来变化 --&gt; &lt;p v-cloak&gt;页面加载完显示&lt;/p&gt; &lt;!-- v-once 只渲染一次 --&gt; &lt;p v-once&gt;&#123;&#123;mes&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="mes" /&gt; &lt;p&gt;&#123;&#123;mes&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data: &#123; message:'hello', mes:'hello'//这个值决定了初始的值是什么 &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vbind]]></title>
    <url>%2F2019%2F05%2F16%2Fvbind%2F</url>
    <content type="text"><![CDATA[v-bind用于绑定属性，样式，很重要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 绑定标签属性 --&gt; &lt;a :href="url" target="_blank"&gt;链接&lt;/a&gt; &lt;br /&gt; &lt;!-- 直接绑定class样式 --&gt; &lt;p :class="className"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定class样式并判断 --&gt; &lt;p :class="&#123;classA:isOk&#125;"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定class数组 --&gt; &lt;p :class="[class1,class2]"&gt;a good girl&lt;/p&gt; &lt;!-- 用三元运算符绑定class样式 --&gt; &lt;p :class="isOk?class1:class2"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定style,注意fontSize的写法，vue中不支持-这种写法，不能写成font-size --&gt; &lt;p :style="&#123;color:col,fontSize:size&#125;"&gt;a good girl&lt;/p&gt; &lt;!-- 用对象绑定style --&gt; &lt;p :style="styleObject"&gt;a good girl&lt;/p&gt; &lt;/div&gt; &lt;style&gt; .classA&#123; color:red; &#125; .classB&#123; font-size:20px; &#125; &lt;/style&gt; &lt;script&gt; new Vue(&#123; el:'#app', data: &#123; url: 'http://baidu.com', className: 'classA', isOk: false, class1:'classA', class2:'classB',//注意这里必须再声明一下否则没有反应 col:'red', size: 18+'px', styleObject:&#123; color:'green', fontSize:'30px'//注意fontSize &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vmodel]]></title>
    <url>%2F2019%2F05%2F16%2Fvmodel%2F</url>
    <content type="text"><![CDATA[v-model是实现双向绑定的方法，是vue的核心1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 简单的双向数据绑定 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="message" /&gt; &lt;!-- 延迟响应 ，鼠标离开或enter才响应--&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message1&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.lazy="message1" /&gt; &lt;!-- 只响应数字,若现输入字母则无效 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message2&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.number="message2" /&gt; &lt;!-- 自动去掉前后空格 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message3&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.trim="message3" /&gt; &lt;br /&gt; &lt;!-- 多选按钮绑定一个值 --&gt; &lt;input type="checkbox" id="isTrue" v-model="isTrue" /&gt; &lt;label for="isTrue"&gt;&#123;&#123;isTrue&#125;&#125;&lt;/label&gt; &lt;br /&gt; &lt;!-- 多选按钮绑定数组 --&gt; &lt;input type="checkbox" id="linguoqiang" value="linguoqiang" v-model="name" /&gt; &lt;label for="linguoqiang"&gt;linguoqiang&lt;/label&gt; &lt;input type="checkbox" id="liuxue" value="liuxue" v-model="name" /&gt; &lt;label for="liuxue"&gt;liuxue&lt;/label&gt; &lt;input type="checkbox" id="chenqianqian" value="chenqianqian" v-model="name" /&gt; &lt;label for="chenqianqian"&gt;chenqianqian&lt;/label&gt; &lt;input type="checkbox" id="guomengyu" value="guomengyu" v-model="name" /&gt; &lt;label for="guomengyu"&gt;guomengyu&lt;/label&gt; &lt;p&gt;您选中的是&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;!-- 单项按钮绑定 --&gt; &lt;input type="radio" value="男" id="man" v-model="sex" /&gt; &lt;label for="man"&gt;男&lt;/label&gt; &lt;input type="radio" value="女" id="woman" v-model="sex" /&gt; &lt;label for="woman"&gt;女&lt;/label&gt; &lt;p&gt;&#123;&#123;sex&#125;&#125;&lt;/p&gt; &lt;!-- 绑定文本域 --&gt; &lt;textarea v-model="text"&gt;&lt;/textarea&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; message: '', message1: '', message2: '', message3: '', isTrue: true, name: [], sex: '男', text: '' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[von]]></title>
    <url>%2F2019%2F05%2F16%2Fvon%2F</url>
    <content type="text"><![CDATA[v-on是事件绑定，他的缩写是@123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;您的的得分是：&#123;&#123;score&#125;&#125;&lt;/p&gt; &lt;!-- 更多事件去看js中的事件 --&gt; &lt;input type="button" @click="add" value="add" /&gt; &lt;input type="button" @click="reduce" value="reduce" /&gt; &lt;input type="text" v-on:keyup.enter="onEnter" v-model="number" /&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data:&#123; score: 0, number:'' &#125;, methods:&#123; //注意下面所有的this的使用，且不能写return,记成事件(v-on)和方法(methods)绑定 add:function()&#123; this.score++; &#125;, reduce:function()&#123; this.score--; &#125;, onEnter:function()&#123; this.score=this.score+parseInt(this.number) //注意转换否则变成字符串连接 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多keycode]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vhtml]]></title>
    <url>%2F2019%2F05%2F16%2Fvhtml%2F</url>
    <content type="text"><![CDATA[注意这种方法在你无法保证绝对安全时不要使用，否则会造成SSR攻击 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;span v-html="h2"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; h2:'&lt;h2&gt;hello world&lt;/h2&gt;' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[vtext]]></title>
    <url>%2F2019%2F05%2F16%2Fvtext%2F</url>
    <content type="text"><![CDATA[这种写法的作用和花括号法一样，但在网速慢加载不出来时不会输出花括号降低用户体验1234567891011&lt;div id="app"&gt; &lt;span v-text="h2"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; h2:'hello world' &#125; &#125;)&lt;/script&gt; 结果：hello world]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vfor]]></title>
    <url>%2F2019%2F05%2F16%2Fvfor%2F</url>
    <content type="text"><![CDATA[一个简单排序,注意这里面sort方法容易掉的坑，不仅是vue所有的js都有这个bug，因此这种解决方式很常用 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in sortItems"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; //注意这里的sortItems别写成items了！ &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:"#app", data:&#123; items:[1,4,3,78,45] &#125;, computed:&#123; sortItems://注意在vue中为了保护data这里必须重新命名不能用items function()&#123; return this.items.sort(sortNum) //若不再定义一个sortNum,将出现收字符排序完了再排下一个，如1,23,4,5,67 &#125; &#125; &#125;); //注意这个函数写的位置，应写在vue后 function sortNum(a,b)&#123; return a-b; &#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果： 对象数组排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(student,index) in sortStudents"&gt;&#123;&#123;index+1&#125;&#125;:&#123;&#123;student.name&#125;&#125;-&#123;&#123;student.age&#125;&#125;&lt;/li&gt; &lt;!-- 注意这里的索引的用法 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:"#app", data:&#123; students: [ &#123;name:'linguoqiang',age:21&#125;, &#123;name:'liuxue',age:21&#125;, &#123;name:'chenhong',age:20&#125;, &#123;name:'chenqianqian',age:19&#125;, &#123;name:'guomengyu',age:18&#125;, ] &#125;, computed:&#123; sortStudents: //千万注意不要画蛇添足在这里加花括号，否则会出错 function()&#123; return sortByKey(this.students,'age') &#125; &#125; &#125;); //对象数组排序方法，在网上搜直接拿过来用就好 function sortByKey(array,key)&#123; return array.sort(function(a,b)&#123; var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); &#125;);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针：指针是储存地址的变量，他也有自己的地址，他通过自己储存的地址指向内存单元 指针的声明：数据类型 *指针变量名；1int *p; 注意：因为当不赋初值时，系统将随意给他个地址，很容易出错，所以一般用NULL给他赋个初值 取地址： &amp;变量名（&amp;为地址运算符） 使用指针储存地址： 数据类型 *指针变量名 = 取地址12int a = 3;int *p = &amp;a; 特别注意的是指针的数据类型应和所指向的变量的数据类型相同 一种数据类型的指针变量可指向任意一个跟他同数据类型的变量1234int a = 10;int *p = &amp;a;int b =2;p = &amp;b; 使用*访问指向的数据 12int * a = 1;cout&lt;&lt;*a;//1 指向不同变量类型的指针长度相同，具体长度取决于编译器，32位编译器就是4个字节，64位编译器就是16个字节 123double a = 3.45;double b = &amp;a;cout&lt;&lt;sizeof(b);//4或8 动态内存分配：解决未知长度内存空间的问题，虽然也定义了长度但在delete时会将不用的销毁，若不用delete就会造成内存泄漏(即内存被占用却没发挥作用，而其他元素可使用元素减少，造成程序运行效率降低) 1234int a = new int;//要指明类型，这是给一个元素分配内存delete a;//对应的deleteint b = new int[10];//这是给多个元素分配内存的形式delete []b;//对应的delete 举一个为字符串分配内存的例子1234string name;cin&gt;&gt;name;//注意要调用string库调用cstring库报错char *n = new char[name.length()+1];//注意不是strlen(),这个用于char,至于+1则是考虑到c++中对最后一个终止字符的风格delete []n;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2019%2F05%2F09%2FBOM%2F</url>
    <content type="text"><![CDATA[BOM:浏览器对象模型，是实现与浏览器交流的window window.document（可省略window）(document就是表示这个文档，我理解成跟this差不多) window.innerHeight（浏览器内部高度，除去菜单栏，工具栏啥的）window.innerWidth（浏览器内部宽度）(Internet Explorer、Chrome、Firefox、Opera 以及 Safari支持) document.body.clientHeight/document.body.clientWidth(Internet Explorer 8、7、6、5支持) window.outerHeight（浏览器完整高度)window.outerWidth(浏览器完整宽度) 一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 screenscreen.availHeight/screen.availWidth屏幕可用高宽4.更多：用的时候查文档，一定要注意浏览器兼容问题，不是所有浏览器都支持 historyhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 navigatornavigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 注意：来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：navigator 数据可被浏览器使用者更改,浏览器无法报告晚于浏览器发布的新操作系统 js消息框 警告框：alert(“文本”) 确认框：confirm(“文本”) 提示框：prompt(“文本”)//提示用户输入js计时事件 setTimeOut(js代码，毫秒)[用于使事件在一定事件后再执行] 1234567&lt;button type=&quot;button&quot; onclick=&quot;func()&quot;&gt;点击&lt;/button&gt; &lt;script&gt; function func()&#123; setTimeout(&apos;alert(&quot;jhk&quot;)&apos;,5000); &#125; &lt;/script&gt; clearTimeOut(对应的setTimeOut)和无穷循环计数的使用 123456789101112131415161718&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;Start count!&quot; onClick=&quot;timeCount()&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Stop count!&quot; onClick=&quot;stopCount()&quot;&gt; &lt;/form&gt; &lt;script&gt; var c = 0; var t;//注意这个一定要全局声明，否则在第二个函数体内无法引用 function timeCount()&#123; document.getElementById(&quot;txt&quot;).value = c;//给它赋初值，把value和文本框绑起来 c+=1; t = setTimeout(&quot;timeCount()&quot;,1000); &#125; function stopCount()&#123; clearTimeout(t);//注意t的对应关系 &#125; &lt;/script&gt; cookie cookie是用来存放信息，有保质期，常用于自动登录，记住用户名，注意中要的数据不能存放在cookie中，因为用户可以自己修改 cookie的特性： 注意若不搭建服务器，只有火狐支持本地的cookie测试 同一网站中所有页面共享一套cookie 数量，大小有限 有限时间，即若不设置过期时间就在当次浏览器关闭时销毁cookie cookie的使用 ①设置cookie: 格式：名字=值123document.cookie = &quot;user=blue&quot;;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); //当把前两行注释后再打开浏览器仍然保留着他俩的值，但因为没有设期限（experis）在把浏览器关掉后再打开就没有这两个cookie了 不会被第二个甚至更多个cookie值覆盖 结果： ②给cookie设置时间期限12345var dat = new Date();dat.setDate(dat.getDate()+30);//加三十天document.cookie = &quot;user=blue; expires=&quot;+dat;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); 结果： ③上面的方法不常用，尝试封装成函数的方法新增cookie1234567function setCookie(name,value,i)&#123; var dat = new Date(); dat.setDate(dat.getDate()+i); document.cookie = name+&apos;=&apos;+value+(expires==null?&apos;&apos;:&apos;;expires=&apos;+dat);//判断截止时间是否为空 &#125; setCookie(&quot;Username&quot;,&quot;dfg&quot;,20); alert(document.cookie); 结果： ④提取cookie12345678910111213function getCookie(name)&#123; var arr1 = document.cookie.split(&quot;;&quot;); for(var i = 0;i&lt;arr1.length;i++)&#123; var arr2 = arr1[i].split(&quot;=&quot;);//将cookie拆分开，因为cookie实质上就是字符串 if(arr2[0]==name)&#123;//注意== return arr2[1]; &#125; return &quot;&quot;; &#125; &#125; setCookie(&quot;password&quot;,&quot;asd&quot;,20); alert(getCookie(&quot;password&quot;));//注意写引号 结果： ⑤删除cookie123function removeCookie(name)&#123; setCookie(name,1,-1);//写成-1浏览器以为是昨天的就自动删了 &#125;]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML_DOM]]></title>
    <url>%2F2019%2F05%2F08%2FHTML-DOM%2F</url>
    <content type="text"><![CDATA[什么是DOM：DOM是文档对象模型，他分xhtml,html,核心dom三种，所以html dom就是可以对html文本中任何元素进行修改删除等操作 DOM节点 在html中任何元素都是节点，比如说整个文档是文档节点，每个html元素是元素节点，每个元素的文本是文本节点，属性是属性节点，注释是注释节点 各节点间有父(parent)，子(child)，同胞关系(sibling);根元素没有父元素，其他元素都有父元素 DOM属性· 这里只说innerhtml,这个属性是获取元素的文本内容12//.innerHTML是获取指定的元素文本内容//.innerhTML = &quot;&quot;是修改制定元素的文本 DOM方法 document对象，他是html文档的根节点，在满足两个条件下他会覆盖原来的 HTML文档，一个是在函数中用document.write,一个是按钮响应这个函数;在下面的我们直接用document.即可1234567&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;button onclick = func()&gt;点击覆盖&lt;/button&gt; &lt;script&gt; function func()&#123; document.write(23333); &#125; &lt;/script&gt; 点击前： 点击后： 访问节点①.getElementById(“”) ②.getElementByTargeName(“”)//标签，如p ③.getElementByClassName(“”)//不推荐使用，因为IE5,6,7,8不支持 改变HTML内容1234&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).innerHTML = &quot;hello world!&quot;; &lt;/script&gt; 结果：hello world! 改变CSS样式（通过.style.属性名访问CSS样式）12345&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &lt;/script&gt; 结果： 创建新元素 步骤一：创建新元素步骤二：若元素内需要有内容，需创建文本节点步骤三：将文本节点追加给新元素步骤四：将这个新元素追加给已有元素即父元素（必须有父元素）1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;sdsjkd&quot;); para.appendChild(tex); document.getElementById(&quot;div1&quot;).appendChild(para); &lt;/script&gt; 结果：123hellosdsjkd 1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var a = document.createElement(&quot;a&quot;); a.href=&quot;http://baidu.com&quot;; a.innerHTML=&quot;百度&quot;; document.getElementById(&quot;div1&quot;).appendChild(a); &lt;/script&gt; 结果： 删除已有元素1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var child=document.getElementById(&quot;p1&quot;);//获取子元素 child.parentNode.removeChild(child);//通过parentNode找到父元素 &lt;/script&gt; 结果: he 替换元素12345678910111213&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;snkslm&quot;); para.appendChild(tex); var parent = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p2&quot;); parent.replaceChild(para,child); &lt;/script&gt; 结果：123hellosnkslm 触发事件举个例子,也推荐这种形式，尽量不要写成内联1234567&lt;p id=&quot;p1&quot;&gt;点击我变颜色&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).onclick = func;//注意不能写func() function func()&#123; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &#125; &lt;/script&gt; 特别注意在触发事件时调用的函数不能写括号，因为写括号就直接在页面加载完成就立刻执行，不加括号才是在触发事件时响应]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在js中函数也是对象，因此可以把它赋给一个变量，一个数组元素，甚至作为参数传给另一个函数调用函数的定义 声明式的静态方式(所有浏览器都支持） function 函数名(形参列表){函数体}//注意没有var否则报错,且function必须小写 ①这种方式最常用，他只需定义一次，在程序的完整过程中，他一直被存在内存中，只在页面打开时解析一次，不论是什么调用它，返回的都是函数体处理完的结果 ②要设定返回值，他可以有0个到多个return,一般多个return 都用在需要判断条件时，即满足这个条件就不往下执行函数体内容 ③参数方面注意传参形式，一种是传值，一种是传地址，简单点说就是传值不改变实参，传地址改变实参12345678910function change(str1,arr) &#123; str1 = "hello javascript!"; arr[arr.length] = "three";&#125;var str = "hello world!";var arr1 = ["one","two"];change(str,arr1);document.write(arr1);//传地址，改变document.write("&lt;br /&gt;");document.write(str);//传值，不变 结果：12one,two,threehello world! 匿名函数(没有函数名，又叫动态函数，较新的浏览器支持)var hd = new Function(&quot;参数1&quot;，&quot;参数2&quot;，&quot;函数结构体&quot;)//F必须大写，必须是new 匿名函数是用一次定义一次，直接赋给变量 这种方式不常用，但是在只有运行时才能确定函数成立条件时，创建动态函数就很有必要123456789var func = prompt("请输入函数体");var x = parseInt(prompt("请输入x"));var y = parseInt(prompt("请输入y"));//注意promt返回的是字符串若不转换结果就是23var op = new Function("x","y",func);var result = op(x,y);document.write("function is "+func+"&lt;br /&gt;");document.write("x is"+x+"&lt;br /&gt;");document.write("y is"+y+"&lt;br /&gt;");document.write("result is"+result); 结果：1234function is return x+yx is2y is3result is5 函数直接量（即赋给变量或作为另一函数的参数，新的浏览器支持7）①var func = (参数列表){函数体}//兼具了匿名函数和声明函数 ②var func = 函数名(参数列表){函数体} ③1234function fan(x,y,z)&#123; document.write((z(x,y)));&#125;fan(1,2,function(x,y)&#123;return x+y&#125;);//函数作为参数 结果：3 回调函数回调函数可以理解成，将回调函数作为参数放在一个新函数里，然后执行过程就是先执行新函数再反过来执行回调函数123456789//定义回调函数function fun1(value)&#123; document.write(value);&#125;//定义新函数并把回调函数作为参数function fun2(fun,value)&#123; fun(value);&#125;fun2(fun1,"hi js!") 结果：hi js! 函数对象123456789function func()&#123; //arguments.length返回参数个数 for(var i=0;i&lt;arguments.length;i++)&#123; document.write(arguments[i]); //arguments[i]输出对应参数，arguments和length是作为对象的函数的属性 &#125;&#125;func(1,2,3); 结果：123]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day3]]></title>
    <url>%2F2019%2F05%2F06%2Fday3%2F</url>
    <content type="text"><![CDATA[1.为什么程序底层要用二进制数：因为cpu和内存其实是IC的一种,而IC它两端有引角，引角只能输入5或0伏电压，这与二进制只有0和1对应，因此，每个引脚对应二进制的一位 计算机处理信息的基本单位一般是8位，因此二进制的位数一般都是8的倍数，而8位就是1个字节所以，计算机处理信息的基本单位是字节 位权：oo的xx次方，二进制oo就是2，十进制oo就是10，以此类推]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象]]></title>
    <url>%2F2019%2F05%2F06%2Fjs%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[四种对象 javascript内置对象 浏览器对象模型中的对象(BOM) 文档对象模型中的对象 用户自定义的对象 下面总结的都是第一种，javascript的内置对象js对象中都有自己的属性和方法，也可以通过new来新建一个对象，有的对象要注意对象和函数的区分，比如Number对象和Number()和Number对象的实例化 Boolean对象 必须注意创建Boolean对象实例的方法必须是与new结合的构造函数 1var boo = new Boolean(true); 在Boolean对象被实例化后，可通过Object的方法toValue来访问它所封装的基本值if(boo.toValue())···; 也可直接访问if(boo) Number对象 要注意在js中他对数值得辨识度并不高，它不论是整数还是指数还是浮点数，一律处理成64位的浮点型，也就是说在js中只有浮点型 Number对象的实例化，可以用new也可以直接用Number(),但是用Number的话是number型，不是对象 Number对象的属性，注意是对象不是对象的实例化 ①MAX_VALUE 指js可接受的最大值 ②MIN_VALUE 指js可接受的最小值 ③NEGATIVE_INFINITY 指js中定义的负无穷值 ④POSITIVE_INFINITY 指js中定义的正无穷值12345678document.write(Number.MAX_VALUE);document.write(Number.MIN_VALUE);document.write(Number.NEGATIVE_INFINITY);document.write(Number.POSITIVE_INFINITY);/*若写成以下形式会报错,因为只能是Number对象的var num = new Number(4)document.write(num.MAX_VALUE); */ 结果：1.7976931348623157e+3085e-324-InfinityInfinity Number对象的方法 ①toString() 有一个形参，是一个2到36的整数，默认为10，是将对象的实例化按进制输出123var num = new Number(&quot;100&quot;);document.write(num.toString(2));//若是用Number()实例化的，也不慌，会将他转换成对象在用这个函数，在转回变量 ②toLocalString() 无形参，作用是转化为本地格式的字符串12var num = new Number(1876653);document.write(num.toLocaleString()); 结果：1,876,653 ③toFixed() 有一个形参代表要有的小数位数，范围是0到20，包括0,20，不写默认为0,注意这个会四舍五入，要是不够会用零补上12var num = new Number(187.6653);document.write(num.toFixed()); 结果：18812var num = new Number(23.56);document.write(num.toFixed(10)); 结果：23.5600000000 ④toPrecision() 有一个参数,代表有效数位，会四舍五入，参数取值范围是1到21包括1,21；若不写参数，就会调用toString()12var num = new Number(23.56);document.write(num.toPrecision(3)); 结果：23.612var num = new Number(23.56);document.write(num.toPrecision()); 结果：23.56 ⑤toExponential() 将数值表示成指数型，有一个形参，代表保留小数位,若省略参数将显示尽可能多的小数位12var num = new Number(23.56356789);document.write(num.toExponential(3)); 结果：2.356e+1 String对象 String对象属性：length,代表字符串字符数，注意这里不像c++要在最后再加一 String对象有些格式化html方法，如anchor()[设置html锚点]；link()[生成链接]；big()[放大字体]；blink()[生成闪动字体]；bold()[加粗字体]；italics()[设置斜体]；sub()[设置下角标]；sup()[设置上角标]；small()[缩小字体]；strike()[加一条删除线]; 值得注意的是，这种html格式化方法并不是所有浏览器都兼容，比如blink()他在ie就不兼容，所以我们要尽可能的避免使用这种html格式化方法，但是anchor()和link()除外，这两个还是可以用用的 1234var str = &quot;Hello world!&quot;str.anchor(&quot;myAnchor&quot;);//参数为锚点名alert(str.anchor(&quot;myAnchor&quot;)); 结果：12var str=&quot;baidu&quot;;document.write(str.link(&quot;http://www.baidu.com&quot;)); 结果： charAt()返回索引处字符，参数则为索引12var str=&quot;baidu&quot;;document.write(str.charAt(2)); 结果：i charCodeAt()返回指定位置的字符的unicode编码12var str=&quot;baidu&quot;;document.write(str.charCodeAt(3)); 结果：100 js中有三种截取字符串片段的方法，我首推slice(start,end)，其次subString(start,stop),不能推荐subStr，因为es6没有规范他，就不用他,而slice()和subString()唯一不同就是前者接受负数后者不接受 123var str=&quot;Hello happy world!&quot;document.write(str.slice(4,7))// 只包括不包括结尾即其实是截取了str[4]到str[6],若无第二个参数表示后面的都要，若这两个参数为负则用负数加长度 indexOf()和lastIndexOf() 返回子串最开始出现的索引和最后一次出现的索引，注意该函数对大小写十分敏感，若不存在返回-1 1234var str = &quot;Hello world&quot;;document.write(str.indexOf(&apos;w&apos;));document.write(str.indexOf(&apos;W&apos;));document.write(str.lastIndexOf(&apos;l&apos;)); 结果：6-19 split() 有两个参数，第一个参数是分割标志(写成字符串)，第二个参数可选，限定个数，这个其实就是拆分字符串,整成一个数组；需要说的是，splirt()也可直接用在变量后 document.&quot;sdh\nfbdkv\ffd&quot;.split(&quot;\&quot;,1) 结果:sdh12var str = &quot;Hello world&quot;;document.write(str.split(&quot; &quot;,1)); 结果：Hello toUpperCase()和toLowerCase()将字符串都变成大写和小写1234var str = &quot;hjfkdflk&quot;;document.write(str.toUpperCase());var str1 = &quot;DKFENDFLOR&quot;;document.write(str1.toLowerCase()); 结果：HJFKDFLKdkfendflor formCharCode()这是一个静态方法所谓静态方法就是只能是对象调用不能对象的实例化调用，这个方法是将unicode编码实例化成一个字符串 1document.write(String.fromCharCode(72,69,76,76,79)); 结果:HELLO Date对象实例化：var time = new Date(); Date对象方法 当所用的是例如网上商店下订单这种孤立的行为，使用用户本地的就行，若是像评论博客这种国际化的全体的行为，就设UTC Date()直接返回用户电脑的时间1document.write(Date()); 结果：Mon May 06 2019 15:49:35 GMT+0800 (中国标准时间) Math对象 Math对象的属性 Math对象的方法，注意这些都是静态方法，不需实例化javascript数组 在js中数组也是对象 数组对象的属性，length 数组对象的实例化方式可new可不new,定义数组后就可以用索引了，比如a[i] ①var arr = [&quot;apple&quot;,&quot;banana&quot;] ; ②var arr = new Array(3,4,5,6,2) ③12345var arr = new Array(3);arr[0]=(1,3);arr[1]=(3,5);arr[2]=(5,4);//二维及以上数组定义方法，再创数组对象 splice()[修改原来数组]实现对数组中元素的添加,删除，修改（每种前两个参数都是固定的，第一个是开始操作的索引，第二个是删除的数量），返回的是删除后组成的数组，即documentarr返回的是修改后的，documentarr.splice返回的删除的组成的数组1234//添加元素，注意不能写成document.write(arr.splice(0,0,&quot;people&quot;))因为返回的是删除的数组var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,0,&quot;people&quot;)document.write(arr); 结果：people,apple,banana,pear,pen1234//删除元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1)document.write(arr); 结果：banana,pear,pen1234//替换元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1,&quot;people&quot;)document.write(arr); 结果：people,banana,pear,pen slice()[不改变原来数组]，即documentarr返回的是原来的数组，documentarr.slice返回的是修改后的数组，作用是返回截取的元素，两个参数，第一个参数是其实的索引(包括)，第二个参数是结束的索引(不包括)12var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr.slice(0,3)); 结果：apple,banana,pear concat()[不改变原来数组]即documentarr返回的是原来的数组，documentarr.concat返回的是修改后的数组，作用是连接数组123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);var arr2 = new Array(&quot;story&quot;);var arr3 = new Array(&quot;fish&quot;)var arr4 = [3,4,5];document.write(arr1.concat(arr2));//连接两个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr1.concat(arr2,arr3));//连接三个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr4.concat(6,7));//连接参数 结果：123apple,banana,pear,pen,storyapple,banana,pear,pen,story,fish3,4,5,6,7 join() 将数组中对象用自己定义的分隔符输出12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.join(&apos;|&apos;)); 结果：apple|banana|pear|pen reverse() 颠倒数组顺序12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.reverse()); 结果：pen,pear,banana,apple push()和pop() 组合使用实现先进后出栈 push()实现在数组的最后面依次加元素,返回新长度；pop()实现删去数组最后一个元素，返回被删除的元素；123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.push(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.pop());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346apple,banana,pear,pen,people,girlgirlapple,banana,pear,pen,people unshift()[ie不支持]和shift() 前者可以有多个参数，作用是加在数组最前面，第一个参数为a[0]以此类推，返回的是新长度，后者是删除最前面的元素，返回被删除的元素即原数组的首元素123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.unshift(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.shift());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346people,girl,apple,banana,pear,penpeoplegirl,apple,banana,pear,pen 遍历数组 12345var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);for(var x in arr1)&#123; document.write(arr1[x]); document.write(&quot;&lt;br /&gt;&quot;);&#125; 结果：1234applebananapearpen 数组的深复制 先举个浅复制的例子 12345678var num1=[];for(var i=0;i&lt;10;i++)&#123; num1[i]=i+1;&#125;var num2=[];num2=num1;num1[0]=400;document.write(num2[0]); 输出结果是400 这种就是浅复制，是按引用传值，新数组还是指向旧数组，旧数组变他就变，要解决这个问题就要用到深复制这个概念 12345678910111213var num1=[];for(var i=0;i&lt;10;i++)&#123; num1[i]=i+1;&#125;function copy(arr1,arr2)&#123; for(var i=0;i&lt;arr1.length;i++)&#123; arr2[i]=arr1[i]; &#125;&#125;var num2=[];copy(num1,num2);num1[0]=400;document.write(num2[0]); 输出结果是1 因此深复制就是讲新数组与旧数组一个个复制得到 更推荐使用[]操作符来创建数组，而不是new Array() 在js中，是数组长度可伸长，可超过定义好的长度 数组排序： 若数组元素是字符串，直接用sort()方法 若数组元素是数字需要另外加一个compare函数 123456var num=[1,233,21,34,32];function compare(num1,num2)&#123; return num1-num2;&#125;num.sort(compare);document.write(num); 不返回新数组的迭代器方法 迭代器方法就是让数组里每一个元素应用一个函数 forEach() 接受一个函数作为参数，让数组每个元素执行一遍函数 every() 接受一个返回值为布尔值的函数作为参数，如果数组中每一个元素执行完函数返回的都是true则这个返回true some() 同样是接受一个返回值为布尔值的函数作为参数，但这个是只要数组中有元素返回的是true,这个就是true reduce() 接受一个函数为参数，返回一个数，这个一般用与数组累加求和，或者将数组中元素拼接为字符串。执行顺序为一个个累加值，直到最后一个值 reduceRight() 和reduce()类似，只不过这个是从右向左拼接字符串 返回数组的迭代器方法 map() 与forEach()类似，只不过这个返回每个元素执行完函数返回的值组成的数组 filter() 与every()类似，但这个返回的是执行完函数返回true的元素组成的数组]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day2]]></title>
    <url>%2F2019%2F05%2F05%2Fday2%2F</url>
    <content type="text"><![CDATA[程序运行时，程序计数器指向一个地址值，然后顺序结构的话，每进行一条指令，程序计数器上的值加一 其实cpu处理程序很有意思，像是比较累加寄存器和通用寄存器中的值，他实际上会进行减法运算，通过正负零来判断谁大谁小 运算结果存放在标志寄存器，无论结果是什么都会存放进去，同时标志寄存器还负责存放溢出和奇偶判断 分支结构是用的跳转指令，即运行时程序计数器不是单纯的一条指令加一 函数调用，实际上是先把调用处以下的指令先存放在栈，然后进行call到函数体进行，处理完函数体后，再return回到调用处的下一指令指向的地址，把栈上存放的指令读入到程序计数器上，再接着往下 说到划分内存，实际上要用到基址寄存器和变址寄存器，我们所说的实际地址值就是基址寄存器的值加上变址寄存器的值，而变址寄存器实际上就是我们所熟悉的数组的索引 正，0，负实际上存在32位的标志寄存器上的前三位]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运算符和语句]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[js语句的格式 要养成每条语句后都写分号的习惯 在js代码中，空白没意义，为了让代码更直观更易于维护，可尝试养成在等号前后，加号等前后写空格的习惯赋值语句 由左边变量，赋值变量和右边被赋给的值组成 右边的表达式可以是直接量值var vm = 35;一个变量和直接量再加上运算符的组合var value = vm + 27;函数的调用var nvalue = escape();一行可以包含多个赋值语句var a = b = c = 23; 二元运算符 二元运算符有加(+)减(-)乘(*)除(/)取余(%)注意在js中除法保存的是浮点数而不是截取的整数 这里重点说一下加法运算符，在字符串那里要特别注意，当两个运算数中有字符串时会优先将+解析为连接运算符12var vm = "3.99" + 2.7;document.write(vm); 结果：3.992.7 而对于其他的二元运算符，只要两个操作数中的字符串内只有数字就可以计算12var vm = "3" * 2;document.write(vm); 结果：6 为了在用加号时规避这种错误，最好采用parseInt或者parseFloat函数显式地转化一下字符串12var vm = parseInt('3') + 3;document.write(vm); 结果：6 一元运算符 一元运算符有负值运算符，自增运算符，自减运算符12345var vm = 2;var value = -vm;document.write(value);var nvalue = ++value;document.write(nvalue); 结果：-2-1 注意自增自减都有前置后置之分，前置是先自己变值在赋值，后置是先赋值在自己变值逻辑运算符，三元运算符，各种语句需要注意的因为有了c++基础就不多说什么事if循环啊啥的，记一点容易犯错的 注意短值运算，就是与的话当第一个表达式返回0，就不往下看了，这个直接就是假；是或的话当第一个表达式返回1，直接就是真，考虑到cpu等内存占用，应该把重要的依据放在前面 注意===和==区别，前面的是等同，现在已经广泛应用，因为当时字符串和数值比较，会先隐式地把字符串转化为数值型，用等同则返回false,用等于则返回true switch语句，注意写break,default;当多种情况是同一入口时，最好用如下形式： 1234case a:case b:case c:document.write("hhhhh"); 注意if语句的条件里千万不能写等于号，最次也得写个== 当想至少进行一次循环时，选do···while而不用while 注意一下for循环中的for in型，在后面会用到比如遍历数组啥的，以后再说，先简单举个栗子1234object("a":b,"c":d)for(x in object)&#123; txt += object[x] ;&#125; 结果：cd]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day1]]></title>
    <url>%2F2019%2F05%2F04%2Fday1%2F</url>
    <content type="text"><![CDATA[CPU和内存是由很多的晶体管组成，他俩合称IC（集成电路） CPU由寄存器，运算器，控制器和时钟组成 程序运行过程：首先由程序员用高级语言写出程序，然后把程序编译成机器语言（即exe文件），然后将这个exe文件在内存上存一个副本，然后再在CPU上解析运行 将CPU的解析和运行过程放大来讲，是时钟先发出时钟信号，cpu开始工作啦，他先让寄存器去抓内存上的数据，然后运算器进行运算，然后控制器通过运算结果来控制整个计算机，其实也就是控制输入输出什么的 实际上，对于程序员来说可以把CPU简单的理解为是很多很多寄存器的集合体，寄存器有很多种，不仅是他们存储的类型上，比如有的是存数值这种数据的，有的他是存地址这样的数据 汇编语言是由助记符组成的（比如将addition写成add），他和机器语言实际上是一一对应的，每一个机器语言实际上都有对应的汇编语言。因而，我们把将汇编语言转换成机器语言成为汇编过程，把机器语言转换为汇编语言称为反汇编过程 其实，编译器汇编器这种的并不是我们所想的一种组件什么的，他其实就是一个程序 我们可以简单地把程序运行的过程就当成是各种寄存器之间的处理，因此我们只要知道CPU是寄存器的集合体就好 内存，我们叫主储存器，现在一般都是DRAM（动态随机存储器），就是储存数据啊啥的，1个字节是8位，每个都有地址]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型与变量]]></title>
    <url>%2F2019%2F05%2F04%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[标识符 标识符只能由数字，字母，$符和下划线表示 首字符必须是字母或$符或下划线，切记不能是数字 在所使用的的作用域内，每个变量的标识符是唯一的 可在变量标识符中使用Unicode的字母和数字，官网链接 可使用转义序列 区分大小写 不得使用js关键字，ECMA 262规范的保留字，浏览器中典型的保留字，具体如下图 js关键字 ECMA 262规范的保留字 浏览器中典型的保留字 尽量使用有意义的，提高可维护性 一些小规范：①项目的集合名称应用复数②对象名首字母大写③函数和变量以小写字母开始并使用驼峰法,也可每个单词间用下划线作用域 局部变量：在一个函数内定义，初始化，函数结束时变量不存在 全局变量：在所有地方都可访问，包括引入的js库 要养成写var的习惯，因为当你想要定义一个局部变量但没有写var就会被当做全局变量，也就是说全局变量可不写var但最好也要写字符串型 单引号和双引号作用一样，不做区别；但是当需要嵌套时不能同型套同型，只能是单引号套双引号或双引号套单引号 字符串中可包括转义序列，例如 \n \\ \&#39; \&quot; 可使用escape函数和unescape函数进行编码和解码，但需要注意的是这两个函数不能处理非ASCII码字符，这是可使用encodeURI和decodeURI函数，下面是使用escape函数和unescape函数的示例12document.write(escape("sbadkf65488$%^"));document.write(unescape("sbadkf65488%24%25%5E")); 结果：sbadkf65488%24%25%5Esbadkf65488$%^ 空字符串是一种特殊情形，一般用来初始化 字符串连接:12var year=2019;document.write("今年是"+year+"年"); 结果：今年是2019年 toString函数，将其他类型转换为字符串类型123document.write(boo.toString());//显示数据类型document.write(typeof boo.toString()); 布尔型 只有true和false两种，不能用引号包起来 Boolean函数,将其他类型转化为布尔型。需要注意的是没有toBoolean函数了，是Boolean函数！！！！还有强调一下有管字符串转成布尔型，当是空字符串时返回false，当是一个及以上空格时返回true,具体实践如下1234var s=Boolean("");document.write(s);var r=Boolean(" ");document.write(r); 结果：falsetrue 数值型 js中数字是浮点型，需要注意的是，js的计算能力不是很强，所以在数字方面一般不是很精确 可取数范围是-2e31到2e31;js中规定正无穷用Infinity表示，负无穷用-Infinity表示；当某函数出现溢出时则会返回一个Infinity（正无穷） parseFloat()和parseInt(),这两个函数都可用于在字符串中提取出数字，但需要注意的是只能提取出第一个字符就是数字的字符串否则报错，其次，parseInt()只取整数部分，注意事项截取而不是四舍五入;这两个函数还可将八进制或十六进制数转化为十进制，只需在后面加一个参数默认为10，具体例子如下1234var str1=parseInt("0x5F",16);document.write(str1);var str2=parseFloat("171.8cm");document.write(str2); 结果：95171.8 isFinite函数，用来判断无穷大，当值是无穷大或NaN时返回false,否则返回true Number函数，将其他数据类型转换为数值型,注意字符串类型，只有在字符串内全部是数字时才有用，否则返回NaN12var str2=Number("171.8cm");document.write(str2); 结果：NaN 常量const 变量名 = 值； 只定义一次 null与undefinedjavaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺 javaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 null值则是表示空对象指针 其实，null就给他理解成一个空对象，暂时赋给一个变量，而undefined就是当访问为初始化的变量时返回undefined]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[myBlog]]></title>
    <url>%2F2019%2F05%2F04%2FmyBlog%2F</url>
    <content type="text"><![CDATA[嘻嘻嘻。 吼吼吼。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
