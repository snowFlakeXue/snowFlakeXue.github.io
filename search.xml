<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[v-for]]></title>
    <url>%2F2019%2F05%2F16%2Fv-for%2F</url>
    <content type="text"><![CDATA[一个简单排序,注意这里面sort方法容易掉的坑，不仅是vue所有的js都有这个bug，因此这种解决方式很常用 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in sortItems&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; //注意这里的sortItems别写成items了！ &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; items:[1,4,3,78,45] &#125;, computed:&#123; sortItems://注意在vue中为了保护data这里必须重新命名不能用items function()&#123; return this.items.sort(sortNum) //若不再定义一个sortNum,将出现收字符排序完了再排下一个，如1,23,4,5,67 &#125; &#125; &#125;); //注意这个函数写的位置，应写在vue后 function sortNum(a,b)&#123; return a-b; &#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果： 对象数组排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(student,index) in sortStudents&quot;&gt;&#123;&#123;index+1&#125;&#125;:&#123;&#123;student.name&#125;&#125;-&#123;&#123;student.age&#125;&#125;&lt;/li&gt; &lt;!-- 注意这里的索引的用法 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&quot;#app&quot;, data:&#123; students: [ &#123;name:&apos;linguoqiang&apos;,age:21&#125;, &#123;name:&apos;liuxue&apos;,age:21&#125;, &#123;name:&apos;chenhong&apos;,age:20&#125;, &#123;name:&apos;chenqianqian&apos;,age:19&#125;, &#123;name:&apos;guomengyu&apos;,age:18&#125;, ] &#125;, computed:&#123; sortStudents: //千万注意不要画蛇添足在这里加花括号，否则会出错 function()&#123; return sortByKey(this.students,&apos;age&apos;) &#125; &#125; &#125;); //对象数组排序方法，在网上搜直接拿过来用就好 function sortByKey(array,key)&#123; return array.sort(function(a,b)&#123; var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); &#125;);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针：指针是储存地址的变量，他也有自己的地址，他通过自己储存的地址指向内存单元 指针的声明：数据类型 *指针变量名；1int *p; 注意：因为当不赋初值时，系统将随意给他个地址，很容易出错，所以一般用NULL给他赋个初值 取地址： &amp;变量名（&amp;为地址运算符） 使用指针储存地址： 数据类型 *指针变量名 = 取地址12int a = 3;int *p = &amp;a; 特别注意的是指针的数据类型应和所指向的变量的数据类型相同 一种数据类型的指针变量可指向任意一个跟他同数据类型的变量1234int a = 10;int *p = &amp;a;int b =2;p = &amp;b; 使用*访问指向的数据 12int * a = 1;cout&lt;&lt;*a;//1 指向不同变量类型的指针长度相同，具体长度取决于编译器，32位编译器就是4个字节，64位编译器就是16个字节 123double a = 3.45;double b = &amp;a;cout&lt;&lt;sizeof(b);//4或8 动态内存分配：解决未知长度内存空间的问题，虽然也定义了长度但在delete时会将不用的销毁，若不用delete就会造成内存泄漏(即内存被占用却没发挥作用，而其他元素可使用元素减少，造成程序运行效率降低) 1234int a = new int;//要指明类型，这是给一个元素分配内存delete a;//对应的deleteint b = new int[10];//这是给多个元素分配内存的形式delete []b;//对应的delete 举一个为字符串分配内存的例子1234string name;cin&gt;&gt;name;//注意要调用string库调用cstring库报错char *n = new char[name.length()+1];//注意不是strlen(),这个用于char,至于+1则是考虑到c++中对最后一个终止字符的风格delete []n;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2019%2F05%2F09%2FBOM%2F</url>
    <content type="text"><![CDATA[BOM:浏览器对象模型，是实现与浏览器交流的window window.document（可省略window）(document就是表示这个文档，我理解成跟this差不多) window.innerHeight（浏览器内部高度，除去菜单栏，工具栏啥的）window.innerWidth（浏览器内部宽度）(Internet Explorer、Chrome、Firefox、Opera 以及 Safari支持) document.body.clientHeight/document.body.clientWidth(Internet Explorer 8、7、6、5支持) window.outerHeight（浏览器完整高度)window.outerWidth(浏览器完整宽度) 一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 screenscreen.availHeight/screen.availWidth屏幕可用高宽4.更多：用的时候查文档，一定要注意浏览器兼容问题，不是所有浏览器都支持 historyhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 navigatornavigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 注意：来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：navigator 数据可被浏览器使用者更改,浏览器无法报告晚于浏览器发布的新操作系统 js消息框 警告框：alert(“文本”) 确认框：confirm(“文本”) 提示框：prompt(“文本”)//提示用户输入js计时事件 setTimeOut(js代码，毫秒)[用于使事件在一定事件后再执行] 1234567&lt;button type=&quot;button&quot; onclick=&quot;func()&quot;&gt;点击&lt;/button&gt; &lt;script&gt; function func()&#123; setTimeout(&apos;alert(&quot;jhk&quot;)&apos;,5000); &#125; &lt;/script&gt; clearTimeOut(对应的setTimeOut)和无穷循环计数的使用 123456789101112131415161718&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;Start count!&quot; onClick=&quot;timeCount()&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Stop count!&quot; onClick=&quot;stopCount()&quot;&gt; &lt;/form&gt; &lt;script&gt; var c = 0; var t;//注意这个一定要全局声明，否则在第二个函数体内无法引用 function timeCount()&#123; document.getElementById(&quot;txt&quot;).value = c;//给它赋初值，把value和文本框绑起来 c+=1; t = setTimeout(&quot;timeCount()&quot;,1000); &#125; function stopCount()&#123; clearTimeout(t);//注意t的对应关系 &#125; &lt;/script&gt; cookie cookie是用来存放信息，有保质期，常用于自动登录，记住用户名，注意中要的数据不能存放在cookie中，因为用户可以自己修改 cookie的特性： 注意若不搭建服务器，只有火狐支持本地的cookie测试 同一网站中所有页面共享一套cookie 数量，大小有限 有限时间，即若不设置过期时间就在当次浏览器关闭时销毁cookie cookie的使用 ①设置cookie: 格式：名字=值123document.cookie = &quot;user=blue&quot;;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); //当把前两行注释后再打开浏览器仍然保留着他俩的值，但因为没有设期限（experis）在把浏览器关掉后再打开就没有这两个cookie了 不会被第二个甚至更多个cookie值覆盖 结果： ②给cookie设置时间期限12345var dat = new Date();dat.setDate(dat.getDate()+30);//加三十天document.cookie = &quot;user=blue; expires=&quot;+dat;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); 结果： ③上面的方法不常用，尝试封装成函数的方法新增cookie1234567function setCookie(name,value,i)&#123; var dat = new Date(); dat.setDate(dat.getDate()+i); document.cookie = name+&apos;=&apos;+value+(expires==null?&apos;&apos;:&apos;;expires=&apos;+dat);//判断截止时间是否为空 &#125; setCookie(&quot;Username&quot;,&quot;dfg&quot;,20); alert(document.cookie); 结果： ④提取cookie12345678910111213function getCookie(name)&#123; var arr1 = document.cookie.split(&quot;;&quot;); for(var i = 0;i&lt;arr1.length;i++)&#123; var arr2 = arr1[i].split(&quot;=&quot;);//将cookie拆分开，因为cookie实质上就是字符串 if(arr2[0]==name)&#123;//注意== return arr2[1]; &#125; return &quot;&quot;; &#125; &#125; setCookie(&quot;password&quot;,&quot;asd&quot;,20); alert(getCookie(&quot;password&quot;));//注意写引号 结果： ⑤删除cookie123function removeCookie(name)&#123; setCookie(name,1,-1);//写成-1浏览器以为是昨天的就自动删了 &#125;]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML_DOM]]></title>
    <url>%2F2019%2F05%2F08%2FHTML-DOM%2F</url>
    <content type="text"><![CDATA[什么是DOM：DOM是文档对象模型，他分xhtml,html,核心dom三种，所以html dom就是可以对html文本中任何元素进行修改删除等操作 DOM节点 在html中任何元素都是节点，比如说整个文档是文档节点，每个html元素是元素节点，每个元素的文本是文本节点，属性是属性节点，注释是注释节点 各节点间有父(parent)，子(child)，同胞关系(sibling);根元素没有父元素，其他元素都有父元素 DOM属性· 这里只说innerhtml,这个属性是获取元素的文本内容12//.innerHTML是获取指定的元素文本内容//.innerhTML = &quot;&quot;是修改制定元素的文本 DOM方法 document对象，他是html文档的根节点，在满足两个条件下他会覆盖原来的 HTML文档，一个是在函数中用document.write,一个是按钮响应这个函数;在下面的我们直接用document.即可1234567&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;button onclick = func()&gt;点击覆盖&lt;/button&gt; &lt;script&gt; function func()&#123; document.write(23333); &#125; &lt;/script&gt; 点击前： 点击后： 访问节点①.getElementById(“”) ②.getElementByTargeName(“”)//标签，如p ③.getElementByClassName(“”)//不推荐使用，因为IE5,6,7,8不支持 改变HTML内容1234&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).innerHTML = &quot;hello world!&quot;; &lt;/script&gt; 结果：hello world! 改变CSS样式（通过.style.属性名访问CSS样式）12345&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &lt;/script&gt; 结果： 创建新元素 步骤一：创建新元素步骤二：若元素内需要有内容，需创建文本节点步骤三：将文本节点追加给新元素步骤四：将这个新元素追加给已有元素即父元素（必须有父元素）1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;sdsjkd&quot;); para.appendChild(tex); document.getElementById(&quot;div1&quot;).appendChild(para); &lt;/script&gt; 结果：123hellosdsjkd 1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var a = document.createElement(&quot;a&quot;); a.href=&quot;http://baidu.com&quot;; a.innerHTML=&quot;百度&quot;; document.getElementById(&quot;div1&quot;).appendChild(a); &lt;/script&gt; 结果： 删除已有元素1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var child=document.getElementById(&quot;p1&quot;);//获取子元素 child.parentNode.removeChild(child);//通过parentNode找到父元素 &lt;/script&gt; 结果: he 替换元素12345678910111213&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;snkslm&quot;); para.appendChild(tex); var parent = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p2&quot;); parent.replaceChild(para,child); &lt;/script&gt; 结果：123hellosnkslm 触发事件举个例子,也推荐这种形式，尽量不要写成内联1234567&lt;p id=&quot;p1&quot;&gt;点击我变颜色&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).onclick = func;//注意不能写func() function func()&#123; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &#125; &lt;/script&gt; 特别注意在触发事件时调用的函数不能写括号，因为写括号就直接在页面加载完成就立刻执行，不加括号才是在触发事件时响应]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在js中函数也是对象，因此可以把它赋给一个变量，一个数组元素，甚至作为参数传给另一个函数调用函数的定义 声明式的静态方式(所有浏览器都支持） function 函数名(形参列表){函数体}//注意没有var否则报错,且function必须小写 ①这种方式最常用，他只需定义一次，在程序的完整过程中，他一直被存在内存中，只在页面打开时解析一次，不论是什么调用它，返回的都是函数体处理完的结果 ②要设定返回值，他可以有0个到多个return,一般多个return 都用在需要判断条件时，即满足这个条件就不往下执行函数体内容 ③参数方面注意传参形式，一种是传值，一种是传地址，简单点说就是传值不改变实参，传地址改变实参12345678910function change(str1,arr) &#123; str1 = &quot;hello javascript!&quot;; arr[arr.length] = &quot;three&quot;;&#125;var str = &quot;hello world!&quot;;var arr1 = [&quot;one&quot;,&quot;two&quot;];change(str,arr1);document.write(arr1);//传地址，改变document.write(&quot;&lt;br /&gt;&quot;);document.write(str);//传值，不变 结果：12one,two,threehello world! 匿名函数(没有函数名，又叫动态函数，较新的浏览器支持)var hd = new Function(&quot;参数1&quot;，&quot;参数2&quot;，&quot;函数结构体&quot;)//F必须大写，必须是new 匿名函数是用一次定义一次，直接赋给变量 这种方式不常用，但是在只有运行时才能确定函数成立条件时，创建动态函数就很有必要123456789var func = prompt(&quot;请输入函数体&quot;);var x = parseInt(prompt(&quot;请输入x&quot;));var y = parseInt(prompt(&quot;请输入y&quot;));//注意promt返回的是字符串若不转换结果就是23var op = new Function(&quot;x&quot;,&quot;y&quot;,func);var result = op(x,y);document.write(&quot;function is &quot;+func+&quot;&lt;br /&gt;&quot;);document.write(&quot;x is&quot;+x+&quot;&lt;br /&gt;&quot;);document.write(&quot;y is&quot;+y+&quot;&lt;br /&gt;&quot;);document.write(&quot;result is&quot;+result); 结果：1234function is return x+yx is2y is3result is5 函数直接量（即赋给变量或作为另一函数的参数，新的浏览器支持7）①var func = (参数列表){函数体}//兼具了匿名函数和声明函数 ②var func = 函数名(参数列表){函数体} ③1234function fan(x,y,z)&#123; document.write((z(x,y)));&#125;fan(1,2,function(x,y)&#123;return x+y&#125;);//函数作为参数 结果：3 回调函数回调函数可以理解成，将回调函数作为参数放在一个新函数里，然后执行过程就是先执行新函数再反过来执行回调函数123456789//定义回调函数function fun1(value)&#123; document.write(value);&#125;//定义新函数并把回调函数作为参数function fun2(fun,value)&#123; fun(value);&#125;fun2(fun1,&quot;hi js!&quot;) 结果：hi js! 函数对象123456789function func()&#123; //arguments.length返回参数个数 for(var i=0;i&lt;arguments.length;i++)&#123; document.write(arguments[i]); //arguments[i]输出对应参数，arguments和length是作为对象的函数的属性 &#125;&#125;func(1,2,3); 结果：123]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day3]]></title>
    <url>%2F2019%2F05%2F06%2Fday3%2F</url>
    <content type="text"><![CDATA[1.为什么程序底层要用二进制数：因为cpu和内存其实是IC的一种,而IC它两端有引角，引角只能输入5或0伏电压，这与二进制只有0和1对应，因此，每个引脚对应二进制的一位 计算机处理信息的基本单位一般是8位，因此二进制的位数一般都是8的倍数，而8位就是1个字节所以，计算机处理信息的基本单位是字节 位权：oo的xx次方，二进制oo就是2，十进制oo就是10，以此类推]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象]]></title>
    <url>%2F2019%2F05%2F06%2Fjs%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[四种对象 javascript内置对象 浏览器对象模型中的对象(BOM) 文档对象模型中的对象 用户自定义的对象 下面总结的都是第一种，javascript的内置对象js对象中都有自己的属性和方法，也可以通过new来新建一个对象，有的对象要注意对象和函数的区分，比如Number对象和Number()和Number对象的实例化 Boolean对象 必须注意创建Boolean对象实例的方法必须是与new结合的构造函数var boo = new Boolean(true); 在Boolean对象被实例化后，可通过Object的方法toValue来访问它所封装的基本值if(boo.toValue())···; 也可直接访问if(boo) Number对象 要注意在js中他对数值得辨识度并不高，它不论是整数还是指数还是浮点数，一律处理成64位的浮点型，也就是说在js中只有浮点型 Number对象的实例化，可以用new也可以直接用Number(),但是用Number的话是number型，不是对象 Number对象的属性，注意是对象不是对象的实例化 ①MAX_VALUE 指js可接受的最大值 ②MIN_VALUE 指js可接受的最小值 ③NEGATIVE_INFINITY 指js中定义的负无穷值 ④POSITIVE_INFINITY 指js中定义的正无穷值12345678document.write(Number.MAX_VALUE);document.write(Number.MIN_VALUE);document.write(Number.NEGATIVE_INFINITY);document.write(Number.POSITIVE_INFINITY);/*若写成以下形式会报错,因为只能是Number对象的var num = new Number(4)document.write(num.MAX_VALUE); */ 结果：1.7976931348623157e+3085e-324-InfinityInfinity Number对象的方法 ①toString() 有一个形参，是一个2到36的整数，默认为10，是将对象的实例化按进制输出123var num = new Number(&quot;100&quot;);document.write(num.toString(2));//若是用Number()实例化的，也不慌，会将他转换成对象在用这个函数，在转回变量 ②toLocalString() 无形参，作用是转化为本地格式的字符串12var num = new Number(1876653);document.write(num.toLocaleString()); 结果：1,876,653 ③toFixed() 有一个形参代表要有的小数位数，范围是0到20，包括0,20，不写默认为0,注意这个会四舍五入，要是不够会用零补上12var num = new Number(187.6653);document.write(num.toFixed()); 结果：18812var num = new Number(23.56);document.write(num.toFixed(10)); 结果：23.5600000000 ④toPrecision() 有一个参数,代表有效数位，会四舍五入，参数取值范围是1到21包括1,21；若不写参数，就会调用toString()12var num = new Number(23.56);document.write(num.toPrecision(3)); 结果：23.612var num = new Number(23.56);document.write(num.toPrecision()); 结果：23.56 ⑤toExponential() 将数值表示成指数型，有一个形参，代表保留小数位,若省略参数将显示尽可能多的小数位12var num = new Number(23.56356789);document.write(num.toExponential(3)); 结果：2.356e+1 String对象 String对象属性：length,代表字符串字符数，注意这里不像c++要在最后再加一 String对象有些格式化html方法，如anchor()[设置html锚点]；link()[生成链接]；big()[放大字体]；blink()[生成闪动字体]；bold()[加粗字体]；italics()[设置斜体]；sub()[设置下角标]；sup()[设置上角标]；small()[缩小字体]；strike()[加一条删除线]; 值得注意的是，这种html格式化方法并不是所有浏览器都兼容，比如blink()他在ie就不兼容，所以我们要尽可能的避免使用这种html格式化方法，但是anchor()和link()除外，这两个还是可以用用的 1234var str = &quot;Hello world!&quot;str.anchor(&quot;myAnchor&quot;);//参数为锚点名alert(str.anchor(&quot;myAnchor&quot;)); 结果：12var str=&quot;baidu&quot;;document.write(str.link(&quot;http://www.baidu.com&quot;)); 结果： charAt()返回索引处字符，参数则为索引12var str=&quot;baidu&quot;;document.write(str.charAt(2)); 结果：i charCodeAt()返回指定位置的字符的unicode编码12var str=&quot;baidu&quot;;document.write(str.charCodeAt(3)); 结果：100 js中有三种截取字符串片段的方法，我首推slice(start,end)，其次subString(start,stop),不能推荐subStr，因为es6没有规范他，就不用他,而slice()和subString()唯一不同就是前者接受负数后者不接受 123var str=&quot;Hello happy world!&quot;document.write(str.slice(4,7))// 只包括不包括结尾即其实是截取了str[4]到str[6],若无第二个参数表示后面的都要，若这两个参数为负则用负数加长度 indexOf()和lastIndexOf() 返回子串最开始出现的索引和最后一次出现的索引，注意该函数对大小写十分敏感，若不存在返回-1 1234var str = &quot;Hello world&quot;;document.write(str.indexOf(&apos;w&apos;));document.write(str.indexOf(&apos;W&apos;));document.write(str.lastIndexOf(&apos;l&apos;)); 结果：6-19 split() 有两个参数，第一个参数是分割标志(写成字符串)，第二个参数可选，限定个数，这个其实就是拆分字符串,整成一个数组；需要说的是，splirt()也可直接用在变量后 document.&quot;sdh\nfbdkv\ffd&quot;.split(&quot;\&quot;,1) 结果:sdh12var str = &quot;Hello world&quot;;document.write(str.split(&quot; &quot;,1)); 结果：Hello toUpperCase()和toLowerCase()将字符串都变成大写和小写1234var str = &quot;hjfkdflk&quot;;document.write(str.toUpperCase());var str1 = &quot;DKFENDFLOR&quot;;document.write(str1.toLowerCase()); 结果：HJFKDFLKdkfendflor formCharCode()这是一个静态方法所谓静态方法就是只能是对象调用不能对象的实例化调用，这个方法是将unicode编码实例化成一个字符串 1document.write(String.fromCharCode(72,69,76,76,79)); 结果:HELLO Date对象实例化：var time = new Date(); Date对象方法 当所用的是例如网上商店下订单这种孤立的行为，使用用户本地的就行，若是像评论博客这种国际化的全体的行为，就设UTC Date()直接返回用户电脑的时间1document.write(Date()); 结果：Mon May 06 2019 15:49:35 GMT+0800 (中国标准时间) Math对象 Math对象的属性 Math对象的方法，注意这些都是静态方法，不需实例化javascript数组 在js中数组也是对象 数组对象的属性，length 数组对象的实例化方式可new可不new,定义数组后就可以用索引了，比如a[i] ①var arr = [&quot;apple&quot;,&quot;banana&quot;] ; ②var arr = new Array(3,4,5,6,2) ③12345var arr = new Array(3);arr[0]=(1,3);arr[1]=(3,5);arr[2]=(5,4);//二维及以上数组定义方法，再创数组对象 splice()[修改原来数组]实现对数组中元素的添加,删除，修改（每种前两个参数都是固定的，第一个是开始操作的索引，第二个是删除的数量），返回的是删除后组成的数组，即documentarr返回的是修改后的，documentarr.splice返回的删除的组成的数组1234//添加元素，注意不能写成document.write(arr.splice(0,0,&quot;people&quot;))因为返回的是删除的数组var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,0,&quot;people&quot;)document.write(arr); 结果：people,apple,banana,pear,pen1234//删除元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1)document.write(arr); 结果：banana,pear,pen1234//替换元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1,&quot;people&quot;)document.write(arr); 结果：people,banana,pear,pen slice()[不改变原来数组]，即documentarr返回的是原来的数组，documentarr.slice返回的是修改后的数组，作用是返回截取的元素，两个参数，第一个参数是其实的索引(包括)，第二个参数是结束的索引(不包括)12var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr.splice(0,3)); 结果：apple,banana,pear concat()[不改变原来数组]即documentarr返回的是原来的数组，documentarr.concat返回的是修改后的数组，作用是连接数组123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);var arr2 = new Array(&quot;story&quot;);var arr3 = new Array(&quot;fish&quot;)var arr4 = [3,4,5];document.write(arr1.concat(arr2));//连接两个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr1.concat(arr2,arr3));//连接三个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr4.concat(6,7));//连接参数 结果：123apple,banana,pear,pen,storyapple,banana,pear,pen,story,fish3,4,5,6,7 join() 将数组中对象用自己定义的分隔符输出12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.join(&apos;|&apos;)); 结果：apple|banana|pear|pen reverse() 颠倒数组顺序12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.reverse()); 结果：pen,pear,banana,apple push()和pop() 组合使用实现先进后出栈 push()实现在数组的最后面依次加元素,返回新长度；pop()实现删去数组最后一个元素，返回被删除的元素；123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.push(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.pop());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346apple,banana,pear,pen,people,girlgirlapple,banana,pear,pen,people unshift()[ie不支持]和shift() 前者可以有多个参数，作用是加在数组最前面，第一个参数为a[0]以此类推，返回的是新长度，后者是删除最前面的元素，返回被删除的元素即原数组的首元素123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.unshift(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.shift());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346people,girl,apple,banana,pear,penpeoplegirl,apple,banana,pear,pen 遍历数组12345var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);for(var x in arr1)&#123; document.write(arr1[x]); document.write(&quot;&lt;br /&gt;&quot;);&#125; 结果：1234applebananapearpen]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day2]]></title>
    <url>%2F2019%2F05%2F05%2Fday2%2F</url>
    <content type="text"><![CDATA[程序运行时，程序计数器指向一个地址值，然后顺序结构的话，每进行一条指令，程序计数器上的值加一 其实cpu处理程序很有意思，像是比较累加寄存器和通用寄存器中的值，他实际上会进行减法运算，通过正负零来判断谁大谁小 运算结果存放在标志寄存器，无论结果是什么都会存放进去，同时标志寄存器还负责存放溢出和奇偶判断 分支结构是用的跳转指令，即运行时程序计数器不是单纯的一条指令加一 函数调用，实际上是先把调用处以下的指令先存放在栈，然后进行call到函数体进行，处理完函数体后，再return回到调用处的下一指令指向的地址，把栈上存放的指令读入到程序计数器上，再接着往下 说到划分内存，实际上要用到基址寄存器和变址寄存器，我们所说的实际地址值就是基址寄存器的值加上变址寄存器的值，而变址寄存器实际上就是我们所熟悉的数组的索引 正，0，负实际上存在32位的标志寄存器上的前三位]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运算符和语句]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[js语句的格式 要养成每条语句后都写分号的习惯 在js代码中，空白没意义，为了让代码更直观更易于维护，可尝试养成在等号前后，加号等前后写空格的习惯赋值语句 由左边变量，赋值变量和右边被赋给的值组成 右边的表达式可以是直接量值var vm = 35;一个变量和直接量再加上运算符的组合var value = vm + 27;函数的调用var nvalue = escape();一行可以包含多个赋值语句var a = b = c = 23; 二元运算符 二元运算符有加(+)减(-)乘(*)除(/)取余(%)注意在js中除法保存的是浮点数而不是截取的整数 这里重点说一下加法运算符，在字符串那里要特别注意，当两个运算数中有字符串时会优先将+解析为连接运算符12var vm = &quot;3.99&quot; + 2.7;document.write(vm); 结果：3.992.7 而对于其他的二元运算符，只要两个操作数中的字符串内只有数字就可以计算12var vm = &quot;3&quot; * 2;document.write(vm); 结果：6 为了在用加号时规避这种错误，最好采用parseInt或者parseFloat函数显式地转化一下字符串12var vm = parseInt(&apos;3&apos;) + 3;document.write(vm); 结果：6 一元运算符 一元运算符有负值运算符，自增运算符，自减运算符12345var vm = 2;var value = -vm;document.write(value);var nvalue = ++value;document.write(nvalue); 结果：-2-1 注意自增自减都有前置后置之分，前置是先自己变值在赋值，后置是先赋值在自己变值逻辑运算符，三元运算符，各种语句需要注意的因为有了c++基础就不多说什么事if循环啊啥的，记一点容易犯错的 注意短值运算，就是与的话当第一个表达式返回0，就不往下看了，这个直接就是假；是或的话当第一个表达式返回1，直接就是真，考虑到cpu等内存占用，应该把重要的依据放在前面 注意===和==区别，前面的是等同，现在已经广泛应用，因为当时字符串和数值比较，会先隐式地把字符串转化为数值型，用等同则返回false,用等于则返回true switch语句，注意写break,default;当多种情况是同一入口时，最好用如下形式： 1234case a:case b:case c:document.write(&quot;hhhhh&quot;); 注意if语句的条件里千万不能写等于号，最次也得写个== 当想至少进行一次循环时，选do···while而不用while 注意一下for循环中的for in型，在后面会用到比如遍历数组啥的，以后再说，先简单举个栗子1234object(&quot;a&quot;:b,&quot;c&quot;:d)for(x in object)&#123; txt += object[x] ;&#125; 结果：cd]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day1]]></title>
    <url>%2F2019%2F05%2F04%2Fday1%2F</url>
    <content type="text"><![CDATA[CPU和内存是由很多的晶体管组成，他俩合称IC（集成电路） CPU由寄存器，运算器，控制器和时钟组成 程序运行过程：首先由程序员用高级语言写出程序，然后把程序编译成机器语言（即exe文件），然后将这个exe文件在内存上存一个副本，然后再在CPU上解析运行 将CPU的解析和运行过程放大来讲，是时钟先发出时钟信号，cpu开始工作啦，他先让寄存器去抓内存上的数据，然后运算器进行运算，然后控制器通过运算结果来控制整个计算机，其实也就是控制输入输出什么的 实际上，对于程序员来说可以把CPU简单的理解为是很多很多寄存器的集合体，寄存器有很多种，不仅是他们存储的类型上，比如有的是存数值这种数据的，有的他是存地址这样的数据 汇编语言是由助记符组成的（比如将addition写成add），他和机器语言实际上是一一对应的，每一个机器语言实际上都有对应的汇编语言。因而，我们把将汇编语言转换成机器语言成为汇编过程，把机器语言转换为汇编语言称为反汇编过程 其实，编译器汇编器这种的并不是我们所想的一种组件什么的，他其实就是一个程序 我们可以简单地把程序运行的过程就当成是各种寄存器之间的处理，因此我们只要知道CPU是寄存器的集合体就好 内存，我们叫主储存器，现在一般都是DRAM（动态随机存储器），就是储存数据啊啥的，1个字节是8位，每个都有地址]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型与变量]]></title>
    <url>%2F2019%2F05%2F04%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[标识符 标识符只能由数字，字母，$符和下划线表示 首字符必须是字母或$符或下划线，切记不能是数字 在所使用的的作用域内，每个变量的标识符是唯一的 可在变量标识符中使用Unicode的字母和数字，官网链接 可使用转义序列 区分大小写 不得使用js关键字，ECMA 262规范的保留字，浏览器中典型的保留字，具体如下图 js关键字 ECMA 262规范的保留字 浏览器中典型的保留字 尽量使用有意义的，提高可维护性 一些小规范：①项目的集合名称应用复数②对象名首字母大写③函数和变量以小写字母开始并使用驼峰法,也可每个单词间用下划线作用域 局部变量：在一个函数内定义，初始化，函数结束时变量不存在 全局变量：在所有地方都可访问，包括引入的js库 要养成写var的习惯，因为当你想要定义一个局部变量但没有写var就会被当做全局变量，也就是说全局变量可不写var但最好也要写字符串型 单引号和双引号作用一样，不做区别；但是当需要嵌套时不能同型套同型，只能是单引号套双引号或双引号套单引号 字符串中可包括转义序列，例如 \n \\ \&#39; \&quot; 可使用escape函数和unescape函数进行编码和解码，但需要注意的是这两个函数不能处理非ASCII码字符，这是可使用encodeURI和decodeURI函数，下面是使用escape函数和unescape函数的示例12document.write(escape(&quot;sbadkf65488$%^&quot;));document.write(unescape(&quot;sbadkf65488%24%25%5E&quot;)); 结果：sbadkf65488%24%25%5Esbadkf65488$%^ 空字符串是一种特殊情形，一般用来初始化 字符串连接:12var year=2019;document.write(&quot;今年是&quot;+year+&quot;年&quot;); 结果：今年是2019年 toString函数，将其他类型转换为字符串类型123document.write(boo.toString());//显示数据类型document.write(typeof boo.toString()); 布尔型 只有true和false两种，不能用引号包起来 Boolean函数,将其他类型转化为布尔型。需要注意的是没有toBoolean函数了，是Boolean函数！！！！还有强调一下有管字符串转成布尔型，当是空字符串时返回false，当是一个及以上空格时返回true,具体实践如下1234var s=Boolean(&quot;&quot;);document.write(s);var r=Boolean(&quot; &quot;);document.write(r); 结果：falsetrue 数值型 js中数字是浮点型，需要注意的是，js的计算能力不是很强，所以在数字方面一般不是很精确 可取数范围是-2e31到2e31;js中规定正无穷用Infinity表示，负无穷用-Infinity表示；当某函数出现溢出时则会返回一个Infinity（正无穷） parseFloat()和parseInt(),这两个函数都可用于在字符串中提取出数字，但需要注意的是只能提取出第一个字符就是数字的字符串否则报错，其次，parseInt()只取整数部分，注意事项截取而不是四舍五入;这两个函数还可将八进制或十六进制数转化为十进制，只需在后面加一个参数默认为10，具体例子如下1234var str1=parseInt(&quot;0x5F&quot;,16);document.write(str1);var str2=parseFloat(&quot;171.8cm&quot;);document.write(str2); 结果：95171.8 isFinite函数，用来判断无穷大，当值是无穷大或NaN时返回false,否则返回true Number函数，将其他数据类型转换为数值型,注意字符串类型，只有在字符串内全部是数字时才有用，否则返回NaN12var str2=Number(&quot;171.8cm&quot;);document.write(str2); 结果：NaN 常量const 变量名 = 值； 只定义一次 null与undefinedjavaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺 javaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 null值则是表示空对象指针 其实，null就给他理解成一个空对象，暂时赋给一个变量，而undefined就是当访问为初始化的变量时返回undefined]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[myBlog]]></title>
    <url>%2F2019%2F05%2F04%2FmyBlog%2F</url>
    <content type="text"><![CDATA[嘻嘻嘻。 吼吼吼。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
