<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异步处理]]></title>
    <url>%2F2020%2F03%2F01%2F%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[同步和异步​ 同步和异步是一种消息通知机制 ​ 同步: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。 ​ 做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事 ​ 异步: A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。 ​ 做一件事，不用等待事情的结果，然后就去忙别的了，有了结果，再通过状态来告诉我，或者通过回调函数来处理。 ES6 Promise对象 ES6的Promise对象是一个构造函数，用来生成Promise实例。所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数 哎呀呀呀呀呀呀，乍一看有点难懂，现在通过一个小应用，来讲解一下这个promise咋用把~ 12345678910111213141516171819202122232425262728// promise的使用// promise 下有俩个参数 分别是 resolve 和 reject let p = new Promise((resolve,reject)=&gt;&#123; // 请求一张图片 let img = new Image(); img.src = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564676679229&amp;di=189f903018a2854e74fbac3834f55d4e&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Ff54083119edfb83c4cfe9ce2eeebc076.jpeg'; img.onload=function()&#123; resolve('成功了')//必须传参 &#125; img.onerror=function()&#123; reject('失败了')//也可reject(),可以不传参 &#125; &#125;) // pending 等待状态 // resolve 成功状态 // reject 失败状态 console.log('21:',p);//[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined //then 是在promise返回结果之后才执行 // then里面可以传递2个函数 // 第一个函数 成功时执行的函数 // 第二个函数 失败时执行的函数p.then((info)=&gt;&#123; console.log('图片'+info) &#125;,(msg)=&gt;&#123;//可以()=&gt;&#123;&#125;不传参 console.log('图片'+msg) &#125;) then的返回值，会返回一个新的 Promise 对象, 但是状态会有几种情况: then 的回调函数中没有返回值，then就会返回一个状态为: resolved 的 promise 对象 then 的回调函数返回值是 非 promise 的值, then就会返回一个状态为: resolved 的 promise 对象，另外会把返回值，传递给 下一个 then then 的回调函数返回值是 promise 对象，then 就直接返回这个 promise 对象，具体的状态可以由我们自己定义,具体传递的值，也由我们自己定义 123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; resolve('123') &#125;) p.then((info)=&gt;&#123; console.log(info) // return 123; //后面then会返回成功了123(对应上面的第二条，有return值时) return new Promise((resolve,reject)=&gt;&#123; reject();//后面then会返回失败了(对应上面的第三条) &#125;) &#125;).then((msg)=&gt;&#123; console.log('成功了',msg) &#125;,()=&gt;&#123; console.log('失败了') &#125;) async 函数 和 await async和await是成对存在的，这么做就是用同步解决异步问题，我想让请求三执行完了请求二执行，请求二执行完了请求一执行，有这么一个次序关系 all和race方法 123456789101112131415161718192021222324252627282930313233343536373839// 所有的promise都成功的情况下 才会执行的函数 let p1= new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; resolve() &#125;, 500); &#125;) let p2= new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; reject() &#125;, 300); &#125;) let p3= new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; resolve() &#125;, 2000); &#125;) // Promise.all 只有所有状态都是resolve才会成功 let allP = Promise.all([p1,p2,p3]); console.log(allP) allP.then(()=&gt;&#123; console.log('成功了') &#125;,()=&gt;&#123; console.log('失败了') &#125;) // Promise.race 这一个数组中的promise 谁跑的最快 就是谁的结果！ let raceP = Promise.race([p1,p2,p3]); console.log(raceP)//p2最快，所以是失败了 raceP.then(()=&gt;&#123; console.log('成功了') &#125;,()=&gt;&#123; console.log('失败了') &#125;)]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2020%2F02%2F25%2FES6%2F</url>
    <content type="text"><![CDATA[let和constvar: 1. var可以重复声明 2. 作用域：全局作用域和函数作用域 3. 会进行预解析 let: 1. 同一作用域下不可以重复声明 2. 作用域：全局作用域和块作用域{} 3. 不会进行预解析 const: 1. 只能声明一次，且必须直接赋值 2. 作用域：块级作用域 3. 不会被预解析 4. 不能重新赋值 解构赋值对象的解构赋值 123456let obj = &#123; a:1, b:2&#125;let &#123;a,b&#125; = obj;//这里用c,d就不行，必须和对象的属性名一致console.log(a,b);//1 2 数组的解构赋值 123let arr = ["a","b"];let [c,d] = arr;//名字可不一样，位置对应了就行console.log(a,b);//a b 怎么快速交换两个值(用到解构赋值) 1234let a=1;let b=2;[a,b]=[b,a];console.log(a,b);//2 1 字符串的解构赋值(没啥用) 123let str = "abc";let [c,d] = str;console.log(a,b);//a b 展开运算符(…)扩展： 12let arr1 = [1,2,3,4];let arr2 = ["a",...arr1,"b,"c];//当使用这种方式插入就会很方便 剩余参数 123let arr1 = [1,2,3,4];let [a,b,...c] = arr1;console.log(c);//[3,4] 以上用法在对象中依然适用，就不再赘述 解决浅复制问题 如果let arr2=arr1 这样直接赋值的话会造成在我修改arr2时，arr1也变了 但如果我用扩展运算符就可以完美避开这个问题 1234let arr1=[1,2,3,4];let arr2=[...arr1];arr2[0]=3;console.log(arr1[0]);//1 Set数组去重 12345678910let arr = [1,2,3,2,1,4,5];let s = new Set(arr);console.log(s);//&#123;1,2,3,4,5&#125; 注意这不是数组console.log(s.size);//5 size属性：个数s.clear();//清空所有值s.delete(4);//传入的是要删除的具体值，而不是数组下标 返回true或false是否删除成功【s.add(6); //添加也包含去重功能，若添加已有元素则添加不成功，返回set本身 s.has(5);//检验是否包含，返回true和false//将s转为数组arr = [...s]; Map123456789101112131415let arr = [ ["a",1], ["b",2], ["c",3]];//写成一维数组是不得行的，必须写成这样式的俩值let m = new Map(arr);console.log(m);//&#123;"a"=&gt;1,"b"=&gt;2,"c=&gt;3"&#125; Map方法将其改变为键值形式console.log(m.size);//3 size属性：个数m.clear();//清空所有值m.delete("a")//传入的是要删除的key值，而不是数组下标 返回true或false是否删除成功 会将key value都删了m.get("b");//返回key对应的valuem.set("d",4).set("a",2);//添加也可修改 注意不是add 可迭代m.has(5);//检验是否包含，返回true和false//将s转为数组arr = [...m]; 箭头函数箭头函数： 形参=&gt;返回值 12let fn=num=&gt;num*2;console.log(fn(2));//4 (形参，形参)=&gt;返回值 12let fn=(num1,num2)=&gt;num1+num2;console.log(fn(1,2));//3 ()=&gt;返回值 12let fn=()=&gt;"返回值";console.log(fn());//"返回值" ()=&gt;{ 执行语句 return 返回值(可选) } 1234let fn=()=&gt;&#123; console.log("a");&#125;;fn();//"a" (形参)=&gt;{ 执行语句 return 返回值(可选) } 箭头函数不能用不定参(arguments) 但可以用扩展运算符解决(又叫rest参数) 1234let fn = (a,b,...arg)=&gt;&#123; console.log(arg);&#125;fn(1,2,3,4); 箭头函数本身没有this，当调用箭头函数的this时，指向其声明时作用域的this 参数默认值问题 1234let fn = (a=2,b=10)=&gt;&#123; console.log(a*b);&#125;fn();//尽管忘记传参数了，也会得到结果20，不会返回undefined Array.from() 将类数组转换为数组 先康康啥是类数组，就是由下标，有值但他不是数组 1234&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt; 12345let lis=document.querySelectorAll("li");lis=Array.from(lis);//当然也可以用展开运算符将类数组转换成数组啦lis=[...lis];//接下来lis就可以愉快的使用数组的方法啦，比如forEach啥的 Array.from还有两个可选参数，一个是类似于map方法，另一个就是改变this指向(我觉得没啥用，就不记了) 12345let lis=document.querySelectorAll("li");lis=Array.from(lis,(item,index)=&gt;&#123; console.log(item,index); return index;&#125;); Array.of()将传入的参数组成一个新数组 1console.log(Array.of(1,2,3,4,"a"));//[1,2,3,4,"a"] Array.isArray() 检测传入的是否是数组 arr.find()返回数组中第一个满足判断条件的值，若没有就返回undefined 参数是一个回调函数 123456789let arr = [1,2,3,4];let val = arr.find(item=&gt;&#123;//index,arr可选 if(item&gt;3)&#123; return true; &#125;&#125;);//简写let val = arr.find(item=&gt;item&gt;3);console.log(val); arr.findIndex() 除了这个返回的是索引值，剩下的和find方法一样 arr.flat(depth) 扁平化多维数组 depth指要提取嵌套数组的结构深度，默认值是1 当然，当你不知道数组有多少层的时候，可以直接传Infinity 返回“拉开的”数组 123456let arr = [ [1,2], [1,[3,6, [4,5]]]]console.log(arr.flat(Infinity));//[1,2,3,6,4,5] arr.flatMap() 在扁平化的同时想要进行一些操作，比如删除某一项时，可以使用此方法，参数是回调函数 but 这个函数只能处理一层，如果层数太多，需要递归 12345678910111213let arr = [ ["小明",18]， ["小刘",19]]let newArr = arr.flatMap(item=&gt;&#123; //使用过滤器方法去掉年龄那一项 item=item.filter((item,index)=&gt;&#123; //使索引值为0，来做到删除年龄 return index==0; &#125;) return item;//注意这里一定要写返回值&#125;)console.log(newArr);//["小明","小刘"] arr.fill() 填充作用，一般用于操作二进制 123let arr = [0,1,2,3,4];console.log(arr.fill("a",1,4));//[0,"a","a","a",4]//三个参数，(替换值，起始位置[可选]，终止位置(不包含，可选))，且终止值默认值为arr.length 不能使数组变长 arr.includes() 判断数组中是否包含一个指定的值 12let arr = [1,2,3,4,5];console.log(arr.includes(1,2));//false 两个参数(查找值，从第几位开始查找(可选)) 字符串也有includes方法，用法和参数与数组的完全一致 str.startsWith() str.endsWith() 123let str = "肥肥肥最厉害";console.log(str.startsWith("肥肥",2));//false，第二个参数(可选)代表从第几位开始作为头，本例中应该是肥最console.log(str.endsWith("肥肥肥",3));//true，第二个参数(可选)代表第几位的前一位为尾 str.repeat() 将字符串重复多少次，不能太大数，比如几亿次啊，浏览器会撑不住 12let str = "a";console.log(str.repeat(3));//"aaa" 模板字符串 插值表达式 ${} (取代字符串拼接中的+””+) , 里面的值只要是表达式即可，可以是函数调用啊，三目运算啊，都可以;首尾用 即可，取代了单双引，且其中可以任意换行而不报错 123456789let name = ()=&gt;&#123; var a = "小明";//当然实际运用中可能是一些非常复杂的操作 return a；&#125;let age = 18;let str = ` 今年$&#123;name()&#125;终于$&#123;age&gt;15?age:"保密"&#125;了！ `;console.log(str);//今年小明终于18了 对象的简洁表示法123456789let a = 0;let b = 1;let obj = &#123; a,//a等于a，打印出来就是a:0，等同于a:a b, c()&#123;//当对象中某一属性值是方法时，可以这么简化，取代之前那种还要写function的 console.log("a"); &#125;&#125; 属性名表达式1234567let name = "小明";let obj = &#123; [name]:111//给属性赋上变量名&#125;console.log(obj);//"小明"：111//按老办法写obj[name]=111; Object.assign() 合并对象，两个参数(源对象，目标对象) 123456789let obj = &#123; a:1, b:2&#125;let obj1 = &#123; c:3, d:4&#125;obj1 = Object.assign(&#123;&#125;,obj,obj1); 当然，我认为使用扩展运算符更方便一些，不需要考虑位置顺序 Object.is() 传两个参数，判断是否完全相等，和===类似，但是又有不同之处，具体如下 12345Object.is(NaN,NaN);//trueNaN===NaN;//false+0===-0;//trueObject.is(+0,-0);//falseObject.is(1,"1");//false 强类型 babel12345&lt;head&gt; &lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;script type="text/babel"&gt;&lt;/script&gt; 上面只是平时简单的测试，用babel，可以将ES6转化为可兼容的，当然也不是所有ES6新增的他都能转化，使用的还需要小心一点，之前要测试哦；至于应用到项目里的高阶使用方法，以后再说····]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F2020%2F01%2F15%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[transition 元素的样式发生改变，给元素添加一个过渡动画 参数： - transition-delay 延迟时间，动画延迟多长时间执行(s|ms) 默认值0s 可选 - transition-duration 动画时长，动画用多长时间完成(s|ms) 默认值 0s 必要 - transition-property 要动画的样式 (即css属性，如width等)默认值 all，若分别对不同属性设置不同动画，中间用逗号隔开 eg：transition: 1s width, 1s 2s height; - transition-timing-function 动画形式 linear 匀速 ease 缓冲(默认值) ease-in 加速 ease-out 减速 ease-in-out 先加速再减速 贝塞尔曲线运动 cubic-bezier()* transition 在使用时需要注意一个小问题，我们首先来看看下面这个代码 我们给box加了一个两秒的动画，让他的宽从100变为500，但实际上，他只是在点击按钮式显现并变化但没有动画效果，原因是元素在页面上渲染完之前，transition 是不起效果的，也就是当我点击按钮时，浏览器让box显示出来是需要渲染时间的，虽然很短，但仍长于解析速度，也就是我可能几微秒的时间内就已经解析到动画那一步了，但我还没渲染完，而我们又无法监视浏览器什么时候渲染完，因此可以设置一个稍微长一点时间的计时器来解决这个问题，时间最好不要少于20ms 这下，问题就迎刃而解啦 transitionend 一个监测动画结束的事件 照理来说，应该可以像鼠标移入啊，我用item.ontransitionend就可以触发事件，但好像不行，应该用下面这种形式 其中，注意后面的WebKitTransitionEnd，这是为了兼容一些低版本的，这些大小写很烦，要仔细点。 监听事件 事件监听基本用法 ：item.addEventListener(‘事件名(不加on)’,fn); 取消事件监听：item.removeEventListener(‘事件名(不加on)’,fn); 如果要取消不能使用匿名函数* 不用匿名函数什么意思，就是防止后来取消的时候找不到，也就是不能写成 12345678item.addEventListener('click',function()&#123;&#125;)function()&#123; item.removeEventListener('click',function()&#123; &#125;)&#125; addEventListener是很常用的一种手段，相比较于用on事件，这种方式更好，因为他不会覆盖，你可以同时为一个元素添加多个点击事件且都会生效，如果用on事件就会被覆盖只有一个生效 那给个正确的例子吧 123456box.addEventListener("click",fn);function fn()&#123; var w = parseInt(getComputedStyle(box)["width"]); this.style.width = w + 100 + "px"; box.removeEventListener("click",fn);&#125; 上面这个例子就是如果写了取消，那一次点击后，下一次不会再生效；要是不写取消，宽度就会随着你的点击次数逐渐增加100px animation 与transition相比，可以精确动画，需要动画帧keyframes 先来看看keyframes的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;style&gt; /* 动画帧 */ //move为动画帧名，在后面调用animation时要注明使用哪个动画帧 @keyframes move &#123; /* 0%&#123; width: 100px; height: 100px; &#125; 动画帧不定义的时候，默认就使用计算后样式(即元素本来的样式) */ //某些情况下需要将0%写成与计算后样式不一样的，如下 /* 0% &#123; width: 0; height: 0; &#125; */ 25% &#123; width: 100px; height: 300px; &#125; 50% &#123; width: 300px; height: 300px; &#125; 75% &#123; width: 300px; height: 100px; &#125; /* 100% &#123; width: 100px; height: 100px; &#125; 100% 不定义 默认会回到计算后样式，剩下的与0%哪里一样 */ 100% &#123; width: 0; height: 0; &#125; &#125; /* 默认动画执行完毕之后，会回到计算后样式 */ #box &#123; width: 100px; height: 100px; background: red; animation: move 2s; &#125;&lt;/style&gt; animation的属性 - animation-name 动画帧名称 必需 - animation-duration 动画持续时间 必需 - animation-timing-function 动画形式(参考 transition) - animation-delay 动画开始前的延迟时间 - animation-iteration-count 动画执行次数 number(具体的数字) | infinite(无限次) - animation-direction alternate(1,3,5奇数次正常，2,4,6偶数次倒序执行倒序执行) normal顺序执行 -animation-fill-mode: ​ backwards 动画开始前，元素的样式保留在动画帧 0 ​ forwards 动画结束后，元素的样式保留在动画帧 100 ​ both: backwards + forwards(开始前在0，结束后在100，即不回到计算后样式) -animation-play-state: paused 暂停, running 播放 低版本兼容需要写成-webkit-animation··· 把很多属性写进animation时可没有顺序，但一定是动画持续时间在动画延迟时间前 animation相关事件12345678910box.addEventListener("animationstart",function()&#123; console.log("动画开始"); &#125;); box.addEventListener("animationend",function()&#123; console.log("动画结束"); &#125;); // animationiteration 动画多次执行时，使用，监听动画又开始 box.addEventListener("animationiteration",function()&#123; console.log("动画又开始"); &#125;); transform 变换：旋转，斜切，缩放，位移 旋转：rotate() 单位deg 斜切：*skew(x,y) ​ skewX() +:左上角，右下角 -:右上角，左下角 与y轴夹角 ​ skewY() +:左上角，右下角 -:右上角，左下角 与x轴夹角 ​ 单位：deg 缩放：(倍数) ​ scale(x ,y) 一起缩放 ​ scaleX() ​ scaleY() 位移：translate(x,y) ​ translateX() ​ translateY() ​ 单位：px 变换原点： ​ 默认 旋转，缩放，斜切 都是围绕着元素的中心点进行变换 ​ transform-origin 变换基点 (旋转，缩放，斜切 围绕着那个点进行) ​ 默认值： center center ​ 0,0点 在元素的左上角 注意，当写多个函数变换时，后写的先计算样式 如上面栗子，第一个是先算好缩放到一半再移200，第二个是先移200，再缩，因此第一个比第二个多走100 js获取transform 或许你想这样子获取 getComputedStyle(item)[&quot;transform&quot;] but你得到的将是这么个玩应儿 matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0) 没错，上面所讲的旋转啊，位移啊，其实都是css为了方便我们使用才弄得，事实上，我们做的都是对就九个数操作，emmmm就是矩阵，等3D的时候就是16位啦哈哈哈哈哈哈哈哈，不过我们只用操作12位就可以了 换句话说，你获取不到transform的哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 emmmmmm不过你可以通过js对这9个数进行你想要的旋转缩放位移！了解就好，一般用不上哈，线性代数还可以再等等。 那先来看看简单的，就位移吧 首先默认情况下matrix是这样的 1234567// matrix(1, 0, 0, 1, 0, 0); var a = 1; var b = 0; var c = 0; var d = 1; var e = 0; var f = 0; 那你要是问我为啥是这样的，我也不知道，记住就好了哈哈哈哈哈，不行就百度一下子 因而我们就用a~f代替一下子这9个数，到时候字符串拼接好用 那就来看看位移的实现吧 1234567891011121314// x 位移 function translateX(x)&#123; e += x; //对e操作 box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125;// y 位移 function translateY(y)&#123; f += y;//对f操作 box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125; box.onclick = function()&#123; translateX(10);//调用 translateY(10);//调用 &#125;; 是不是很简单哈哈哈哈哈，那再来看看缩放吧，也差不多的 123456789101112131415161718// x 缩放（a,c,e） function scaleX(x)&#123; a *= x; c *= x; e *= x; box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125; // y 缩放(b,d,f) function scaleY(y)&#123; b *= y; d *= y; f *= y; box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125; box.onclick = function()&#123; scaleX(1.2); scaleY(1.2) &#125;; emmmm在说旋转之前先来看看一些基础叭 1234Math.tan(rad) 正切函数//你像这个rad就是烦人之处，他不接受角度，因而我们需要把角度转换成弧度一下子Math.PI π圆周率角度转弧度: deg/180*Math.PI 下面来看正题-旋转的实现 12345678function rotate(deg)&#123; a=Math.cos(deg/180*Math.PI); b=Math.sin(deg/180*Math.PI); c=-Math.sin(deg/180*Math.PI); d=Math.cos(deg/180*Math.PI); box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125; rotate(30); 再来看看斜切~ 12345678910// x轴倾斜 function skewX(xDeg)&#123; c = Math.tan(xDeg/180*Math.PI); box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125;// y轴倾斜 function skewY(yDeg)&#123; b = Math.tan(yDeg/180*Math.PI); box.style.transform = 'matrix('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')'; &#125; transform 3D 实现3D，必须加上这两个东西 transform-style: preserve-3d; 设置到父元素，使其子元素保留其3D位置 perspective 景深，一般设置到父样式的父元素，设置成想加3D效果的元素的一两倍即可 还有一个需要你灵活设置，那就是transform-origin,就是你看的角度，emmm我觉得应该是位置好一点，相对于2D，3D这里需要多设置一个z轴距离，设置在父元素上 像这样transform-origin: center center -100px; 还有一个属性 ​ backface-visibility: hidden; 当元素不面向屏幕时是否可见。 设置在3D变化的元素上即可 以上所总结的是设置在父元素上还是哪上如果忘了，可以去看看3D导航这个demo 下面再来讲讲3D实现方法 transform3D 变换 ​ 1. 旋转 ​ rorateX() 围绕着 X 轴的旋转 (上下翻转) ​ rorateY() 围绕着 Y 轴的旋转 ​ rorateZ() 围绕着 Z 轴的旋转 ​ 2. 位移 ​ translateZ z轴位移 Tween动画算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167var Tween = &#123; linear: function (t, b, c, d)&#123; //匀速 return c*t/d + b; &#125;, easeIn: function(t, b, c, d)&#123; //加速曲线 return c*(t/=d)*t + b; &#125;, easeOut: function(t, b, c, d)&#123; //减速曲线 return -c *(t/=d)*(t-2) + b; &#125;, easeBoth: function(t, b, c, d)&#123; //加速减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t + b; &#125; return -c/2 * ((--t)*(t-2) - 1) + b; &#125;, easeInStrong: function(t, b, c, d)&#123; //加加速曲线 return c*(t/=d)*t*t*t + b; &#125;, easeOutStrong: function(t, b, c, d)&#123; //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;, easeBothStrong: function(t, b, c, d)&#123; //加加速减减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t*t*t + b; &#125; return -c/2 * ((t-=2)*t*t*t - 2) + b; &#125;, elasticIn: function(t, b, c, d, a, p)&#123; //正弦衰减曲线（弹动渐入） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125;, elasticOut: function(t, b, c, d, a, p)&#123; //*正弦增强曲线（弹动渐出） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; &#125;, elasticBoth: function(t, b, c, d, a, p)&#123; if (t === 0) &#123; return b; &#125; if ( (t /= d/2) == 2 ) &#123; return b+c; &#125; if (!p) &#123; p = d*(0.3*1.5); &#125; if ( !a || a &lt; Math.abs(c) ) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; if (t &lt; 1) &#123; return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; &#125;, backIn: function(t, b, c, d, s)&#123; //回退加速（回退渐入） if (typeof s == 'undefined') &#123; s = 1.70158; &#125; return c*(t/=d)*t*((s+1)*t - s) + b; &#125;, backOut: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; //回缩的距离 &#125; return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; &#125;, backBoth: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; &#125; if ((t /= d/2 ) &lt; 1) &#123; return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; &#125; return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; &#125;, bounceIn: function(t, b, c, d)&#123; //弹球减振（弹球渐出） return c - Tween['bounceOut'](d-t, 0, c, d) + b; &#125;, bounceOut: function(t, b, c, d)&#123;//* if ((t/=d) &lt; (1/2.75)) &#123; return c*(7.5625*t*t) + b; &#125; else if (t &lt; (2/2.75)) &#123; return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; &#125; else if (t &lt; (2.5/2.75)) &#123; return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; &#125; return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; &#125;, bounceBoth: function(t, b, c, d)&#123; if (t &lt; d/2) &#123; return Tween['bounceIn'](t*2, 0, c, d) * 0.5 + b; &#125; return Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; &#125;&#125;;/* Tween四个必要参数: - t: current time（当前时间 - 当前运动次数） - b: beginning value（初始值） - c: change in value（变化量） - d: duration（持续时间 - 运动总次数） */(function()&#123; var run = document.querySelector("#run"); var stop = document.querySelector("#stop"); var box = document.querySelector("#box"); var x = 0; var speed = 5; var timer = 0; var t = 0; //动画执行到第几次 (动画已经消耗的时间) var b = 100; // 动画开始前的初始值 var c = 500; // 动画初始值 和 目标点之间的差值 var d = 60; // 动画执行总次数, 动画执行时间 run.onclick = function()&#123; cancelAnimationFrame(timer); timer = requestAnimationFrame(move); function move()&#123; t++; var val = Tween["elasticOut"](t,b,c,d);// val 动画执行到第 t 次时，动画应该走到哪个位置 // console.log(val,t); //box.style.transform = 'translateX('+val+'px)'; box.style.width = val + 'px'; console.log(t); if(t &lt; d)&#123; timer = requestAnimationFrame(move); &#125; &#125; &#125;; stop.onclick = function()&#123; cancelAnimationFrame(timer); &#125;;&#125;)(); 动画框架的使用所用框架戳这里 首先我们来看看我们能操作哪些属性 12345678910111213141516171819202122232425262728&quot;width&quot;,&quot;height&quot;,&quot;left&quot;,&quot;top&quot;,&quot;right&quot;,&quot;bottom&quot;,&quot;marginBottom&quot;,&quot;marginleft&quot;,&quot;marginRight&quot;,&quot;marginTop&quot;,&quot;paddingLeft&quot;,&quot;paddingRight&quot;,&quot;paddingTop&quot;,&quot;paddingBottom&quot;&quot;opacity&quot;&quot;rotate&quot;,&quot;rotateX&quot;,&quot;rotateY&quot;,&quot;rotateZ&quot;,&quot;translateX&quot;,&quot;translateY&quot;,&quot;translateZ&quot;,&quot;scale&quot;,&quot;scaleX&quot;,&quot;scaleY&quot;,&quot;skewX&quot;,&quot;skewY&quot; 注意这里都是数值样式，如果是非数值样式，比如颜色，可以获取但不能用作动画操作 那我们就先来看看咋获取吧 123css(box,"height");//获取css(box,"height",200);//修改css(box,"background","blue");//修改 但是有一个特别重要的东西就是有关transform的值，也就是上面给出的可操作的部分的下半部分，是只能先设置再获取的 12css(box,"scale",.5);css(box,"scale"); 如果没有上面代码块的第一行，那么久无法获取 下面进入正题，看看框架的具体使用参数 123456789101112131415161718192021222324// transform 相关的样式，在动画前，一定记得先设置初始值 css(box,"rotate",0); mTween(&#123; el: box, attr: &#123;//改变后的样式值 width: 300, height: 300, rotate: 360 &#125;, //duration: 100 //默认值 400 duration: &#123; multiple: .5, /* 根据要动画的样式中，最大的差值计算一个时间 multiple 差值的倍数 */ min: 400, //完成动画的最少时间 毫秒 max: 1000 //完成动画的最大时间 毫秒 &#125;, fx : "backOut" // 动画形式: 参考 Tween cb: function()&#123; console.log("动画执行完成"); &#125;, moveing: function()&#123;//注意moveing的写法 console.log("动画执行过程中"); &#125;//停止动画 mTween.stop(box); &#125;);]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[定时器]]></title>
    <url>%2F2020%2F01%2F14%2F%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[设置定时器 setTimeout(function,时间)：多长时间后干嘛 setInterval(function,时间)：每隔多长时间干嘛 这两个的返回值是定时器编号 清空定时器： clearTimeout(定时器编号) clearInterval(定时器编号) 定时器管理： 如果多个定时器同时进行，会乱套，所有有下面两种解决方式 在打开新定时器时把旧定时器关掉：clearInterval(timer) 判断定时器是否执行，如果执行先不打开 123456789if(timer)&#123; return;&#125;·····timer=item.setInterval(()=&gt;&#123; ···· timer=0；&#125;，1000) demo1 demo2]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂七杂八]]></title>
    <url>%2F2020%2F01%2F14%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F</url>
    <content type="text"><![CDATA[1.首先给一个例子 ​ 是不是很神奇，咋都是5呢，这大概是因为这个var吧，那我们换成let试试 ​ 哦吼，看样子是局部全局问题呀，解析的时候先解析全局的，那用var的话，var是全局的，已经解析到5了，你手速不可能跟上解析速度吧，那输出就都是5，而用let就完全不用操心了。 ​ 下面的demo里用的都是let，但解决方法是var的 ，那我该怎么解决这个问题，定位到我指定元素呢，用this就ok，在事件函数中，this代表的是触发当前事件的元素。也就是说，在demo中，如果用let,就用nav[i];如果用var,就用this demo) 2.有的时候我们想让一些块元素没有间隙地并排放着，但总是事与愿违，就像下面这样 但是不慌，解决办法还是有的 首先是笨办法，就是把div写一串,还是不留缝隙那种 &lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;div class=&quot;app&quot;&gt;&lt;/div&gt; 还有一个办法就是把父元素的font-size设成0，但是如果子元素对font-size有要求，因为他会继承父元素的0，所以要单独给子元素再设置font-size 采用任一方法，我们来看看效果 吼吼吼，大功告成！(虽然这不是js的事) 3.开关问题： 123456if()&#123;&#125;else&#123;&#125; 这种形式是不是非常常见，但是作为判断条件的有时可能并不能起作用，比方说src这个属性就不能放在括号里，不能作为条件，这个时候就可以用开关了，实际上就是我们自己定义的一个条件，通过这个条件来控制我们自己的条件 123456789let isTrue=true;if(true)&#123; ··· isTrue=false;&#125;else&#123; ··· isTrue=false;&#125; 4.classList的应用 item.classList.add(“class名字”) 添加class item.classList.remove(“class名字”) 删除某一class item.classList.contains(“class名字”) 判断是否含有某class，有则返回true,没有则返回false item.classList.toggle(“class名字”) 切换，若有这个就删掉，没有这个就加上 5.自定义属性 给元素加一个标准中没有定义的属性就是自定义属性，如 item[i].index=i; 6.JSON是字符串，不是对象 7.任何数%n,结果为0~n-1，如n%5，结果为0,1,2,3,4 8.数据类型划分 按typeof划分：number,string,boolean,function,undefined,symbol,object 按ECMAscript划分：简单类型：number,string,boolean,null,undefined,symbol ​ 复杂类型：object ​ 常见对象类型：Array,object,Element,Elements,Function 因此console.log(typeof(null))的结果是object而不是null 9.NaN不等于任何值，也不等于自身]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[获取元素]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[JS有三大功能块：行为交互，数据交互，逻辑处理 获取单个元素 getElementById querySelector 需要注意的是，以下所有获取元素的方法中的document都可替换为parent 获取完元素的用处： 修改css样式 首先回顾一下css引入的三种方法 行间样式： 1&lt;div style="width:100px;height:100px;background-color:red;"&gt;&lt;/div&gt; 非行间样式： &lt;style&gt;&lt;style&gt; &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 无论是哪一种样式，都用一种方式即可修改对应的样式 其中，需要注意两种获取元素的方法的括号里应该写什么，getElementById是写名就行了，不需要 . # queryselector如果匹配到了多个元素，只会采用第0个 ​ 再来看看一些有意思的 ​ 如果我想清空样式怎么做最方便呢(只适用于行间样式) ​ item.style.cssText=” “; ​ 如果只修改某个样式，比方说我原来的样式是宽高各100px，我现在 ​ item.style.cssText=”width:300px” ​ 我得样式就会变成宽300，高0，也就是说会覆盖，这个时候，就可以用js超级好用的字符串拼接了 ​ item.style.cssText+=”width:300px” ​ 这个时候后面的宽覆盖前面的宽，样式就变成宽300，高100 获取表单用户输入的内容 item.value 获取普通元素(非标单的内容) item.innerHtml 注意当要加的是标签时，要用字符串拼接，否则会覆盖掉原来的标签 item.innerHtml+=”&lt;&gt;&lt;&gt;” 获取元素的class item.className 这种情况可以用于脱离内联样式，通过写多个class及if语句来改变样式 获取多个元素(类数组) document.getElementsByClassName(“类名”) document.getElementsByTag(“标签名”) document.querySelectorAll(“css selector”) 上述三种方法获取到的一组元素不能直接操作，都只能通过数组下标访问，即使只有一个能匹配也得用数组下标，因此一般也都用循环 还有！切记是Elements!不是Element! demo链接]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I/O软件层次结构]]></title>
    <url>%2F2019%2F11%2F28%2FI-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[注意每一层都是用下一层提供的服务，向上层提供服务 用户层软件 中断处理程序 汇总： 其中只有设备驱动程序和中断处理程序需要和硬件打交道 I/O核心子系统 其中假脱机技术实际上不属于核心子系统，但我们就拿在一起讲 因为要实现的功能与硬件无关，所以就无须设备驱动程序和中断处理程序 I/O调度 就跟磁盘调度差不多，找个合适的调度算法就行 设备保护 假脱机技术 脱机：脱离主机的控制进行输入输出 假脱机技术：用软件方式模拟脱机技术 其中输入井就对应着上面第一个磁带的作用，输出井是第二个；输入进程相当于上图中第一个外围控制机，输出进程相当于第二个； 共享打印机原理分析 设备的分配与回收]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I/O控制方式]]></title>
    <url>%2F2019%2F11%2F28%2FI-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[程序直接控制方式 中断驱动方式有了这种方式，CPU和I/O才能并行 DMA方式 如上图所示，我们可以看出，I/O与内存之间就不需要CPU这个媒介了 通道控制方式 总结：]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I/O控制器]]></title>
    <url>%2F2019%2F11%2F27%2FI-O%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[I/O控制器的组成 内存映像I/O vs 寄存器独立编址]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I/O设备的概念和分类]]></title>
    <url>%2F2019%2F11%2F27%2FI-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[什么是I/O设备 I/O设备的分类]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[磁盘的管理]]></title>
    <url>%2F2019%2F11%2F27%2F%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘初始化 引导块计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序(自举程序)完成的 但把自举程序放在了ROM中，如果有需要去更新初始化程序的时候，因为放在ROM中不能被修改了怎么办？–可以用下图的解决方式，也就引入了引导块的概念 坏块坏块就是无法正常使用的扇区，这属于硬件故障，操作系统是无法修复的，只能把他们标记出来，以免以后错误地引用他们]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[减少延迟时间的方法]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[交替编号为解决上述读取连续扇区，需要的延迟时间过长的问题，就有了交替编号这种解决方案 如上图所示，让连续扇区在物理上有间隔，像这样交替编号后，假设我刚读完扇区2想接着读扇区3，因为中间有扇区6，就不用像以前那样因为要花一小段时间处理去转一圈回来才能读取扇区3，这样就大大减少了延迟时间 错位命名当相邻盘面相同位置对应扇区编号相同时，如0-0,1-1,2-2···· 这个时候就引入了错位命名，即让相邻的两个盘面位置对应的扇区号不一样，如下图就是0-7····]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[磁盘调度算法]]></title>
    <url>%2F2019%2F11%2F27%2F%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一次磁盘读/写操作需要的时间 其中延迟时间公式中的1/2意思是平均要1/2个磁道 延迟时间和运输时间都与转速成线性相关，但转速是硬件的固有属性，因此操作系统无法优化延迟时间和运输时间 但寻道时间是操作系统可以优化的，具体看如下算法 先来先服务算法(FCFS) 最短寻找时间优先(SSTF) 扫描算法 LOOK算法 C-SCAN算法 C-LOOK算法]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[磁盘的结构]]></title>
    <url>%2F2019%2F11%2F27%2F%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[磁盘，磁道，扇区 如何在磁盘中读/写数据磁头臂带动磁头，方向只有红线上的两个方向磁盘在马达下转动 事实上磁盘由很多个盘面组成 磁盘的物理地址注意”一个盘片可能有两个盘面”的意思是有正反面 注意磁盘的物理地址必须是(柱面号，盘面号，扇区号)，不能是(盘面号，柱面号，扇区号)，这样做当访问连续扇区时可以减少磁头的移动 磁盘的分类按磁头划分：注意第二张图每个盘面都有那些磁头，只是不方便画所以没有 按盘片是否可更换]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件系统的层次结构]]></title>
    <url>%2F2019%2F11%2F27%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件保护]]></title>
    <url>%2F2019%2F11%2F24%2F%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[口令保护 加密保护 访问控制]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件的基本操作]]></title>
    <url>%2F2019%2F11%2F23%2F%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建文件 删除文件 打开文件注意打开文件时并不会将文件数据读入内存，只是将目录项中的信息复制到内存的打开文件夹里，索引号又称文件描述符 打开文件夹有两种，一种是系统的，他有一个特殊的指标就是打开计数器，记录有几个进程打开了某个文件；另一种是进程的，他也有特殊的指标，比如说读写指针-&gt;记录读或写到文件哪个位置了，访问权限，索引号； 每个进程都有自己的打开文件夹，系统只有一个打开文件夹 关闭文件 读文件 写文件 读写文件操作只需提供索引号即可，不需要文件名]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件存储空间管理]]></title>
    <url>%2F2019%2F11%2F21%2F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前的文件物理结构实际上是对磁盘非空闲块的管理，下面来看看操作系统对磁盘空闲块的管理 下面将涉及以下内容 存储空间的划分与初始化现在我们肯定要对电脑做的一件事就是给我们的电脑分盘(C,D,E,F····盘) 空闲表法 如何分配磁盘块:与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。 如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况①回收区的前后都没有相邻空闲区;②回收区的前后都是空闲区;③回收区前面是空闲区;④回收区后面是空闲区。总之，回收时需要注意表项的合并问题。 空闲链表法 空闲盘块链：以盘块为单位组成一条空闲链 操作系统会保存链头，链尾指针(上图中链头是20，链尾是0) 如何分配：当某文件申请k个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针 如何回收：回收的盘块一次挂到链尾，并修改空闲链的链尾指针 适用于离散分配的文件结构，而且当为一个文件分配多个磁盘块时需要多次操作，需要一个个摘 空闲盘区链：以盘区为单位组成一条空闲链(比如下面0一组，6,7一组，12,13,14一组···每一组就是一个区)，每个空闲盘区的第一块惠济路盘区的长度，下一盘区的指针 解释一下最后那句，比方说现在要回收17,18这两块，因为前后没有相邻的空闲盘区，就把他俩作为一个空闲盘区挂在链尾 既适用于离散分配又适用于连续分配，为一个文件分配多个盘块时效率更高 位示图法 上图中字长就是16，n就是16，比方{1,10},那盘块号就是1*16+10=26 比方说盘块号是17，那字号就是17/16=1,位号，就是17%16=1 既适用于连续分配又适用于离散分配 成组链接法因为空闲表和空闲链表可能过大，因此不适用于大型文件系统，unix系统采用了成组链接发对磁盘空闲块进行管理 文件目录区专门用一个磁盘块作为超级块，当系统启动时将超级块读入内存，并保证内存与外存中的超级块数据一致 如下图就是成组链接的一个实现，超级块要保存下一组空闲块号，比如图中100，还有下一组的空闲块号。同样的下一组也可像超级块这样保存下一组的，但是注意，最后一组比前面的是要少的，因为有上一组有1个-1来表示终止了；注意图中虽然是按顺序来的，什么300-201呀啥的，只不过是为了表明数量关系，实际上不需要时连续的 如何分配：比方说需要一个空闲块，拿去与超级块存的那个100比，发现可以，是小于100的，那就将第一分组的一个空闲块分给他，并修改超级块中数据，但是注意像，300这块不能乱动，因为会牵连到后面的组 如果需要100块，发现100=100，是足够的，可以把第一个分组的100块分给他，但是因为300号块内存储了下一组的数据，因此需要将300号内的数据复制到超级块中 怎么回收空闲块：比方说每个分组最多有100块 如果此时第一个分组没满，只有99块，那就把这个空闲块加到第一组 如果此时第一个分组已经满了，就把超级快的内容复制到新的空闲块中，并让他作为第一个分组]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件的物理结构]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[文件块： 磁盘块： 因为要研究文件的物理结构，实际上就是研究文件的分配方式，文件要存在磁盘上，所以必然要以磁盘为载体来研究 文件的物理结构(文件分配方式)连续分配 连续分配要求每个文件在磁盘上占有一组连续的块，如下图所示 文件块是连在一起的，如果实行连续分配那在磁盘中也得是连续的，用户是按逻辑地址来访问文件的，那操作系统怎么实现从逻辑地址到物理地址的转换呢。实际上这就是(逻辑地址，块内地址)-&gt;(物理地址，块内地址)的转换，块内地址是不变的 这就需要文件目录中的记录要有在磁盘中的起始块号和长度 然后操作系统在找到文件对应的FCB时得到起始块号和长度再根据用户给的逻辑块号，就可以得到物理块号=起始块号+逻辑块号 因此，连续分配支持顺序访问和直接访问 当然，要检查逻辑块号，不能大于长度，否则不合法 同时，磁盘在读取某个磁盘块时需要移动磁头，要访问的磁盘块相隔越远，移动磁头所需时间越长；因此当连续分配时，磁盘移动距离当然是最小的，也就是说，连续分配的文件在顺序读/写时速度最快 下面来看看连续分配的缺点 1.不利于扩展 如图A占了三个连续的块，橙色的被其他文件占了，绿色空闲，如果我想让A再占一个，他需要连续的四块，这时发现被占了，那就只能把A占的四个格都迁移到绿色那里，这样会有很大的消耗 2.存储空间利用率低，会产生难以利用的磁盘碎片，虽然可以使用紧凑来处理碎片，但会耗费很大的时间代价 如图，橙色是被占用的，绿色是未被占用的，如果来了一个文件需要连续的3个块，显然是无法满足要求的，也就是说只要有大于1的我现在都满足不了，除非用紧凑技术，但这就会增加时间开销 链接分配 链接分配可以为文件分配离散的磁盘块，分为隐式链接和显式链接两种 隐式链接 那怎么实现逻辑块号到物理块号的转变呢？用户给出逻辑块号i,操作系统找到该文件的FCB，读取到起始块号和终止块号，然后就找到逻辑块号为0的块，并把它读进内存，由此根据指针就知道逻辑块1在哪了，然后把逻辑块1读入内存，如此一步一步向下找，就能找到逻辑块i了，需要i+1次磁盘I/O 如此看来，这个很像链表，他也是只支持顺序访问，不支持随机访问，查找效率低，且指向下一盘块的指针需要耗费少量的存储空间 那我们再来看看他是否能解决拓展问题呢；因为我们要再加几个块，因为隐式链接可以离散着存放，那只要有空闲块就ok，再把结束块号改一下就可 因此，采用隐式链接的链接分配方式，很方便文件扩展，另外，所有空闲的磁盘块都可以被利用，不会有碎片问题，外存利用率高 显式链接 把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT) 比如文件aaa依次存放在磁盘块2-&gt;5-&gt;0-&gt;1，这样目录中就只需要记录起始块号，结尾的下一块可以用特殊字符来表示，比如-1 因为每个块只能放一个文件块，所以不存在一对多的情况，那一个磁盘仅设置一张FAT，开机时将FAT读入内存，并常驻内存，FAT各表项在物理上连续存储，且每一个表项长度相同，因此物理块号字段可以是隐含的 那怎么实现从逻辑内存到物理内存的转换呢？比方说用户给了逻辑块号i，操作系统找到该文件的FCB，读取到起始块号，然后再到FAT中查表，一个个往下找就能找到了，因为只是查了表，并没有依次访问之前的0~i号逻辑块，且这个表一直在内存某个位置，就可以说是实现了随机访问，因为块号转换不需要访问磁盘，所以比隐式链接要快得多 同时，显式链接方式也不会产生外部碎片，也很方便对文件进行拓展 那显式链接唯一的缺点就是FAT要占一定的存储空间 一般来说，链接方式默认为隐式链接 索引分配 索引分配允许文件离散地分配在磁盘里，系统会为每个文件建立一个索引表(注意跟FAT不一样，FAT是整个系统就这一个)，索引表中记录文件各个逻辑块对应的物理块，索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫做数据块 如图，嘉禾文件aaa的索引块在7，数据块依次是2-&gt;5-&gt;13-&gt;9 同样的，表项长度时一样的，逻辑块号也是可以省略的 那怎么实现逻辑块号到物理块号的转换？同样的也是查表，把某文件的索引表读到内存就可以找到了，因此也是支持随机访问，文件拓展也很容易，只要给文件分配一个空闲块，索引表加一项即可；但索引表需占用一定的空间 但如果一个磁盘块装不下一张索引表的时候该怎么办呢？有三种解决方式：链接方案，多层索引，混合索引 链接方案 比方说，一个索引块最多能有256项，而某个文件需要大于260个块，那我就需要两个索引块，若采用链接方式只需要在第一个索引块用一点点空间保存指向下一个索引块的指针即可，那目录中只需要保存第一个索引块即可；比方说我要找259号逻辑块，那我必须把第一块全都读一遍，才能找到下一块才能找到259号；那如果我需要256个索引块，我要是想访问最后一个逻辑块，那我就要在磁盘上找到前面255个索引块，也就是说要进行255次磁盘操作，这样很低效 为此，就提出了多级索引方案 多级索引 有点类似于多级页表 注意上面涉及到的计算很重要 总结：采用k级索引结构，且顶级索引表未调入内存，则访问一个数据块只需要k+1次读磁盘操作 如果说我想要读取的文件很小他只有1KB却还是要读取顶级索引表再读二级索引表，还是要三次读磁盘操作，有点小题大做，就提出了混合索引的方案 混合索引 注意这里块数的计算 下面我们来看看想找到某一块需要几次读磁盘操作(顶级索引表未被调入内存) 0~7：两次 8~263：三次 264~65799：四次 由此看来一些小文件存在像0~7这样的块中，就只需要两次读磁盘操作，而一般计算机中都是小文件多，因此这样比较有效率]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件目录]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[文件控制块 FCB的有限集合称为文件目录，一个FCB就是一个文件目录项 如上图所示，2015-08啊啥的是目录文件，就是文件夹，微信不拉不拉的就是个文件，所有的这些个FCB组成文件目录，每条FCB包含了文件的基本信息(文件名，物理地址，逻辑结构，物理结构等)，存取控制信息(是否可读/可写，禁止访问的用户名单等)，使用信息(文件建立，修改时间) 最重要的是文件名和物理地址，因为FCB就是要实现可以让用户通过文件名与文件间的映射实现“按名存取” 目录结构单级目录文件 早期计算机系统不支持多级目录，整个系统只有一张目录表，每个文件占一个目录项 因此在单级目录下肯定是不允许有重名文件的，不然你想要是按文件名查找，有重名的操作系统哪知道你要找的到底是哪个啊 那在创建新文件时，要先检查文件目录里有没有重名的，没有重名的才能建立文件再将对应的目录项插入到目录表里 综上所述，如果有多个用户同时使用计算机，很有可能产生同名文件，因此不适用于多用户操作系统，为了解决这个问题，提出了两级目录文件的概念 两级目录文件 早期的多用户操作系统中，采用两级目录结构，分为主文件目录和用户目录 注意这里是根据不同用户划分的，user1想访问user2的FCB就不行，但是这样的话不同用户的文件可以同名；然而这样的两级目录还是有缺点，那就是用户不能将自己的文件进行分类，为了解决这个问题就引出了多级目录的概念 多级目录文件(树形目录结构) 上面说到自拍.jpg，那操作系统是怎么找到他的呢？ 操作系统是根据绝对地址一层一层找到下一级目录的，首先从外存读入根目录的目录表，找到照片目录存放位置，从外存读出相应目录表，在找到2015-08目录的存放位置，再从外存取出对应目录表，最后找到自拍.jpg的存放位置，全程需要3次读磁盘I/O操作 但很多时候，用户会连续访问同一目录下多个文件，比如连续查看2015-08的两个文件，如果都按绝对地址从根目录开始找太低效了，这个时候就可以设置一个“当前目录” 虽说多级目录结构可以很方便的对文件分类，层次结构清晰，也能有效对文件管理并保护，但不便于实现文件的共享，因此就提出了无环图目录结构 无环图目录结构 索引节点(FCB的改进) 注意索引节点不是在目录表里的，他在外存，目录项只有文件名和索引节点指针]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件的逻辑结构]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[无结构文件 有结构文件 根据各条记录长度是否相等，可将记录划分为定长记录及可变长记录 比如专业大家都差不多，就是定长，但是换成特长，可能有的人很多，有的人没有，就是可变长 顺序文件 因此组合一下，顺序文件就有以下分类 链式存储，就像链表他是不能想要第几个节点就能马上得到的，必须从第一个开始遍历 顺序存储中可变长记录的话，没有特定的规律，不能通过简单地计算直接得到物理位置，因而也只能从第一个开始遍历 定长记录的话就类似于数组了，当然可以随机存取，特别地，如果使用串结构，则各记录不是按照关键字顺序排列的，就无法迅速查找到某关键字对应的记录；而如果是顺序结构，即根据关键字按顺序排列，就可以用折半查找(二分法)，就是从中间的那条记录与要查找的记录比较，再就根据升序或者降序向前或向后查找。 一般情况下顺序文件都是指顺序存储 但顺序文件的缺点是删除或增加一个记录很困难，但如果是串结构就相对简单了，因为他不是按关键字顺序的所以添加直接加在后面就行，删直接删就行不用考虑顺序问题 虽然定长记录查找起来更快一些，但现实使用更多的是可变长的，那该怎么办呢？ 这就引出了索引文件(适用于对信息处理的及时性要求很高的场合) 索引表得连续的放在内存里，逻辑文件(不定长记录文件)可离散着放，这样的话索引表就相当与定长记录的顺序文件，就可以迅速找到第i个的地址，同时如果是按关键字排列，可以用折半查找的方法加快访问速度； 索引号可以替换成关键字，比如学号，姓名… 索引表的每个表项长度相同，联想前面的页表项 如果索引表的表项占得地方太大了，比如说文件的记录平均占8B，但每个索引表项却占32个字节，那索引表占的空间就比文件本身4倍，那这样内存的利用率就会大大降低 为了解决这个问题就引出了索引顺序文件 如上图所示，将文件分组，每一组对应索引顺序文件的一个索引表项，这样的话跟一对一相比，当然节省了很多空间，还有索引顺序文件的项不是按关键字排列，这样增加删除就更快了 那现在索引表确实是瘦了不少，那他是不是可以解决查找速度慢的问题呢 假如一个顺序文件有10000个记录，则按关键字检索，只能从头开始(不是定长)，则至少5000次 但如果用索引顺序表，假设将这10000条记录分成100组，则每组有100条记录，当要查找是肯定要先去索引顺序表找在哪个组，从头开始找，平均要50次，找到在哪一组之后，就要去对应的组找到具体的位置，一组有100条，那平均就要找50次；查找速度就是50+50=100次 由此看来，的确是减少了不少 但如果文件有10的6次方个记录，可分为1000组，每组1000个记录，这样平均要500+500=1000次才能找到，还是很大，那该怎么办呢 可以建立多级索引顺序表 就用上面的10的6次方的例子，这样就是拿出100组，每一项对应一组(100项)，再对应一组(100项) 这样访问次数就是50+50+50=150，相比于1000少了很多]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识文件管理]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件：一组有意义的信息/数据集合 文件属性 其中在外存中的地址是因为文件相关信息一般都存在外存里，所以操作系统需要知道他在哪 保护信息实际上就是权限，一个电脑可以有多个用户账号，可分别对用户账号设置权限，比如只可读不可写，在右键-文件属性-安全里 文件内的数据怎么被组织起来 其中无结构文件又叫流式文件 有结构文件又叫记录式文件 文件内之间怎样组织起来 操作系统应向上提供哪些功能 文件应如何存放在外存 其他由操作系统实现的文件管理功能文件共享：使多个用户可以共享使用一个用户 文件保护：如何保证不同的用户对文件有不同的操作权限]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2019%2F11%2F12%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[什么是死锁在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象 发生死锁后若无外力干涉，这些进程都将无法向前推进 死锁，饥饿，死循环区别饥饿：由于长时间得不到想要的资源，导致各进程都堵塞 死循环：某进程执行过程中一直跳不出某个循环的现象，有的死循环是逻辑错误，有的是程序员故意的，比如前面生产者消费者问题中的死循环，就是为了阻止其他进程进来 死锁产生的必要条件 其中最后一段的意思就是，如果有同类可替代的资源，就算循环等待也可能不发生死锁，就像图中的老人也有一个筷子，他可以给哲学家3号用 什么时候会发生死锁 总之，对不可剥夺的资源的不合理分配，可能导致死锁 死锁的处理策略 静态策略：预防死锁 思想：破坏产生死锁的一个或几个必要条件 破坏互斥条件 把只能互斥访问的资源改为允许共享使用，就不会进入死锁状态 比如SPOOLing技术，就是把独占设备在逻辑上改造成共享设备 如图中，实际上只是把进程们传到输出进程，有一种逻辑上共享的感觉，最终打印机还是一个一个打印 缺点：并不是所有资源都可以改造成可共享使用的资源，且为了系统安全，很多地方还需要保护这种互斥性，因此，很多时候无法破坏互斥条件 破坏不可剥夺条件 破坏请求和保持条件 上图的意思是，如果源源不断的有A类进程和B类进程，那当一个A进程释放后就会马上把资源1分给下一个A进程，B进程同理，只有A,B都不用，C才能用，因此可能造成C进程饥饿 破坏循环等待条件 缺点2解释：因为只能先占小的再占大的，所以当我想先用7号，再用5号，就只能先占5号，让他空闲一段时间，7号才能继续，这样就会造成资源浪费 缺点3解释：比如有的机器要先5后7，有的机器要先7后5，你就要改，就很麻烦 动态策略：避免死锁 安全序列：指系统如果按这种序列分配资源，则每个自愿都能顺利完成，只要能找出一个安全序列，系统就是安全状态，当然，安全序列可能不止一个 若分配资源后，系统找不到一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利进行下去，但如果有进程归还了一些资源，系统也有可能重新回到安全状态，不过在分配资源之前我们要考虑到最坏的情况 如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，可能发生死锁(处于不安全状态不一定发生了死锁，发生死锁一定是在不安全状态) 因此在分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，这也就是银行家算法的核心 银行家算法 注意这里的”把该进程加入安全序列，并把该进程持有的资源全部回收”，比如说我还有可用资源(6,3,2)，那我把他分配给进程P0，进程P0满足他的最大需求就会把资源都释放出来，我的可用资源就是(6,3,2)+(2,2,1)=(8,5,3) 死锁的检测和解除 若系统中不采取预防死锁的措施，也不采取避免死锁的措施，那系统就很有可能出现死锁，在这种情况下系统应提供以下两个算法 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来 死锁的检测 ① 用某种数据结构来保存资源的请求和分配信息 ②提供一种算法（依次消除与不阻塞进程相连的边，直到无边可消），利用上述信息来检测系统是否已进入死锁状态 进程的解除]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[管程]]></title>
    <url>%2F2019%2F11%2F11%2F%E7%AE%A1%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为什么引入管程在之前用信号量实现进程同步，互斥时，我们知道很容易因为异步性导致出现死锁，编程困难，易出错，能不能设计一种机制让程序员不需要再关注复杂的PV操作，让写代码更轻松呢，这个时候就在Pascal语言里首次引入了”管程”的成分，一种高级同步机制 管程的定义和基本特征管程是一种特殊的软件模块，有下面这些部分组成 1.局部于管程的共享数据结构说明 2.对该数据结构进行操作的一组过程(相当于函数) 3.对局部于管程的共享数据设置初始值的语句 4.管程有一个名字 管程的基本特征： 1.局部于管程的数据只能被局限于管程的过程所访问 2.一个进程只有通过管程内的过程才能进入管程访问共享数据 3.每次允许一个进程子管程内执行某个内部过程 综上，我认为可以把管程理解为面向对象中的封装，比如说类 用管程解决生产者消费者问题 比如]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[页面置换策略]]></title>
    <url>%2F2019%2F11%2F11%2F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[驻留集指请求分页存储管理中给进程分配的物理块的集合 在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的大小 若驻留集太大，会导致多道程序并发度下降，资源利用率降低，所以应该选择一个合适的驻留集大小(极端一点，驻留集等于进程大小，进程能一次性放进去) 若驻留集太小，又会导致缺页频繁，系统要花大量时间来处理缺页，实际用于进程推进的时间很少(极端点，驻留集是1，进程是100) 页面分配，置换策略有了上面的问题就引出了分配，置换策略 固定分配：操作系统为每个进程分一组固定数目的物理块，在进程运行期间不再改变，即驻留集大小不变 可变分配：先为每个进程分一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即驻留集大小可变 局部置换：发生缺页时只能选进程自己的物理块进行置换 全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可将别的进程持有的物理块置换到外存，再分配给缺页进程 两两组合就有了下面的结果 其中未锁定是一些不要紧的进程，因为操作系统会将一些程序设成锁定，不允许别人动 何时调入页面 从何处调入页面 抖动(颠簸)现象刚刚换出的页面又要马上换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动或颠簸，产生抖动的主要原因是进程频繁访问页面数目高于可用物理块数(分配给进程的物理块不够) 为了解决物理块到底应该分多少的问题，有了工作集的概念 工作集指在某段时间间隔，进程实际访问页面的集合]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两级页表]]></title>
    <url>%2F2019%2F11%2F06%2F%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[分页存储中的页表是单级页表，它有两个很严重的问题 1.页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框 2.没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面第二个问题需要用到虚拟技术，以后再说 为了解决第一个问题也就有了两级页表，就是在页表的基础上为离散的页表再建个页表，称为页目录表 如上图所示就是把单级页表给离散开了，分成了1024个部分，至于为什么分为1024个部分，我们来慢慢推导，每个页面可以放2的10次方个页表项，那我总共有2的20次方个有页表项，那么就应该被分成1024个部分 那分出来的小页表的起始地址怎么求呢，这个时候就是我们的页目录表闪亮登场的时候了 页目录表第一列代表是小页表的页表号，第二列代表小页表在内存中的内存块号，比如根据一级页表(页目录表),0,3我可以知道0#页表存放在内存块号为3的位置，然后从3的位置拿出0#页表，就跟单级页表使用方法一样了 如何转换为物理地址 下面提醒几个需要注意的点 采用两级页表(没有快表)，需要三次访问内存，第一次访存是访问内存中的页目录表，第二次是访问内存中的二级页表，第三次是访问内存目标单元，根据推导，在没有快表的情况下，k级页表就要访存k+1次]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[变址机构]]></title>
    <url>%2F2019%2F11%2F06%2F%E5%8F%98%E5%9D%80%E6%9C%BA%E6%9E%84%2F</url>
    <content type="text"><![CDATA[基本变址机构基本变址机构(两次访存)解决分页存储地址转换问题的，通常会在系统中放置一个页表寄存器来存放页表在内存中的起始地址F和页表长度M,进程未执行时，页表的始址和页表长度会放在进程控制快中，当进程调度时，操作系统内核会把他们放在页表寄存器里，具体流程看下图 在你仔细看完这个流程图后我想你大概会有这样的几个问题， 那个小于等于号为什么要有等于–因为页表长度最小是1，而页号最小是0，因此当页号是1，实际上他的页表长度已经是2了，因此越界； 为什么需要将页号和页表始址连接起来–因为也表示放在内存里的，我想读页表我得先找到他。 bw是什么–你可以去看看在分页存储那里讲的操作系统怎么简单的获得页号和页内偏移量 下面来深究一下页表项长度问题 出现上图问题的原因实际上是因为，我本来要20位就够了，但为了凑字节，我只能再加四位，如果我用3个字节表示页表号，那我一个页框可以存1365个页表项，还剩1个字节的碎片啥也装不了，那我1365号(第1366个)就只能在下一个页框里存了，那我就不能直接用之前的结论，我还得再加1，为了解决这个问题，我可以让页表项占更多的字节，这样的话就不会出现碎片 具有快表的地址变换机构具有快表的地址变换机构实际上是基本变址机构的一个完善 首先先来看看两个概念 时间局限性：如果执行了程序中的某条命令，那么不久后这条命令很有可能被再次执行；如果某个数据被访问过那么他很有可能在不久后被再次访问(比如程序中有大量循环) 空间局限性：一旦程序访问了某个存储单元，在不久后，它附近的存储单元也很有可能被再次访问(比如数据是连续存放的) 基本的地址变址机构需要每次都查页表，很有可能好几次连着查的都是同一个页表项 增加一个快表就能解决这个问题 快表(TLB),又称联想寄存器，是一种访问速度比内存快很多的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换过程，与此对应，内存中的页表又叫做慢表 如图所示(0,0)先进，前后两个0分别表示页号，偏移量 刚开始的时候快表为空，所以会在页表中查找，与此同时会存在快表中如上图所示 等到执行(0,4)时，因为还是在0号所以就不必再查找，直接在快表里拿出来用就行了，剩下的以此类推 若快表满了，则必须按照一定的算法对旧的页表项进行替换(页面置换) 这样我们就可以很清楚的看出来，如果快表命中，那变址速度就会显著提高，一般来说快表命中率在90%以上 我们来算算看 若访问快表时间为1微秒，访问内存为100微秒，快表命中率为90%，那么访问一个逻辑地址的平均耗时是多少 a. 快表慢表不同时访问 (1+100)0.9+(1+100+100)0.1=111微秒 第一个一百为对内存访问，第二个也是，第三个是对慢表访问(快表命中，一次访存；快表未命中，两次访存) b. 快表慢表同时 (1+100)0.9+(100+100)0.1=110.9微秒 同时时快表那1微秒就省了 c. 若未采用快表 100+100=200微秒]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态分区分配算法]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足要求时，应选择哪个分区 首次适应算法(First Fit)算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区 实现方法：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链或空闲分区表(链或表都按地址从小到大排列)，找到大小能满足要求的第一个空闲分区 最佳适应算法(Best Fit)算法思想：因为动态分区分配是分配一块连续的内存，所以为了保证大一点的进程进来时能有足够的内存用，所以会尽量的留大块的空闲区，优先使用小的空闲区 实现方法：将空闲分区表或链按容量从小到大排序，当分配内存时，顺序查找表或者链，找到大小满足要求的第一个空闲分区，然后有必要的话重新排序表或者链(导致算法开销大) 缺点：若果我们每次都选最小的，那可能每次都要有一块很小(比如2MB)的内存难以被利用，这样就形成了很多外部碎片 最坏适应算法(Worst Fit)算法思想：为了解决最佳适应算法会出现很多超级小的空闲分区，可以在每次分配时优先使用最大的空闲分区，这样剩下的就不会很小，方便以后使用 实现方法：将空闲分区表或链按容量从大到小排序，当分配内存时，顺序查找表或者链，找到大小满足要求的第一个空闲分区，然后有必要的话重新排序表或者链(导致算法开销大) 缺点：事实上我们每次找的第一个合适的就是最大的，因为他在表或链的最前面，肯定先匹配到他，这样的话每次都分割他，把它分成一块块小的区域，这样如果有个大一些的进程再来，那就谁也满足不了了 邻近适应算法(Next Fit)算法思想：首次适应算法每次都从低地址开始查找，且低地址处被分成了很多很小的分区，这样在每次查找时都要经过这些小分区，但那些剩下来的很小的碎片可能都满足不了我却要在经过一遍，这就增加了查找的开销，因此就有了邻近适应算法，即从上次查找后的位置开始查找 实现方法：空闲分区以地址递增的次序排列(可排成一个循环链表)，每次分配内存时从上次查找后的位置开始顺序查找空闲分区链或空闲分区表(链或表都按地址从小到大排列)，找到大小能满足要求的第一个空闲分区，不需要重新排序表或者链 其实我们可以看到邻近适应算法就是首次优先算法的一个改编，他不一定就是比首次适应算法好，下面我们来分析一下 首次适应算法虽然每次都要从头开始顺序查找，蛋挞让前面的小内存更可能被用到，而后面的大内存被尽可能的保留下来(最佳适应算法的优点) 邻近适应算法每次都从上次查找完的位置开始往下查找，那前面的小内存可能满足，却只能接着往下走去分割大内存，如此一直进行下去，后面的大内存会被分成很多个小内存，这样等到有大进程来了却没有能满足的了(最坏适应算法的缺点) 综合来看，首次适应算法是最好的]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存空间的分配与回收]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[连续分配管理方式连续分配：指为用户进程分配的必须是一个连续的内存空间 单一连续分配：内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间优点：实现简单，无外部碎片(内存中某些空闲分区由于太小而难以利用)；可采用覆盖技术扩充内存，不一定需要内存保护缺点：只能用于单用户，单任务的操作系统中，有内部碎片(分配给某进程的内存区域中，如果有些部分没有用上，这就是内部碎片)，存储器利用率极低固定分区分配： 为了能在内存中装入多道程序，又让这些程序互不干扰，会将整个用户空间划分为若干个固定大小的分区，每个分区内只放一道作业 有两种固定分区的划分方法，一种是分区大小相等，即在用户区分出若干个大小一样的分区，这样必然会导致不灵活，有的小作业却独占那么大的内存，有的大作业因为内存不够而进不来，但这种方法适用于控制多个相同对象的场合 另一种是分区大小不等，这样当然是增加了灵活性，可以满足不同大小的进程要求 操作系统会建立一个数据结构——分区说明表，来实现各个分区的分配与回收。他会有一个是状态，但被占用了会修改状态为已分配 那固定分区分配的优点：实现简单，无外部碎片 缺点：当用户程序太大，可能所有分区都不能满足要求，此时不得不采用覆盖技术空充，但会境地性能；会产生内部碎片，内存利用率低 动态分区分配： 动态分区分配不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并是分区大小正好适合进程的需要。有外部碎片，无内部碎片 系统会用空闲分区表或者空闲分区链这两种数据结构来记录内存的使用情况 当有很多空闲分区都能 满足时，会按照动态区分配算法来分配，具体以后再说 回收：(合并！！！)若某分区只被占了一部分，就在相应的表或者链改数据，若彻底被占了就直接在相应的表或者链去掉一个，若是回收内存，就要和他相邻的空闲内存分区合并，并把相邻的分区在相应的表或者链改数据外部碎片：提到了很多次外部碎片这个问题，那怎么解决这个问题呢，其实办法是有的，那就是紧凑技术，就是将 内存区挪动，使他腾出一块连续的内存，这也就是为什么我们在装入时最好选择动态重定位方式。虽然紧凑技术可以解决存在外部碎片的问题，但时间代价很大## 非连续分配管理方式非连续分配方式：为用户分配的是一些分散的内存空间基本分页存储管理： 如图所示，我将内存区分成每块为10MB的分区，也就是固定分区，这个时候进程A来了，他是23MB，我的每个区都满足不了，我还得满足他只能被放在一个完整的分区里，那么这个时候我必然要使用覆盖技术，但这很浪费。那么怎么解决这个问题呢，我可不可以把进程A拆成10+10+3呢，然后分别放在三个不同的分区里(不用连续)，答案是可以的，这就是基本分页存储，但是需要注意的是，必须是按照分区大小拆，我不能拆成8+10+5,但是好像这么做我会留下一个7MB的内部碎片啊 那我们如果把分区划分的小一点呢，比如说化成2MB，那就是2*11+1，这样我只会有1MB的内存碎片，试着把分区划的更小，你会发现内存碎片也更小 基本分页存储的思想就是把内存的用户区分成一个个相等小的分区，再按照分区将进程拆分成一个个小部分，小分区越小，产生的内部碎片越少，实际上就是将固定分区分配改造成非连续分配版本。每个分区就是一个页框，每个页框有一个页框号，页框号从0开始，边框号小的在低地址。将进程按页框大小分成若干部分，每部分叫页或页面，页的编号时页号，也是从0开始。 那也就是说页面会被一一放到页框里，但最后一个页面的大小可能会小于页框的大小，因此页框大小不应太大，否则会产生过大的内部碎片。 同时页面不一定要放入连续的页框中，可以间隔地放入页框中 实现方式:与之前连续存储不同的是，我现在把每一块都分散着放了，我的物理地址该怎么获取，因此这个实现就是我怎么能根据逻辑地址转换成物理地址 如图所示，这种方式是之前说过的装入方式的一种，动态重定位，我们把自己想做操作系统，我怎么找到逻辑地址为80对应的物理地址呢？首先我知道1页有50的存储单元，那80就应该在1号页，相对于1号页的偏移地址为30，好了，搞清楚之后我要装入了，这个时候我就要弄清楚1号页的其实物理地址是多少，哦是在450，那我的逻辑地址为80对应的物理地址就应该是450+30=480 因此我要进行如下4步才能将逻辑地址转为物理地址 算出逻辑地址对应的页号(逻辑地址/页面长度)(取整数部分) 该页号在内存中的起始地址 算出逻辑地址在该页面的偏移量(逻辑地址%页面长度) 物理地址=页面地址+页内偏移量 但操作系统一般都会让页号，页内偏移量，页面大小为2的整数幂，这样可以很轻易的就得到物理地址 如上图我们可以看见，如果我用32位表示逻辑地址，页面大小是12位，那后12位(页内偏移量)就是偏移量，前32-12=20位就是页号，则一个页面大小是2的12次方，共有2的20次方个页面 那么我怎么获取相应的页号在内存中对应的起始地址呢？ 光看图可能有点晦涩难懂，假设我知道是在1页，页框大小为50，那看图，在页表里页号为1对应着块号为6，那我的起始地址就是6*50=300 实际上每个页表项的长度是一定的，页号是隐含的，具体理解看下图 也就是说在页表里实际上是只有块号，因为页号直接就顺序排列了，至于上图为啥要算字节，是因为要按字节编址 基本分段存储管理： 分段：是将进程按照逻辑分为若干个段，每个段都有自己的段名(程序员自己命名的)，每段从零开始编址 如下图所示，就是程序员给进程段起段名，每一段地址都是从零开始，回忆分页管理，这里是不等分的，而分页管理是将内存等分很多块，然后进程对应内存没一块的大小来分割自己进入内存 与分页一样，在装入内存时存在映射关系，且在内存里可不连续，虽然程序员命名了进程段，但编译程序会将段名转换成段号，这样才能让操作系统认识 如此看来，与分页相比，采用分段是用户可见的，程序可读性更高，但分页对于用户是不可见的 分段系统的逻辑地址由段号和段内地址(段内偏移量)组成，比如： 段号的位数决定每个进程最多可以分多少个段 比如上面段号有16位，那他就最多能表示2的16次方个，因此进程最多被分为64K个段 段内地址的长度决定了每个段的最大长度是多少 比如上面段内地址有16位，如按字节编址，则每个段最大长度为64KB 段表：与页表差不多，只不过多了段长，因为分段不是等分的，同时，段表中段号也是隐式的，不占地址空间 其中，每个段表项的长度实际上是相同的，如上面说的假设逻辑地址=16位段号+16位段内地址，那么用16位表示段长(不会超过最大段内地址)就足够了，若物理内存是4GB，则可以用32位表示整个物理内存，因此，让每个段表项占16+32=48=6B就行了，因此若段表的起始地址是M，则K号段对应的段表项存放地址为M+K*6(注意这里说的是段表项，是在段表里找段表项，不是进程) 机器指令中的逻辑地址用二进制表示：00000000000000100000000100000000 其中前十六位表示段号，后十六位表示段内地址，那怎么将逻辑地址转为物理地址呢 在段表上处理机之前，段表寄存器会被存放在系统区的PCB中 注意第4步，需要比较段内长度和段长，因为不等分，所以有违规的可能 分页与分段的区别： 分页的用户进程地址是一维的，程序员只需给出一个记忆符即可表示一个地址 分段的用户进程地址是二维的，程序员既要给出段名，也要给出段内地址 分段比分页更容易实现信息的共享和保护，比如下面的消费者进程和生产者进程都想访问1号段，分段就能体现出他的优越性，但是注意只能共享不能修改的代码(纯代码或可重入代码，不属于临界区) 分页分段都是两次访存，当然分段也可引入快表，加快地址变换速度 段页式管理方式： 分页，分段优缺点： 那结合分段分页就诞生了段页式管理 因此段页式管理的逻辑地址结构应该是 段号的位数决定了进程最多能被分成多少段：段号占16位，所以进程最多被分成2的16次方-&gt;64K个段 页号位数决定了每个段最多能分多少个页一：页号有四位，所以每个段最多被分成2的四次方-&gt;16个页面 页内偏移量决定了每个页面大小是多少：页内偏移量占了12位，因此每个页面大小为2的12次方,-&gt;4KB(按字节编址) 同样的用户只能看到分段，分页是由操作系统做的，用户看不见，因此段页式管理的地址空间是二维的 因此一个进程对应一个段表，多个页面 怎么将逻辑地址转换成物理地址 其中第四步，是因为段长度不等，所以要检查，和分段管理要检查段内地址是一个道理 当然也可以用快叫，这样如果命中就只需要一次访存]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存扩充]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85%2F</url>
    <content type="text"><![CDATA[覆盖与交换是内存扩充的两种方法 覆盖技术解决程序大小大于物理内存总和的问题，即将程序分为多个段，常用的段常驻在内存，不常用的段在需要的时候调入内存 内存被分为一个固定区和若干个覆盖区，需常驻内存的段放在固定去，调入后不再调出(除非运行结束)，不常用的段放在覆盖区内，需要时调入内存，不需要时调出内存 如下面的栗子 如图则是按照程序的逻辑将不可能同时被访问的程序段放在一个共享的覆盖区上，在逻辑上看，内存是被扩展了的。但上图程序的逻辑操作系统并不知道，只能由程序员声明覆盖结构 也就是覆盖技术的缺点：对用户不透明，增加了用户编程的负担 覆盖技术只适用于早期的操作系统，已成为历史 交换技术设计思想：内存空间紧张时，系统将内存中某些进程暂时换到外存，把外存中已经具备运行条件的进程换入内存(进程在内存和磁盘中的调度–中级调度)，注意PCB会常驻内存，不被调出 那么就有了下面的几个问题 应该在外存的哪里保存换出来的进程？ 首先要补充一个知识，磁盘存储空间分为对换区和文件区，文件区是存放文件的，主要追求存储空间的利用率，因此对文件空间的管理采用离散分配方式；对换区只占磁盘空间的一小部分，被换出的进程就放在这里，由于对换速度直接影响系统整体速度，所以对换区采用连续分配方式，因而对换区的I/O速度比文件区更快 什么时候进行交换？ 在内存紧张时进行，系统负荷降低就暂停 应该换出哪些进程？ 阻塞进程；优先级低的进程；有时考虑到有可能因为优先级低一进来就被调出，有的系统还会考虑进程在内存中的驻留时间 虚拟存储技术我们知道，传统的存储管理再加上覆盖技术或者交换技术就可以实现内存扩充，提高效率。现在再讲一种扩容方法-虚拟存储技术 下面来看看传统的存储管理的缺点 传统的存储管理(连续分配，非连续分配)，很多时候暂时用不到的数据仍会占用内存，导致内存利用率不高。 (一次性)作业又必须一次性全部装入内存才能运行，这就导致两个问题，一个是作业很大时，不能全部装入内存，导致大作业无法运行，第二个问题是，当有大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业可以运行，导致多道程序并发度降低。 (驻留性)一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束，事实上，在上一个时间段，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源。 但！虚拟存储可以解决上面的所有问题 还记得之前讲过的两个局部性原理吗？一个是时间局部性，就是某条指令或数据可能会被经常多次刚问(比方说循环)，另一个是空间局部性，就是一块数据他周围的数据很可能被接连访问(比方说数据被连续，顺序存储) 那怎么利用这两个局部性来扩充内存呢？ 答案是高速缓冲技术：将近期会频繁访问的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中 下面这幅图就是计算机存储器的层次结构，我们可以看到越往上越快，越贵，越小，就比方说之前提到的快表机制，就是将近期经常访问的页表项副本放到更高速的联想寄存器中，这样我们就可以快速的拿到要用的，将其他不常用的用更小的成本存储起来 这样，基于局部性原理，在程序装入时，可以将程序中很快会用到的布恩装入内存，暂时用不到的部分留在外存，就可以让程序开始执行 在程序执行过程中，当所访问的信息不在内存中时，由操作系统负责将所需信息从外存调到内存，然后继续执行程序 当内存空间不够时，由操作系统负责将内存中暂时用不到的信息换到外存 在操作系统的管理下，用户会觉得有一个比实际内存大得多的内存，这就是虚拟内存(这就是操作系统虚拟性的体现，实际的物理内存没有变，只是在逻辑上进行了扩充) 需要注意的是 虚拟内存的最大容量是计算机的地址结构(CPU寻址范围)确定的 虚拟内存的实际容量是min(内存和外存之和，CPU寻址范围) 虚拟内存的三大特征 多次性：无需在作业运行时将作业一次性全部装入内存，而是允许分为多次调入内存 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入，换出 虚拟性：从逻辑上扩充了内存的容量，远大于实际的容量 那怎么实现虚拟内存技术呢？ 因为我们需要允许一个作业多次调入内存，就肯定不能采用连续分配方式，会不方便实现，那虚拟内存的实现就需要建立在离散分配的内存管理方式的基础上，也就有了虚拟内存技术的三种方式 与传统的离散分配有两点区别 在程序执行中，当所需信息不在内存，操作系统需要从外存调进来，也就是说操作系统要提供请求调页(或请求调段功能) 如果内存空间不够，操作系统还要负责将内存中暂时用不到的信息换到外存，也就是说操作系统要有页面置换(或段置换)的功能 请求分页存储管理 页表机制 为了实现请求调页，操作系统需要知道每个页面是否已经调入内存，如果还没有调入，操作系统需要知道页面在外存的什么位置；为了实现页面置换，操作系统需要根据一些指标来判定谁被调出去，有的页面没有被修改过，就不需要再费力把它调回外存，有的页面被修改过，就需要将外存中的旧数据覆盖，因此，操作系统需要记录各个页面是否被修改过 下面是请求分页存储管理的页表与基本分页存储管理的页表的对比 缺页中断机构 在请求分页系统中，每当要访问的信息不在内存中需要去调入时，就会发生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断，这个时候缺页进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列 若果内存中有空闲块，就为该进程分配一个空闲块，将所缺页面装入该快，并修改相应页表中额页表项 若内存中没有空闲块，就要用页面置换算法将一个页面淘汰，若盖爷年在内存期间被修改过，就要写回外存，未修改过的页面不用写会外存 缺页中断是因为当前执行的指令想访问的目标页面未调入内存而产生的，因此属于内中断 一条指令当中可能发生多次缺页中断，比如copy a to b,因为a，b不在一个页面，就可能会发生两次缺页中断 地址变换机构 除上图之外还有几点细节 快表中的页面一定是在内存中，若某个页面被调到外存，快表中的相应表项也要删除，否则可能访问错误的页面 只有写指令才需要修改”修改位”，并且，一般来说只需要修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样可以减少访存次数 和普通中断处理一样，缺页中断也需要保留CPU现场 需要用某种页面置换算法来决定换出哪个页面 换入换出操作都依赖于I/O操作，因此若换入换出操作太频繁会有很大的开销 页面调入内存后，需要修改慢表，同时也需将表项复制到快表中 页面置换算法 页面的换入换出需要磁盘I/O，会有较大开销，因此好的页面置换算法应该追求更少的缺页率 最佳置换算法： 每次选择淘汰的页面将是以后永不使用或最长时间不被使用的页面，这样可以保证最低的缺页率，拿下面这个例子举例 当要访问页面2时，内存里没有，就发生缺页，这个时候发现内存已经满了，因此要用页面置换算法淘汰一个，若用最佳置换算法，目前内存里有7,1,0这三个页面，看看没页面2后面一次出现0,1,7，因此页面7是最长时间内不被使用的页面，因此淘汰7 当你把这个表完全分析完之后，你会发现，缺页发生了9次，但页面置换只发生了4次，因此却也不一定会发生页面置换，只有在内存中没有空闲块时才会发生页面置换 但是，想使用最佳置换算法就得知道访问页面的顺序，这可想而知，在进程运行时才知道下一步要访问谁，因此最佳置换算法是无法实现的 先进先出置换(FIFO)： 每次选择淘汰的页面是最早进入内存的页面 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可，队列的最大长度取决于系统为进程分配了多大内存块 具体过程很简单，就不赘述，但需要注意的是我给进程分了更多的内存块，他的缺页次数却不减反增，这是Belady异常，只有FIFO算法才会产生Belady异常，另外，虽然FIFO算法实现简单，但是该算法与进程实际运行的规律不适应，因为先进入的页面有可能最经常被访问，因此，算法性能差 最近最久未使用置换算法(LRU)： 每次淘汰的是最近最久未使用的页面 实现方法：页表的每一个页表项增添一个”访问字段”，记录该页面自上次被访问以来所经历的时间t，当要淘汰一个页面时，淘汰现有页面t最大的，即最近最久未使用的页面 下面举个栗子来直观感受下这个算法 如图走到箭头位置时，内存给分的内存块都满了，这个时候就要淘汰一个页面，目前内存里有1,8,7,2这四个页面，那根据最近最久，那从3逆向前找，依次找到8,1,2，7,；那7就是最近最久，淘汰7 因为该算法实现需要专门的硬件支持，虽然算法性能很好但实现困难，开销大 时钟置换算法(CLOCK)： 最佳置换算法的性能最好，却无法实现；先进先出置换算法随实现简单但性能差；最近最久未用置换算法性能好，是最接近最佳置换算法的，但实现起来需要硬件支持，算法开销大 时钟置换算法是一种性能和开销均衡的算法，又称最近未使用算法(NRU) 实现方法：为每个页面设置一个访问位 将内存里的页面通过链接指针依次连接成一个循环队列，当某页被访问时，其访问未知为1；当要淘汰页面时，从队头开始，若访问位是0，就将该页换出，若访问位为1，就将它置为0，暂不换出，继续检查下一页面，若第一轮扫描的所有页面都是1，则将这些页面置为0后，进行第二轮扫描时，一定会有访问位为0的页面，因此，时钟置换算法选择淘汰页面最多会经过两轮扫描 要淘汰时，指针开始动，第一次检查在队首，其他看情况而定 淘汰之后，指针才挪到下一位 eg：假设系统为某进程分配了5个内存块，并考虑以下页面引用串：1,3,4,2,5,6,3,4,7 分配了5个内存块，因此访问前五个页面时，只需依次链接成循环队列即可，且每访问一个页面就把该页面的访问位置为1 当想访问第6个页面时，已经没位置了，这个时候就要淘汰页面了，就从1号页(队头)开始，发现他的访问位是1，则将它置换成0，再来到3号页，发现他也是1，再将它置换成0，如此向下，把这一圈都检查完了，也都置成了0 接下来开始第二轮，检查1号页时，发现他是0，那就把它淘汰，将6号页换过来并置为1 接着往下走(像时钟一样不会逆着走，因此这里不是从6号页开始，而是继续到下一个页面)，3号页面在内存里，而且访问位是0，就将它的访问位置成1，接着往下走，4号页同理，注意3,4这里不需要淘汰页面，因此指针不走，还在3 要访问7页面时发现内存里没有，因为要淘汰页面了，指针开始动，这个时候就从3号页开始了，他是1，就将它置为0，指针来到4号页，发现他是1，就将它改成0，指针来到2号页，发现他本来就是0，因此置换出他，换上7号页，并置为1，淘汰后，指针指向5号页 改进型的时钟置换算法 注意几个点，第一轮找(0,0)因为这个时候没有被修改的，且第一轮扫描不修改任何标志位 第二轮找(0,1)，因为第一轮没有(0,0)，所以只能退而求其次来选择(0,1),这次要修改访问位，置为0 第三轮找(0,0)，因为第2轮没找到(0,1)，且都将访问位置成了0，不修改任何标志位 第四轮找(0,1)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存的基础知识]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是内存？有何作用内存是用于存放数据的硬件，程序执行前需先放到内存中才能被CPU处理 若计算机“按字节编址”，则每个存储单元大小为1个字节，即8位2进制 若字长为16的计算机“按字编址”，则每个存储单元大小为1字，即16位2进制 2的10次方=1K(千) 2的20次方=1M(兆，百万) 2的30次方=1G(千兆，十亿) 例如一台电脑有4GB内存，是指该内存中可存放4*2的30次方个字节，如果是按字节编址，也就是有2的32次方个存储单元(地址长度)(0~2的32次方-1) 逻辑地址&amp;物理地址逻辑地址：一般编译产生的都是逻辑地址(相对地址)，即可通过起始地址算出绝对地址 物理地址：在内存中实际存放的地址，又叫绝对地址 从写程序到程序运行 编译就是由高级语言到机器语言 逻辑地址到物理地址的转换(装入)绝对装入(还未产生操作系统)：在编译时，若知道程序将放到内存中的哪个位置，编译程序就产生绝对地址的目标代码，即装入时直接按模块里给的地址之机装到相应位置即可只适用于单道程序环境通常情况下，这个绝对地址是编译或汇编再转换成的，也可以是程序员直接赋予静态重定位(用于早期的多道批处理操作系统)：编译，连接后的模块，装入模块的地址都是从0开始，里面指令的地址是相对地址，在装入时对地址进行重定位，获得物理地址(转换是在装入时一次完成的)静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入，且装入后就不能移动了动态重定位(用于现代操作系统)：现在的计算机系统一般都采用这种方式，在编译，链接也和静态的一样地址都从0开始，指令中的地址是逻辑地址，但区别是动态重定位在装入后不会立即将逻辑地址转化为物理地址，他会在运行时，才转换。且动态重定位支持移动，因为它有重定位寄存器支持(存放装入模块存放的起始地址)## 链接的三种方式静态链接：在装入前就将各个模块链接，之后不再拆开装入时动态链接：装入时立即链接运行时动态链接：装入后，要运行的时候再链接## 内存管理操作系统作为资源的管理者，当然也要管理内存，如下是它所需要做的，未展开叙述的就是后续会补上的内容内存空间的分配与回收 内存地址的扩充(实现虚拟性) 地址转换(三种转换方式) 存储保护：保证各进程在自己的内存空间中运行，不会越界访问 两种方式：设置上下限寄存器；利用重定位寄存器，界地址寄存器(逻辑地址的最大值)进行判断]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[调度算法]]></title>
    <url>%2F2019%2F11%2F03%2F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[先来先服务算法(FCFS,First Come First Serve)(考虑等待时间) 下面给出例子来计算一下 按照先到先服务原则可以画出下面的示意图 周转时间=完成时间-到达时间：P1=7-0=7; P2=11-2=9;P3=12-4=8;P4=16-5=11 带权周转时间：周转时间/运行时间：P1=7/7=1；P2=9/4=2.25；P3=8/1=8;P4=11/4=2.75 等待时间=周转时间-运行时间：P1=7-7=0;P2=9-4=3;P3=8-1=7;P4=11-4=7 平均周转时间=(7+9+8+11)/4=8.75 平均带权时间=(1+2.25+8+2.75)/4=2.56 平均等待时间=(0+5+7+7)/4=4.75 其中排队买奶茶的例子是这样的，当你只想买一杯奶茶时，前面却出现一个人要一下子买30杯，本来你的奶茶只需要做1分钟，但因为那个”长作业”导致你要等很久，所以用户体验感很差，也就是上面计算中P3的带权周转时间，我们看到，他大很多倍。 为了解决这个问题，就有了下面的这一种算法 短作业优先算法(SJF,Shortest Job First)(考虑运行时间) 同样也是上面的计算例子 注意短进程优先算法是说，已经到达的进程中，运行时间最短的先服务，0时刻只有P1，所以P1先服务，而在0-7这中间P2,P3,P4都已经到达，因此可以画出下面图示 周转时间=完成时间-到达时间：P1=7-0=7; P2=12-2=10;P3=8-4=4;P4=16-5=11 带权周转时间：周转时间/运行时间：P1=7/7=1；P2=10/4=2.5；P3=4/1=4;P4=11/4=2.75 等待时间=周转时间-运行时间：P1=7-7=0;P2=10-4=6;P3=4-1=3;P4=11-4=7 平均周转时间=(7+10+4+11)/4=8 平均带权时间=(1+2.25+8+2.75)/4=2.56 平均等待时间=(0+5+7+7)/4=4 对比FCFS的后三项指标：8.75,3.5,4.75发现的确降低了很多 下面再来看看抢占式的短作业优先调度算法，最短剩余时间优先算法 即当有进程加入就绪队列改变，新到达的进程剩余时间比当前运行的进程剩余时间更短或正在运行的进程完成时，新进程抢占处理机 Pn(m) n表示第n个进程，m表示剩余时间 0时刻(P1到达)：P1(7) 2时刻(P2到达)：P1(5) P2(4) 4时刻(P3到达)：P1(5) P3(1) P2(2) 5时刻(P3完成，P4刚好到达)：P1(5) P2(2) P4(4) 7时刻(P2完成)：P1(5) P4(4) 11时刻(P4完成)：P1(5) 因此可以画出以下图示 周转时间=完成时间-到达时间：P1=16-0=16; P2=7-2=5;P3=5-4=1;P4=11-5=6 带权周转时间：周转时间/运行时间：P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1;P4=6/4=1.5 等待时间=周转时间-运行时间：P1=16-7=9;P2=5-4=1;P3=1-1=0;P4=6-4=2 平均周转时间=(16+5+1+6)/4=7 平均带权时间=(2.28+1.25+1+1.5)/4=1.5 平均等待时间=(9+1+0+2)/4=3 对比非抢占式的后三项指标：8 2.56 4 我们发现，这才是最小的 因此我们来总结一下，在所有进程同时可运行/几乎同时到达时，SJF的调度算法的平均等待时间，平均周转时间最少 若没有上述条件，则抢占式的短时间优先算法即SRTN的平均等待时间，平均周转时间最少 这也就是为什么一开始那个只是总览中的最少···打双引号 高响应比优先算法(HRRN,Highest Response Ratio Next)(都考虑) 同样是上面的计算例子，我们来分析一下， 0时刻：只有P1到达就绪队列，P1上处理机 7时刻(P1完成)：就绪队列中有P2,P3,P4,响应比分别为P2=(5+4)/4=2.25;P3=(3+1)/1=4;P4=(2+4)/4=1.75 8时刻(P3完成)：P2=(6+4)/4=2.5;P4=(4+1)/4=1.25 12时刻(P2完成)：只剩P4 时间片轮转算法(RR,Round-Robin)同样我们也可以像上面那样举个计算栗子来验证，且不需要算平均周转时间什么的，只看响应时间，画出图就好了，但这里表述不清，就省略了，只是提醒一点，当同一时刻既有处理机上下来的进程，又有新来的进程，则把从处理机上下来的进程挂在后面 动手试试之后，不妨将时间片分别设置大一点，小一点 这里只给出图示 当时间片为2时 当时间片为5时 你会发现时间片过大的话就和FCFS没什么区别，且会增大响应时间(比如上图P4五个小格后因超过时间片，所以要再响应一下) 时间片过小的话，需要频繁的切换进程，开销大，也导致进程的实际执行时间比例减少 因此，时间片既不能过大也不能过小，通常情况下，设计时间片大小时，应保证切换进程的比例不超过1% 优先级调度算法 同样给出下面这个小栗子，给出优先数，本例子是优先数越大，优先级越大，有的可能是优先数越大优先级越小，注意区分 非抢占式：进程主动放弃处理机(运行完或异常停止或I/O中断)后进行调度，在当前已经到达的进程中选择优先级最高的，当需判断两个优先级相同，则谁先到达就选谁 抢占式：当就绪队列改变时会发生调度，比如2时刻，由只有P1变为P1和P2，这个时候就会判断谁的优先级高，谁运行，当需判断两个优先级相同，则谁先到达就选谁 补充： 根据优先级是否可以动态改变将优先级分为静态优先级，动态优先级(创建进程时有一个初始值，之后根据情况动态改变) 如何合理设置优先级：系统进程优先级高于用户进程；前台进程高于后台进程；操作系统更偏好I/O型进程 是么时候调整动态优先级：若进程在就绪队列中等待了很长时间，则可以适当提升其优先级；若某进程在处理机内占用太长时间，就适当降低优先级；若进程频繁进行I/O操作，应适当提高优先级 以上的算法多多少少都有点瑕疵，下面给出折中的一种算法——多级反馈队列调度算法 多级队列调度算法(最优，用于进程调度，抢占式，会饥饿)算法思想：设计多级就绪队列 给出实例来分析算法流程 新进程先到优先级高的队列即第一级队列，待这一级时间片用完后就到下一级队尾，若已经在最后一级队尾则重新放入最后一级队尾，只有k级为空才会为k+1级分配时间片，具体实现过程如下图 (第五幅图开始少了个P1) 会饥饿：若源源不断地有短进程到达第一级队列，拿在底下队列的进程长期得不到服务就会饥饿]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[调度算法的评价指标]]></title>
    <url>%2F2019%2F10%2F31%2F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[相对于操作系统则看重平均，就是除以作业数 CPU利用率(CPU贵，希望他利用率高一点)利用率=忙碌时间/总时间 系统吞吐量(希望少时间内完成更多作业)单位时间内完成作业的数量 吞吐量=总共完成了多少作业/总共花了多少时间 周转时间(希望作业从提交到完成花的时间少一点)周转时间包括四部分： 1 作业在外存后备队列上等待高级调度 2 进程在就绪队列上等待低级调度 3 进程在CPU上运行 4 进程等待I/O操作完成的事件 后三项在一个作业的整个处理过程中可能发生多次 因而周转时间=作业完成时间-作业提交时间 但用户只关心自己的作业从提交到完成花了多少时间，也就是周转时间是多少 打个比方：假设作业1实际运行时间只需要一分钟，作业2实际运行时间需要十分钟；周转时间为12分钟，那对于1来说，用户体验感很差，我本来就一分钟就好了，你却让我等十几分钟；但对于作业2来说，他的体验就是极好的，也就是多等了一会而已。 那就给出了带权周转时间的定义：带权周转时间=作业周转时间/作业实际运行时间 那也就是周转时间越小带权周转时间越小，用户体验感更好 等待时间(希望作业/进程等待处理机的时间尽可能少)对于进程来说，等待时间指进程被创建后等待处理机的时间，其中在等待I/O完成的过程不算，即等待时间=周转时间-运行时间-I/O操作时间 对于作业来说，等待时间是指从作业被加入外存开始。即周转时间-运行时间 因为作业要被CPU，I/O设备处理多久一般都是确定的，所以调度算法只会影响等待时间 响应时间(从用户提交请求到首次产生响应)比如我按下键盘的一个键等待计算机给我响应的时间]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程调度]]></title>
    <url>%2F2019%2F10%2F31%2F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[进程调度的时机 当然进程调度也不是想发生就发生的，如下这三种情况就不可以 1 中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换 2 注意是内核程序临界区，如果是普通临界区则可以切换 3 例如原语，要一气呵成不能被中断 进程调度的方式非剥夺调度方式(非抢占方式) 只允许进程主动放弃处理机，在运行过程中即使有紧急的任务到达，当前进程依然会继续使用处理剂，直到该进程终止或主动要求进入阻塞状态 实现简单，系统开销小但无法及时处理紧急任务，适合于早期的批操作系统 剥夺调度方式(抢占方式) 当一个进程正在处理机上执行时，如果有一个更紧急的任务进程要用处理机，则立即暂停正在执行的进程，将处理机分配给更紧急的那个进程 可以优先处理更紧急的进程，也可以让各进程按时间片轮流执行，适用于分时操作系统，实时操作系统 进程调度(选择)，进程切换(从一个到另一个)是有代价的，并不是调度越频繁，并发度就越高]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处理机调度的概念和层次]]></title>
    <url>%2F2019%2F10%2F31%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[调度的基本概念在多道程序系统中，进程的数量往往是多于处理机的，这样不可能并行地处理各个进程。处理及调度，就是从就绪序列按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行 调度的三个层次高级调度(作业调度) 由于内存有限，有时无法将用户提交的作业都放进内存，就会通过高级调度，按照一定的规则从外存上处于后备队列中的作业挑一个给他分配内存等必要自愿，并创建相应的PCB，使他获得竞争处理机的权利。 因此，高级调度是外存和内存之间的调度，每个作业只能被调入，调出依次，作业调入时会创建PCB，调出时才销毁PCB，高级调度主要是指调入问题，因为只有调入的时机才由操作系统决定，但调出必须是作业运行结束才调出。 中级调度(内存调度) 存入内存的有些进程可能暂时不能运行，但是他却占着内存位置，因此引入虚拟存储技术，来提高内存利用率和系统吞吐率，具体实现就是将暂时运行不了的进程调到外存等待，等进程具备运行条件且内存稍有空间时，重新调入内存。暂时调出内存的进程状态为挂起状态，但PCB不会被调出，因为操作系统还要根据PCB记录的进程数据存放在外存的地址，进程状态等信息对进程监控，管理，被挂起的进程PCB会被放到挂起队列中。 中级调度，就是要决定哪个处于挂起状态的进程需要重新被调入内存中，一个进程可能被调入调出很多次，因此中级调度比高级调度发生频率要高的多 进程的挂起状态和七状态模型 暂时调到外存等待的进程状态叫挂起状态，挂起状态可以细分成就绪挂起状态和阻塞挂起状态。因此就有了下面的七状态模型 激活和挂起两部分不必多说，有时运行态或者创建态要转化成就绪态有可能因为内存不够或某种原印，将进程调到外存，成为就绪挂起状态，同样的，当处于阻塞他的进程等待的事件发生了，想转化成就绪态，同样也可能因为某些原因被调到外存，成为就绪挂起状态 低级调度(进程调度) 低级调度的任务就是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给他，低级调度(进程调度)是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，进程调度的频率很高，一般几十毫秒一次。 总结]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哲学家进餐问题]]></title>
    <url>%2F2019%2F10%2F31%2F%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：在一张圆桌上坐着5位哲学家，在每两位哲学家中间放一只筷子，桌子中间是一碗米饭，哲学家只要两个动作，要么思考，要么吃饭，但哲学家只有拿起两只筷子才能正常吃饭，如果筷子在别人手里，这位哲学家就被阻塞，当进餐完毕之后，放下筷子继续思考 分析： 五位哲学家与左右邻居对其中间的，筷子的访问是互斥的 每个哲学家进程需要同时持有两个临界资源才能吃饭，如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓 信号量设置chopsticks[5] = {1,1,1,1,1}，对哲学家按0~4编号，哲学家i左边筷子为i,右边筷子为(i+1)%5 这样我们可以很自然地写出下面的代码 12345678910111213semaphore chopsticks[5]=&#123;1,1,1,1,1&#125;;Pi()&#123; while(1)&#123; // 拿左边筷子 P(chopsticks[i]); // 拿右边筷子 P(chopsticks[(i+1)%5]); 吃饭; V(chopsticks[(i+1)%5]); V(chopsticks[i]); 思考; &#125;&#125; 但是，如果五个哲学家并发执行，都拿起了左边筷子，那谁也拿不到右边筷子，那谁也吃不了饭，发生死锁，就造成了饥饿 那怎么解决死锁问题呢？ 上面分析出现的问题是，哲学家们谁也不能同时拿起左右两双筷子，那我们现在要解决的就是我们至少要让一个哲学家拿到筷子，也就是说要让他一气呵成的拿筷子，拿筷子过程中和任意一个哲学家都存在互斥，解决一气呵成问题就用互斥 1234567891011121314semaphore chopsticks[5]=&#123;1,1,1,1,1&#125;;semaphore mutex = 1;Pi()&#123; while(1)&#123; P(mutex); P(chopsticks[i]); P(chopsticks[(i+1)%5]); V(mutex); 吃饭; V(chopsticks[(i+1)%5]); V(chopsticks[i]); 思考; &#125;&#125; 这样就肯定能保证有一个哲学家拿到两只筷子。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[吸烟者问题]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：假设系统中有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起一支烟，抽烟者需要三种材料：烟草，纸和胶水，三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水，供应者无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉他完成了，供应者就会放另外两种材料到桌子上，这个过程一直重复(让三个抽烟者轮流抽烟) 分析： 这是一种可以生产多种产品的单生产者和多消费者问题，每次生产者只能放两种材料到桌子上，那这就存在着互斥问题，我们可以将桌子抽象为容量为1的缓冲区，那可能会问，我每次放两个东西上去啊，容量怎么能是1呢，在这里我们应该看成组合关系，我们每次是放一个组合上去 123组合一：纸+胶水组合二：烟草+胶水组合三：烟草+纸 同步关系(从事件角度来考虑) 1 桌子上有组合一 -&gt; 第一个抽烟者取走东西 2 桌子上有组合二 -&gt; 第二个抽烟者取走东西 3 桌子上有组合三 -&gt; 第三个抽烟者取走东西 4 发出信号 -&gt; 供应者将下一组合放到桌子上 那对应的四个同步信号量就应该是 1234semaphore offer1 = 0;semaphore offer2 = 0;semaphore offer3 = 0;semaphore finish = 0; 其中finish表示发出完成信号的数量，刚开始是0 那对应的PV操作如下图所示 根据多生产者多消费者分析出的结论，这个抽烟者问题也是当缓冲区容量为1时，可不设置互斥信号量也能实现互斥 代码实现： `C++semaphore offer1 = 0;semaphore offer2 = 0;semaphore offer3 = 0;semaphore finish = 0;int i = 0;provider(){ while(1){ // 实现轮流 if(i==0){ 将组合一在桌上; V(offer1); } else if(i==1){ 将组合二在桌上; V(offer2); } else if(i==2){ 将组合三在桌上; V(offer3); } i = (i+1)%3;//实现 0 1 2循环 P(finish);//若写在最上面就一下子就阻塞了，要等到放完东西再检查有没有完成信号 }}smoker1(){ while(1){ P(offer1); 从桌子上拿走组合一，卷烟抽掉; V(finish); }}smoker2(){ while(1){ P(offer2); 从桌子上拿走组合二，卷烟抽掉; V(finish); }}smoker3(){ while(3){ P(offer3); 从桌子上拿走组合三，卷烟抽掉; V(finish); }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[读者写者问题]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：有读者和写者两组并发进程，共享一个文件。 分析：当多个读进程共同访问时不会出现问题(读进程与消费者不一样，读进程不会讲数据清空，并不会改变数据)，但写进程和其他进程(读进程或者写进程)同时访问时会出现问题，比如一边写一遍读，我这边刚写完，你又来写；因此有如下要求 1 允许多个读者共同访问共享文件的数据 2 只允许一个写者往文件里写 3 任一写者未完成写操作时，不允许任何读者或写者进入 4 写者进入写操作前，应让已有的读者和写者退出 分析： 都是互斥关系：读进程-写进程，写进程-写进程，读进程-读进程必须要互斥 因为写进程要和任一进程都互斥，因此设置一个rw的互斥信号量，在写进程前后分别用P,V操作，因为读进程与写进程也互斥，因此我也得在读进程前后也分别用P,V操作，那么这个时候如果我已经有一个读进程在读了，我另一个读进程也想读，就会被P操作这一步阻塞，这违背了读进程-读进程不互斥。接下来就是读者写者的核心问题了—用count来控制，我们可以把P，V操作分别理解为加锁和解锁，那我第二个读进程再想进就不应该再加锁了，应该跳过这一步直接往下去读，因此这个时候的解决方法就是用count去判断是第几个读进程想进去，然后跳过加锁过程。 实现自己和自己不互斥，自己和别人互斥，考虑用count计数器 代码实现 1234567891011121314151617181920212223semaphore rw = 1;int count = 0;writer()&#123; while(1)&#123; P(rw); 写文件; V(rw); &#125;&#125;reader()&#123; while(1)&#123; if(count==0)&#123; P(rw); &#125; count++; 读文件； count--; if(count==0)&#123; V(rw); // 如果是最后一个读进程，需解锁 &#125; &#125;&#125; 但是如果第一个读进程进行完P操作之后还没进入共享文件就切换到了第二个读进程，这时count仍为0，那第二个读进程也要进行P操作，但这时他就要被阻塞了，因此上面的方法还是不行，那问题出在哪，显然是因为检查和改变count没有一气呵成，那解决一气呵成问题应该很自然的想到用互斥的方法，因此我们应该再加一个互斥信号量mutex，让进程在每次进行检查和改变count值得时候都P,V操作一下 12345678910111213141516reader()&#123; while(1)&#123; P(mutex) if(count==0)&#123; P(rw); &#125; count++; V(mutex) 读文件； P(mutex); count--; if(count==0)&#123; V(rw); &#125; V(mutex); &#125; 这个时候第一个读者在进行P(rw)和count++是一起呵成的，他不完成这两步然后V(mutex),第二个读进程只能一直被阻塞，等他完成了，第二个读进程进来因为此时count已经是1了，因此第二个读进程直接count++，接着往下走就行了。至此，关于互斥的操作就都完成了 但是如果有很多读进程都在读，那写进程就要一直等，这样就造成了饥饿，也就是读进程优先，那解决这个问题我们可以再加一个互斥信号量w 123456789101112131415161718192021222324252627282930semaphore rw = 1;semaphore mutex = 1;semaphore w = 1;writer()&#123; while(1)&#123; P(w) P(rw); 写文件; V(rw); V(w); &#125;&#125;reader()&#123; while(1)&#123; P(w) P(mutex) if(count==0)&#123; P(rw); &#125; count++; V(mutex) V(w) 读文件； P(mutex); count--; if(count==0)&#123; V(rw); &#125; V(mutex);&#125; 我们来验证下可不可以 读者1-&gt;读者2：读者以进来后w=0,mutex=0,rw=0,count=1;在没有进行V操作之前，读者2被阻塞，进行V操作之后读进程可以跳过P(rw)正常向下，也就是即实现了一气呵成，又满足读者进程和读者进程不互斥 写者1-&gt;写者2：这个与上面的类似，很好证明成立 写者1-&gt;读者1：当写者没写完，w永远是0，读者会被阻塞在P(w)，反之亦然，因而读者和写者之间互斥成立 读者1-&gt;写者1-&gt;读者2： 在读者1一直走一直走到V(w)这一步后，之前被阻塞的写者1才能被唤醒，只要写者没写完进行V(w)，读者2就一直被阻塞 写者1-&gt;读者1-&gt;写者2： 在写者V(w)后，第一个唤醒的是读者1，读者1V(rw)之后，写者2被唤醒 根据上面的验证我们发现这样完全可行，不会读进程一进来就畅行无阻，阻塞写进程，不会造成谁优先谁饥饿，是一种公平的状态]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多消费者-多生产者问题]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[先给出问题背景：桌子上有一个盘子，每次只能向其中放入一个水果，爸爸专向盘子里放苹果，妈妈专向盘子里放橘子，儿子专等着吃盘子里的橘子，女儿专等着吃盘子里的苹果。只有字盘子是空的时候，爸爸或妈妈才能向盘子里放水果；只有在盘子里有自己想要的水果时，儿子或女儿才能取出盘子里的水果吃掉。 分析： 对盘子的访问要互斥 同步关系(一前一后) 1 父亲将苹果放进盘子后，女儿才能取走苹果 2 母亲将橘子放进盘子后，儿子才能取走橘子 3 盘子为空时，爸爸或妈妈才能往盘子里放水果(盘子为空这个事件可以由女儿或儿子触发) 根据上面的分析，我们可以得出下面的几个信号量 1234semaphore mutex = 1; //互斥信号量semaphore apple = 0;semaphore orange = 0;semaphore plate = 1;//一开始父亲或母亲就可以放水果，可以理解为空闲大小 具体代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344semaphore mutex = 1;semaphore apple = 0;semaphore orange = 0;semaphore plate = 1;dad()&#123; while(1)&#123; 准备一个苹果; P(plate); P(mutex); 把苹果放入盘子; V(mutex); V(apple); &#125;&#125;mom()&#123; while(1)&#123; 准备一个橘子; P(plate); P(mutex); 把苹果放入盘子; V(mutex); V(orange); &#125;&#125;daughter()&#123; while(1)&#123; P(apple); P(mutex); 取出盘子里的水果； V(mutex); V(plate); 吃苹果; &#125;&#125;son()&#123; while(1)&#123; P(orange); P(mutex); 取出盘子里的水果； V(mutex); V(plate); 吃苹果; &#125;&#125; 注意这里还是互斥的P操作要写在同步的P操作之后，避免产生死锁问题 现在来考虑考虑，我可不可以不要互斥信号量？ 一开始盘子为空，女儿和儿子想运行都会被阻塞，如果父亲先操作，那么会让plate变成0，这个时候母亲要是想放橙子会被阻塞；女儿当然可以拿苹果，其他进程都会被阻塞，如此分析看来，我不要互斥信号量是完全ok的 1234567891011121314151617181920212223242526272829303132333435semaphore apple = 0;semaphore orange = 0;semaphore plate = 1;dad()&#123; while(1)&#123; 准备一个苹果; P(plate); 把苹果放入盘子; V(apple); &#125;&#125;mom()&#123; while(1)&#123; 准备一个橘子; P(plate); 把苹果放入盘子; V(orange); &#125;&#125;daughter()&#123; while(1)&#123; P(apple); 取出盘子里的水果； V(plate); 吃苹果; &#125;&#125;son()&#123; while(1)&#123; P(orange); 取出盘子里的水果 V(plate); 吃苹果; &#125;&#125; 那如果我的盘子可以放两个水果呢？plate的初始值就是2，当父亲放进苹果后，plate变为1，母亲也想放橙子，发现也可以，于是就出现了父亲母亲同时访问缓冲区的情况，因而，如果缓冲区容量为1，我们可以不设互斥信号量，但如果缓冲区容量大于1，就必须设置信号量 那为了避免出麻烦，我们就不管三七二十一都给他设上互斥信号量，肯定是没有问题的。 最后想说一个思想，在多消费者多生产者的问题中，不同于之前的生产者消费者问题，我们不应该把每个进程看成一个整体来考虑问题，应该将事件拿出来分析问题 就上面的问题来讲，如果我不按时间角度来分析，那就是只有儿子将橘子取走了，母亲才能向盘子里放橘子；只有女儿将苹果取走了，爸爸才能把苹果放在盘子里；那仔细想想，我一定要有这个先后顺序吗，比如说女儿取走苹果之后，既可以是母亲方橘子，也可以是父亲放苹果，因此应该想象成事件间的前后关系，就是只有盘子空了，父亲或母亲才能放水果。 再者，通过栗子，我们应该明白，所谓多消费者多生产者应该不是数量上的多，而应该是种类上的多。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生产者-消费者问题]]></title>
    <url>%2F2019%2F10%2F29%2F%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[所谓生产者-消费者问题实际上就是有一个缓冲区，生产者生产好了放进去，消费者可以从缓冲区中取出来产品用，但是需要注意的是肯定是要保证各进程都是互斥的，生产者和消费者要互斥不用多说，假设现在有两个生产者想要把产品放进缓冲区，如果都想放在同一个地方怎么办，因此一定要保证互斥性，那互斥的初始信号量是1，因此我们要设置一个互斥信号量 semaphore mutex = 1; 假设初始的缓冲区是大小为n的空缓冲区； 首先当缓冲区满了，就不能让生产者在把产品放进去了，得等消费者取出产品释放空间了才行，也就是说在缓冲区满这种情况，必须是消费者在生产者之前，那这就是要有一个同步，同步信号量就是空闲缓冲区的大小，就是要确认一下空闲缓冲区有没有位置，空闲缓冲区的初始值就是n ,semaphore empty = n; 当缓冲区是空的时候，同样不能让消费者从中取出产品，那这里就是生产者要在消费者之前执行，那这里也是一个同步关系，这里的同步信号量就是产品数量，初始值为0，semaphore full = 0;; 直观点看就是下面这张图 下面上代码 123456789101112131415161718192021222324semaphore mutex = 1;semaphore full = 0;semaphore empty = n;producer()&#123; while(1)&#123; 生产一个产品; P(empty);//1 P(mutex);//2 把产品放进缓冲区； V(mutex); V(full); &#125;&#125;consumer()&#123; while(1)&#123; P(full);//3 P(mutex);//4 从缓冲区取走一个产品; V(mutex); V(empty); 使用产品;“ &#125;&#125; 需要仔细理解一下full和empty,注意full缓冲区里的产品数，empty是缓冲区空闲的大小，而且敲重点同步信号量定的是初始值！！！不要想当然。还有就是要注意实现互斥的P操作一定要写在实现同步的P操作之后，V操作无所谓先后，为什么呢？如果颠倒了位置（2143），假设缓冲区已经满了，即empty为0，full为n，如果先执行互斥的P操作,mutex为0，再执行P(empty)，因为已经没有空闲缓存区了，因此生产者被阻塞，切回消费者，因为mutex已经为0了，消费者这边P(mutex)也走不下去了，消费者也则色，这就造成了消费者等生产者释放临界区，生产者等待消费者释放空闲缓冲区，生产者和消费者循环等待被对方唤醒，形成死锁，同样的若缓冲区为空，也会造成死锁. 还有就是尽量不要把”生产一个产品”和”使用产品”放在缓冲区那步代码，最好像上面那么些，不然占用资源会造成忙等。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号量机制]]></title>
    <url>%2F2019%2F10%2F28%2F%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为啥要引入信号量机制，关于实现进程互斥我们有四种软件实现方法，三种硬件实现方法，但是要么就是不能让上锁和检查一气呵成出现问题，要么就是上述所有方法都有的一个通病：不能实现让权等待。那么，就是信号量机制诞生的意义啦。 信号量：一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量。 用户进程可以通过使用操作系统提供的一对原语来对信号量操作，从而很方便的实现进程互斥，进程同步。 划重点：一对原语：P,V操作=&gt;P(S),V(S),S为调用时传入的参数，是信号量；其中P,V分别可表示为wait和signal 信号量机制–整型信号量 用一个整数型变量作为信号量，这里这个整型信号量只能用于三种情况，初始化，P操作,V操作 wait实现的底层原理 12345int S = 1; //初始化void wait(int S)&#123; //wait原语，相当于进入区 while(S&lt;=0); //如果资源不够就一直等待，会出现忙等，不满足让权等待 S=S-1; //如果资源够，就占用一个资源&#125; signal实现的底层原理 1234int S = 1;void signal(int S)&#123;//signal原语，相当于退出区 S=S+1; //用完资源，在退出区释放资源&#125; 例如：这里有一个进程P0 ··· P(s); //进入区，申请资源 //临界区，访问资源 V(s); //退出区，释放资源 ··· 敲重点！！！整型信号量的缺陷就是不满足让权等待 信号量机制–记录型信号量 先来看看原理 12345678910111213141516171819//记录型信号量的定义typedef struct&#123; int value; //剩余资源数 Struct process *L; //等待队列&#125;semaphore;//某进程需要资源时，通过wait原语申请void wait(semaphore S)&#123; //传入的必须是semaphore类型的 S.value--; if(S.value&lt;0)&#123; block(S.L);//如果资源不足，就用block原语转为阻塞态，并加到信号量等待队列的队尾上 &#125;&#125;//进程使用完资源后，通过signal原语释放void signal(semphore S)&#123; S.value++; if(S.value&lt;=0)&#123; wakeup(S.L);//如果加1后还是小于等于零说明之前有进程被挂在等待队列上了，就使用wake原语唤醒，从等待队列的对头拿出一个进程，将他从阻塞态转为就绪态并分给他资源让他运行 &#125;&#125; 这个过程要是不理解就写出四个进程，给两个资源自己比划比划，但是要强调一下，不论是P操作还是V操作，不论满不满足资源够用，都要先对value操作。这样就避免了违反让权等待。 用信号量实现进程互斥 1 分析问题，找出临界区 2 设置互斥信号量，初值为1(因为临界区只允许一个) 3 进临界区之前做P操作 4 进临界区之后做V操作 举个栗子 123456789101112131415semaphore s = 0;P1()&#123; ··· P(s); 临界区 V(s); ···&#125;P2()&#123; ··· P(s); 临界区； V(s); ···&#125; 用信号量实现进程同步 问题来了，什么是同步，那就记好了，同步就是你想让他有顺序，比如谁必须在谁之前执行,注意理解下面第3,4步 1 分析问题，找出哪里需要实现”一前一后”的同步关系(比如代码4必须在代码2后执行) 2 设置同步信号量，初始值为0 3 在前操作之后执行V操作 4 在后操作之前执行P操作 举个栗子 12345678910111213semaphore s = 0;P1()&#123; 代码1； 代码2； V(s); 代码3;&#125;P2()&#123; P(s); 代码4； 代码5； 代码6；&#125; 用信号量实现进程的前驱关系 1 分析问题，画出前驱图，把一堆钱去关系都看成一个同步问题 2 为每一对前驱关系设置同步信号量，初值为0 3 在前操作之后执行V操作 4 在后操作之前执行P操作 举个栗子 如上图就是一个前驱图，说白了就是必须在谁谁谁完成之后，谁谁谁才能运行，比如S1完了，S2,S3才行；S2完了，S4，S5才行；S4,S5,S3完了，S6才行。而每一条箭头连接的两个进程就是同步关系，依次信号量都是0，遵循同步的规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445P1()&#123; ··· S1； V(a); V(b); ···&#125;P2()&#123; ··· P(a); S2； V(c); V(d); ···&#125;P3()&#123; ··· P(b); S3； V(g); ···&#125;P4()&#123; ··· P(c); S4； V(e); ···&#125;P5()&#123; ··· P(d); S5； V(f); ···&#125;P6()&#123; ··· P(e); P(f); P(g); S6； ···&#125; 因此只要把图画出来就会变得非常简单]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程同步与互斥]]></title>
    <url>%2F2019%2F10%2F18%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%2F</url>
    <content type="text"><![CDATA[进程同步我们知道为了实现并发，进程就有了异步性这个概念，异步性就是以不可预知的速度和方向进行的，但是有的时候我希望各个进程是可以共同合作的，就是有一定顺序的进行，就比方说管道通信，我就想先写再读而不是不知道是先读还是先写，这个时候就要引入进程同步来解决这个问题。 进程同步：有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的顺序 进程互斥进程互斥就是当一个进程使用某一资源时，其他进程只能等待，只有当这一进程用完了，将资源释放了，下一进程才能使用，也就是互斥。那某一资源是啥？这就是下面要讲的一个概念——临界资源 临界资源：一个时间段内只允许一个进程使用的资源，如很多物理设备——打印机，摄像头，此外还有很多变量，数据，内存缓冲区都属于临界资源 对临界资源的互斥访问，可以在逻辑上分为如下四个部分 进入区：负责检查是否可以进去临界区，若可以进入，则应该设置正在访问临界资源的标志(可以理解为上锁) 临界区：访问临界资源的那段代码 退出区：负责接触正在访问临界资源的标志(可理解为解锁) 剩余区：做其他处理 现在我们来想一个问题，要是我这个进程暂时进不了临界区，但是他还站着处理机，我可以一直让他一直占着吗。为了保证整体系统的性能，就要引入我的四个原则 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区(不会饥饿) 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待(占用着处理机却不能进临界区而忙碌地等待) 进程互斥的软件实现方法先给出框图，再详细讲 单标志法: 123456int turn = 0;P0进程： P1进程：while(turn!=0); (1) while(turn!=1); (5) //进入区critical section; (2) critical section; (6) //临界区turn = 1; (3) turn = 0; (7) //退出区remainder section;(4) remainder section;(8) //剩余区 首先我们来推一下这个方法是怎么实现互斥的，我们定义了turn为0，这个turn就是单标志，即刚开始只允许P0先进入临界区。若P1先上处理器运行，他会一直循环5，直到时间片用完，发生调度，回到P0，P0可以进入临界区，在P0运行过程中，若切换回P1，仍会继续循环在5，只有P0在退出区将turn转为1时，P1才能进临界区，因此可以实现互斥。 但是我们可以很容易就发现我把TURN 定义成0后，对于临界区的访问，只能是P0-&gt;P1-&gt;P0-&gt;P1…,这样的轮流进入临界区带来的问题就是，当只允许P0进，但P0一直不进，P1想进却进不了，就不满足空闲让进的原则。 双标志先检查法: 123456789bool flag[2]; //表示进入临界区的意愿的数组flag[0]=false;flag[1]=false;P0进程： P1进程：while(flag[1]); (1) while(flag[0]); (5) //进入区flag[0]=true; (2) flag[1]=true; (6)critical section; (3) critical section; (7) //临界区flag[0]=false; (4) flag[1]=false; (8) //退出区remainder section; remainder section; //剩余区 flag[0],flag[1]为双标志，谁要是想进先检查对方想不想进，对方想，那他就一直卡在那，直到时间片用完，对方不想，那他就把自己的标志设为true(上锁)，直到他来到退出区将他的标志设为false，别的进程才能用临界区。对比单标志法，这里因为在进入临界区前上了锁就是只有他想进入临界区时才会设置成true,这样就避免了违反空闲让进原则 但想想要是按照152637这样的顺序进行，产生这种方式的原因是异步性，这样的话就是说P0，P1可以同时进入临界区，违反了忙则等待的原则，导致这种情况的原因就死检查和上锁没有一气呵成，有可能因为进程切换导致这样的结果 双标志后检查法: 123456789bool flag[2]; //表示进入临界区的意愿的数组flag[0]=false;flag[1]=false;P0进程： P1进程：flag[0]=true; (1) flag[1]=true; (5) //进入区while(flag[1]); (2) while(flag[0]); (6)critical section; (3) critical section; (7) //临界区flag[0]=false; (4) flag[1]=false; (8) //退出区remainder section; remainder section; //剩余区 对比双标志先检查法可以发现，这个无非就是颠倒了一下顺序，先上锁后检查，这样的话我先上了锁表明我想进，然后另一个要是想进，那我就等待因此的确是避免了同时进入的可能，但是如果我还是因为异步，按照1526的顺序，就会导致谁也进不去，这就违背了空闲让进，和有限等待原则，会因各进程都长期无法访问临界资源而产生饥饿现象。 Peterson算法: 1234567891011bool flag[2]; //表示进入临界区的意愿的数组int turn=0;flag[0]=false;flag[1]=false;P0进程： P1进程：flag[0]=true; (1) flag[1]=true; (6) turn=1; (2) turn=0; (7)while(flag[1]&amp;&amp;turn==1); (3) while(flag[0]&amp;&amp;ruen==0); (8)critical section; (4) critical section; (9)flag[0]=false; (5) flag[1]=false; (10)remainder section; remainder section; 这个算法可以理解成一种孔融让梨的思路，比如说1,6是表明自己想要进临界区，2,7却是我愿意让出临界区，123456或者1623都能满足互斥。 最后说一下这四个算法都有的一个毛病，就是在他们进行死循环进不了临界区的shihou9，他们都占着处理机，就造成了忙等，也就是违背了让权等待 进程互斥的硬件实现方法 中断屏蔽方法: 利用开/关中断指令实现，与原语实现思想相同，即在进程从开始访问临界区到结束访问这中间不允许发生进程切换，因此不能发生两个同时访问临界区的情况 ··· 关中断 临界区 开中断 ··· 优点：简单高效 缺点：不适合多处理机，假如说我处理机1弄了关中断，那处理机1当然不会有问题，别的进程进不了临界区，但是如果我其他的处理机想进入临界区，那因为中断是相对于某个处理机，那么也就是说处理机2上的进程也可以进入处理机1的这个临界区，就没有实现互斥了 再者，因为开/关中断指令只能运行在核心态，如果让用户态可以随意调用很危险，所以只适用于操作系统内核进程，不适用于用户进程 TextAndSet指令: TSL指令是用硬件实现的，执行过程中不允许被中断，将检查和上锁操作一气呵成 优点：适用于多处理机，实现简单，不用想软件实现方法那样严格检查是否会有逻辑漏洞 缺点：和软件实现方法一样，可能会出现占用处理机进行死循环的状态，形成忙等待，即不满足让权等待的原则 Swap指令: 逻辑上与TSL指令类似，优缺点也一样，只不过步骤不太一样。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2019%2F10%2F17%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是线程什么是线程？我们首先得说说为什么要引进线程-&gt;从程序到进程，我们实现了进程并发让我的qq和网易云可以同时运行，但是我想用QQ一边视频，一边打字聊天，一边看QQ空间怎么办呢。QQ这个进程里的代码是顺序执行的，我是不是也得让这些小操作也可以并发执行才行，这个时候就得引出我们的线程了。也就是说进程里可以有多个线程，且这些线程可以被处理机调度，这个时候被处理机调度的就不是进程了，进程只是除CPU外的系统资源分配单元(如打印机等都是分给进程的)，线程是调度的基本单位。同时，在以前进程的切换需要切换当前的运行环境，系统开销大，但如果线程在同一个进程下就不需要切换运行环境，系统开销小。 线程的属性线程是处理机调度的单位 多CPU的计算机中，各个线程可占用不同的CPU 每个线程有一个线程ID，线程控制块(TCB) 线程也有就绪，阻塞，运行三种基本状态 线程几乎不拥有系统资源 同个进程的不同线程共享进程的资源 由于共享内存地址，同一进程中的线程间通信无需系统干预 同一进程中的线程切换不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 线程的实现方式用户级线程：由应用程序的线程库实现，线程切换可在用户态下完成，无需操作系统干涉；用户能看到，操作系统看不到 在引入内核级线程之前我们先来讲讲为什么需要内核级线程，只有用户级线程不好吗，他切换都不用操作系统干涉的，不是效率高吗。那我们来想想操作系统只能看见进程，只能管进程，那我的处理机资源就给这个进程，当我线程想调I/O设备的时候，肯定要系统调用，转为核心态，这个时候我这个线程就阻塞了，其他的线程呢？因为操作系统看不见他们，就不能调度他们，我处理机在唯一的那个进程那，现在就是进程阻塞了，其他的线程也阻塞了，这样性能大大降低了。那这个时候如果我引入内核级线程，我的处理机就可以供内核级线程调度，而不是单单只供一个进程调度，如果我有一个以上的内核级线程是不是就可以解决上面的都阻塞问题了，但是要知道这就要涉及到内核了，内核级线程切换就要增大开销了。 内核级线程：管理工作由操作系统内核完成，包括线程调度，线程切换等。因此内核级线程要在核心态下完成。 这里需要注意的是，我上面讲了那么多就是想表明一个意思，进程，线程，用户级线程，内核级线程，这一串实际上就是一级一级为了解决上一级问题才诞生出来的机制，所以我这个内核级线程并不是来代替用户级线程，因此我想要用内核级线程，我就也需要有用户级线程 多线程模型多对一模型:其实这个多对一和之前没有内核级线程没什么区别，也还是会导致都堵塞问题，并发度低，但是进程管理开销小，效率高 一对一模型：其实这个一对一模型就是纯粹的引入内核级线程，这里各线程可以分给多个处理机，并发度高，但进程管理开销大 多对多模型 用户级线程个数&gt;=内核级线程个数，这我认为是不想浪费，内核级线程是来解决问题的，当然不能多弄出来几个浪费啊。多对多模型，就是集上面两者所长。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程的定义(强调动态性)进程是能和其他程序并行执行的程序段在某数据集合上的一次运行过程，它是系统资源分配和调度的基本单位。 话说为什么要引入进程呢？在最开始是单道程序技术时，只有一个程序在运行，CPU可以很容易的找到位置，但想引入多道程序技术，就意味着我要支持并发，那并发，就是每个程序都是走走停停，我要记录当下位置，那这个时候就得引入进程，还要给他一个PCB来记录，同时需要注意的是进程是在某个程序段上的而不是程序上。 进程的组成进程=PCB(程序控制快)+程序段(存放要执行的代码)+数据块(存放程序运行中处理的各种数据) 实际上应该说进程实体等于上面那一串，进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，进程实体是静态的而进程是动态的。 进程的组织(执行指针，就绪队列指针，阻塞队列指针) 链接方式 索引方式 进程的特征动态性：进程是程序的一次执行过程，是动态发生，变化，消亡的 并发性：内存中有多个进程实体，各进程可以并发执行 独立性：进程是能独立运行，独立获得资源，独立接收调度的基本单位 异步性：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题 结构性：各个进程都会配置一个PCB，结构上看，进程由程序段，数据段，PCB组成 进程的状态 需要注意的是单核处理机环境下某一时刻只能有一个进程位于执行态，而双核环境下可以同时有两个进程处于运行态；就绪态就是拥有了除处理机一切资源，万事俱备，只欠CPU；阻塞态一般是向操作系统申请I/O设备时的等待，为了提高CPU的利用率，需先将其他资源配备齐了才能获得CPU； 进程的另两种状态——创建态，终止态 创建态：进程创建需要操作系统给他分配内存，创建PCB 终止态：操作系统回收进程拥有的资源同时撤销PCB 进程状态的转换 这里要区分两点，运行态到阻塞态是进程通过系统调用转换成阻塞态，是主动行为；而又阻塞态到就绪态是因为操作系统给他分他想要的资源了，是被动的；还有，不能从阻塞态转回运行态，也不能从运行态转为阻塞态，前者是因为他没有处理机，后者是阻塞态必须是在运行态才能向操作系统请求。 进程控制简单来说，进程控制就是实现进程之间的状态转化。而操作系统一般是通过原语来操作的，原语之前记过，这里只想强调一下他的原子性，就是不可分割，必须一起呵成的执行。用来控制进程转换的原语有(创建原语，撤销原语)，(阻塞原语，唤醒原语)。注意这里我打括号的是成对的意思，就是创建了肯定要撤销，阻塞了肯定要唤醒。下面来细说说 创建原语：申请一个空白PCB，为新进程分配所需资源，初始化PCB，将PCB插入就绪队列 撤销原语：从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程，终止其所有子进程，将该进程的所有资源归还给父进程或操作系统，删除PCB 阻塞原语：找到要阻塞的进程对应的PCB，保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程进行，将PCB插入相应事件的等待队列。 唤醒原语：在事件等待队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度 进程通信顾名思义，进程通信就是指进程之间的信息交换。为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程间的信息交换又必须实现，为了保证进程间的安全通信，操作系统提供了以下方法： 共享存储： 因为各进程的地址是不一样的，但又要进行通信，操作系统就会分配一个共享空间出来，供各进程做读写等操作，需要注意的如下这个例子，进程1和进程2不能同时对共享空间操作，他们俩必须是互斥的。共享存储有两种，基于数据结构的共享速度慢受限制多，比如他可能只能放长度为10的数组，是一种低级的通信方式。但基于存储区的操作就要好很多，在内存中划出一个存储区，数据的形式，存放位置都由进程控制，而不是操作系统，这种通信方式就比较高级。 管道通信： 管道实际上就是可供进程连续读写数据的一个共享文件，又名pipe文件，其实就是内存中开辟的一个缓冲区。但是通道只能是半双工通信，意思就是在某一时间内，他只能是单向的 如果就想实现双向的，就要用两个管道，如下图所示 现在我们就拿只有一个管道的那个说，进程1往管道写时，进程2不能从管道中读，也就是说和上面的共享通信一样，这也得是互斥的，而且每次进程1必须把管道写满了，进程2才能读，同样的，进程2没读空，进程1也不允许写。数据一旦被从管道中读出，就会被管道抛弃，就再也找不回来了，因此读进程只能有一个。 消息传递： 进程间的数据交换是以格式化消息为单位进行传递的,其中消息头中包括发送进程ID,接收进程ID，消息类型等格式化的信息。有了ID就不怕会混了。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。 消息传递有两种方式，直接通信就是发送进程使用发送原语将消息直接挂在到接收进程的消息缓冲队列上，然后接受进程用接收原语接受，消息间接就是操作系统提供了一个信箱，进程们都可以往里面用发送原语存消息，接受的进程通过接收原语就可以接受，因为消息里有消息头，因此不存在弄错的情况]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统调用]]></title>
    <url>%2F2019%2F10%2F15%2F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是系统调用我们知道操作系统要向上提供两种接口，一种是命令接口，一种是程序接口，而程序接口就是由一组系统调用组成，我们可以把系统调用简单的理解为，可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。 系统调用功能 需要注意的是，有的功能是需要特权指令的，因此要在系统调用的相关处理要在核心态下进行 系统调用与库函数的区别 图中黑色箭头表示，我们本该用汇编语言调用系统调用，但现在我们一般都通过调用高级语言的库函数来实现调用系统调用，因为库函数封装好了系统调用。 传递系统调用参数-&gt;执行陷入指令(用户态)-&gt;执行系统调用响应服务程序(核心态)-&gt;返回用户程序 这里需要注意，陷入指令是唯一一个只能在用户态执行而不能在核心态执行的指令 发出用户系统调用请求是在用户态，对系统调用的处理在核心态]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中断和异常]]></title>
    <url>%2F2019%2F10%2F14%2F%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[中断机制的诞生早期的计算机程序只能串行执行，什么意思呢，就是计算机只能处理一个程序，这个程序处理完了，下一个程序才能拿到计算机里来运行，这样就大大降低了资源利用率。为了解决这个问题，人们就发明了操作系统，从而引入了中断机制，实现了多道程序并发执行。事实上，我们只要知道，发生中断就意味着需要操作系统介入，开展管理工作. 中断的概念及作用下面我们大概来看看过程 如图所示，因为中断的引入，我们可以实现多道程序并发执行。我们来模拟一下中断过程， 进程1时间片用完了，计时器向CPU发出中断信号，CPU就会切换为核心态，这个时候就是将管理权交到了操作系统的手上，操作系统的内核就会对中断信号做处理，也就是停止进程1，让进程2运行，处理完之后会用指令再转换成用户态，这个时候进程2就开始运行了；当进程2运行一段时间后，他想输出，但I/O这是特权指令，他就得申请，他就发出系统调用(内中断信号)，这是CPU转到核心态，交给操作系统处理，操作系统会根据进程2的请求，让打印机打印，进程2停止运行去等待打印机，换进程3运行，再转回用户态，这时当打印机完成了，他会向CPU发出中断信号，告诉他自己完成了，CPU又转换为核心态交给操作系统，操作系统就让进程2恢复，完成后续工作。再转成用户态，进程2继续执行。 通过上面的栗子，我们不难看出，只要CPU一收到中断信号，他就要转成核心态，用户程序停止运行，操作系统内核对中断处理完之后，转回用户态，用户程序按操作系统的安排继续运作。 最最最重要的：用户态转核心态，有且仅有中断这一种方法，核心态转用户态是通过执行一个特权指令，将程序状态字的标志位设置为用户态 中断分类 内中断和外中断区别的根本在于中断信号的来源，内中断是来自CPU内部，与当前执行的指令有关，比如说时间片用完了，计时器向CPU发中断信号；外中断来自于CPU外部，与当前执行的指令无关，比如说刚刚的打印机发给CPU它打印结束了。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统概述]]></title>
    <url>%2F2019%2F10%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是操作系统 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。 下面来详细的讲讲操作系统处于中间都做了哪三件事 1）举个例子来解释操作系统作为系统资源的管理者都做了什么 我们要用qq跟朋友视频聊天，首先要找到qq.exe，这是文件管理，我们点击qq，要读取相应的数据，这是存储器管理，运行qq，需要把它放到处理机(CPU)上，这是处理机管理，通过摄像头跟朋友聊天，这是设备管理。 2)操作系统向上要提供一些接口来供调用，具体如下图 3)作为最接近硬件的层次操作系统做了什么呢，我们买回来一个裸机，没有任何软件支持，这时我们给他安上操作系统，操作系统就可以提供资源管理和方便用户的服务功能，将裸机变得更强大，简单点说是什么意思呢，就是操作系统是个很厉害的工匠，他把硬件给打造成各种各样容易使用的工具，这时用户就可以直接使用这些工具而无需去了解硬件到底是怎么工作的 操作系统的特征 并发 并发：指两个或多个事件在同一时间间隔内发生，这些时间宏观上同时发生，微观上交替发生。 这里需要与另一个概念区别一下-并行 并行：指两个或多个事件在同一时刻同时发生。 这怎么理解呢，比如说我们的电脑是四核的，那么我就可以有四个应用并行，但是我们还有一些系统软件他要运行，甚至说，我们一般会打开不止四个软件，那通过我们日常生活我们可以发现，他们都在运行呀，这就是宏观上同时发生，微观里交替发生 共享 共享：系统中的资源可供内存中多个并发执行的进程共同使用 互斥共享我们可以通过举一个日常的栗子来解释一下，比如说我们想同时用微信和qq和朋友们视频聊天，虽然这个进程是可以给微信，qq都使用这个视频资源的，但是在同一时间段内，他只会分给一个进程用，因而会返回给我们另一程序占用摄像头的信息。 同时共享我们也可以举一个小栗子，比如说，我们从qq,微信上下载东西，我们发现他俩都在正常的下载，都在访问硬盘资源，这就是同时共享，但需要注意的是，在微观上，他们还是交替进行的。也有时候在微观上也在同时发生，比如说扬声器同时播放游戏中的音乐和网易云的音乐。 并发和共享的关系 解释一下为啥他俩互为存在条件，我们先来说说没有并发怎么了，同样拿微信和qq来说，如果没有了并发，那么就是说，在同一时间段只有一个程序运行，那么共享就失去了意义。那要是没有共享呢，也就是说我的资源只给一个，那么我另一个程序的不到资源去运行，也就无法并发。 虚拟 先给一个有点难懂的概念-&gt;虚拟就是把物理实体变为若干个逻辑上的对应物。物理实体是客观实在的，逻辑上的对应物是用户感受到的。 emmmmmm举个栗子，比如说我们的电脑只有4GB的内存，单核(物理实体)，但是我的游戏就已经4GB了，我还有qq,网易云。。。等等等等的软件，那他们都能同时运行，我就觉得我的内存远大于4GB,有好几个核，这就是逻辑上的对应物。 那我们再来想想如果没有了并发，我只需要同一时间段内运行一道程序，那就谈不上虚拟性了 异步 异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，并不能一贯到底，而是要走走停停，以不可预期的速度向前推进，这就是进程的异步性。 举个生活中的小栗子，外卖小哥要送好多份外卖，但是路线不一样，有可能顺路，有可能一部分顺路一部分不顺路，那这就是一个并发过程，针对我这份外卖，他只能是这个小哥送-&gt;资源有限，不能一贯到底-&gt;不可预期的速度前进,这就是异步性。 OS发展与分类 运行机制 让我们来捋一捋，操作系统的内核程序是系统的管理者，既可以执行特权指令，又可以执行非特权指令，运行在核心态。应用程序只能执行非特权指令，运行在用户态。那么问题来了，则么判断处理器在哪个状态呢-&gt;程序状态字寄存器(PSW)中某个标志位来标识当前处理器处于哪个状态，如0为用户态，1为核心态。那什么是特权指令什么是非特权指令，简而言之，特权指令就是类似于内存清零这种有危险的指令，非特权指令就是普通的指令，不会对系统造成很严重的影响。 操作系统的体系结构 操作系统的内核最接近硬件，是操作系统最基本最核心的部分，实现操作系统内核功能的那些程序就是内核程序。 首先来看看一些基本概念： 时钟管理：实现计时功能 中断处理：实现中断机制 原语：是一种特殊的程序，处于操作系统的最底层，是最接近硬件的部分；这种程序的运行具有原子性，只能一气呵成的运行，不可中断；运行时间较短，调用频繁。 上图中给出的其实是大内核，还有微内核，因而有的操作系统是大内核，有的是微内核，微内核就是不包括进程管理，存储器管理，设备管理等功能，只保留最基本模块。 可能觉得晦涩难懂，这里举个栗子，把刚起步的公司比作大内核，这个时候公司几乎都是管理层，只有很少的下属，因而大部分工作都是管理层做的，这样就看出来了优点：性能高；接着来，因为分配严重不均，导致管理层做的太多，也就是内核代码庞大，难以维护。 那成立很久的大公司我们就可以把它比作微内核，管理层做的事少了，因而看出优点；再来说缺点，下属做完要来找管理层的确认，管理层确认完了再返回去，如此就是微内核的缺点。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[词法作用域]]></title>
    <url>%2F2019%2F08%2F30%2F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域有两种模型，一种是词法作用域，一种是动态作用域，而js用的就是词法作用域。词法作用域就是在词法化时的作用域，变量及代码块写在哪就是在哪，当词法分析器处理代码时不会改变作用域。 一·词法阶段词法阶段就是词法分析器处理代码的阶段，下面将涉及引擎怎么找想要的变量，还有作用域嵌套中的隐蔽效应，就拿下面一段嵌套作用域来详细讲 12345678function foo(a)&#123; var b = a*2; function bar (c)&#123; console.log(a,b,c); &#125; bar(b*3);&#125;foo(2) //2 4 12 首先划分一下作用域 全局作用域&gt;包含foo所创建的作用域&gt;包含着bar所创建的作用域 这下我们就可以看到嵌套关系 还需要搞清楚的一点就是引擎在查找的时候是逐级向外的，也就是说，他会从最里层开始查找 回到这个例子，引擎来到最里层，也就是包含着bar所创建的作用域，他需要找到a b c这三个变量，可是在这一层他只能找到c，所以他就要去上一级接着找，这时他就找到了a和b 正是引擎的这种查找方式使遮蔽效应诞生了，现在再强化一下查找方式，引擎从最里面一层开始逐层往外查找且找到第一个匹配的就停止查找。也就是说如果我的嵌套作用域里用相同名字的变量，里面的会遮蔽掉外层的变量。 二·欺骗词法 所谓欺骗词法就是修改词法作用域，一种是eval(),一种是with eval()eval()接受一个字符串参数,当执行动态创建的代码时有时可能需要用到拼接，它是在运行期修改书写期。以下面一段代码为例 123456function foo(str,a)&#123; eval(str);//欺骗 console.log(a,b);&#125;var b = 2;foo("var b = 3",1) eval（）是在运行时修改词法作用域的，可以理解成eval写在哪，其中包含的代码就在哪，这样来看，引擎在内部就找到了b就不需要再去外层寻找了。输出结果就是1,3而不是1,2。 需要注意的是，在严格模式下，引擎是不会放过他的，因此会失效，无法修改词法作用域 with with通常被当做重复引用同一对象的多个属性的快捷方式 foo(obj)&#123;123456789101112131415 with(obj)&#123; a=2; &#125;&#125;var o1 = &#123; a:3&#125;;var o2 = &#123; b:3&#125;foo(o1);console.log(o1.a);//2foo(o2);console.log(o2.a);//undefinedconsole.log(a);//2,泄漏到全局作用域 这里着重说一下为什么会泄漏到全局作用域，因为o2没有a,所以在非严格模式下会进行LHS引用，这样就泄漏了 最后需要说一下，欺骗词法作用域了解就好，尽量不要使用，因为会降低性能。而且受严格模式限制。]]></content>
      <categories>
        <category>我不知道的javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是作用域]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一·编译原理javascript是一种“解释执行”语言。它跟传统的编译语言编译时间不一样但编译的步骤基本相似且javascript的要更为复杂。因为与其他编译语言不同，他不需要提前进行编译，就导致了他没有太多时间进行优化，他只是在代码执行前进行几毫秒的编译。所以，他就想各种方法来进行性能优化，比如JIT（延迟编译）甚至实施重编译。 二·3个处理代码的重要角色 引擎：负责编译和执行全过程的 编译器：进行语法分析及代码生成等累活 作用域：收集并维护由所有已声明的标识符组成的一系列查询，并实施一套严格的规则，确定当前代码对标识符的访问权限 有什么角色知道了，现在就来讲讲他们三个是怎样来编译和执行的，就拿一个简单的代码来说 var a = 2 首先，编译器会看所在作用域是否有a,如果没有它就会生成一个a,接下来他就会生成代码提交给引擎 然后引擎拿到代码运行时它会去问作用域是否有这个a，如果有它就会把2赋值给a，如果作用域说没有，他就会接着去找，至于怎么找，下面再详细说。如果引擎怎么找也找不到a，他就会抛出一个异常。 三·LHS与RHS要讲的这两个东西是引擎查找是的两种方式，L就是left,R就是right。下面就拿一段代码来具体理解 123456function foo(a)&#123; var b = a; console.log(a); return a+b;&#125;var c = foo(2); LHS是赋值操作的目标是谁（查找的目的是对变量进行赋值），RHS是赋值操作的源头是谁（查找目的是获取变量的值） 首先c=是赋值操作，所以进行一个LHS，再看调用foo(2)时，因为2是数值而不是变量所以我们不需要去查找他是谁，也就是不需要进行RHS， 再往下走，这个时候就要来到函数体，a我们不知道，所以要获取，就要对foo()进行RHS，然后传参使2赋值给了a(隐式赋值)，那么a就进行了LHS。 再往下走,b=a,这是一个赋值操作所以b就是用了LHS，这个时候还是要查找a，那么就又进行了RHS 接下来需要注意的是，console是个对象，而log是console调用的一个函数,这个时候console是什么我们不知道，所以console要进行RHS，然后还要查找a,所以a也要进行一下RHS 再往下走，a+b中还是要查找a,b,所以要进行两次RHS 四·异常我们为什么要知道LHS和RHS，就是因为引擎用这两种不同的方式会导致不同的处理方式 如果RHS查找怎么也找不到，那么它就会抛出一个ReferenceError的异常 而LHS如果查找不到但是他是在非严格模式下（禁止自动或隐性创建全局变量），那么他就会隐式地创建一个全局变量，如果他在严格模式下，他就会抛出一个TypeError 五·作用域嵌套作用域嵌套其实就是关乎着引擎的查找方式。首先如果引擎在当前作用域没有找到想要的变量，他就会去上一级作用域去找，以此类推，可以把作用域们想象成一栋楼，当前作用域就在一楼，他嵌套的作用域（上级作用域）就以此升高，最高层就是全局变量，引擎也就找到全局变量为止了。 `javascriptfunction foo(a){ console.log(a+b);}var b = 2;foo(2);} 就拿上面的代码来说，我想用b，但是作用域里没有，他就会去外层去找，这里也就是全局变量b了，结果也就可以正常的执行出来]]></content>
      <categories>
        <category>我不知道的javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[map]]></title>
    <url>%2F2019%2F08%2F01%2Fmap%2F</url>
    <content type="text"><![CDATA[map也是种数据结构，他与json，set这两种数据结构相比，更灵活，效率更高 set用来设定值，map的好处在这就能体现出来，就是他的key和value是可以一一对应的任何数据类型，比如下面 1234567let json = &#123; a:1, b:2&#125;let vm = new Map();vm.set(json,5);console.log(vm); 说他一一对应，我当然可以把我想要的value拿出来，这就是get出场的时候啦 1console.log(vm.get(json));//5 删除用delete，全删用clear,查找用has,得长度用size就不细说了…]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Set和WeakSet]]></title>
    <url>%2F2019%2F08%2F01%2FSet%E5%92%8CWeakSet%2F</url>
    <content type="text"><![CDATA[Set和WeakSet都是数据结构而不是数据类型，他俩很相似，前者要放数组在他的数据结构里，后者要放对象在他的数据结构里。而放的方式，两者又有细微的差距。 Set首先看看声明,注意要new一个，只要是new，我们typeof一下就可以知道这是个object,也就说明了set是个数据结构不是数据类型 1let vm = new Set([1,2,3]); 下面看看打印出来的 12console.log(vm);//Set(3) &#123;1, 2, 3&#125; 下面就是关于Set的增删查，这里说一下，Set有一个特性，那就是他去重，当他所包含的数组里有重复的元素，他会自动删掉最后一个重复的，当你查长度时，显示的就是没有重复的长度 先来看看增，回忆一下，在数组操作里，我们增加元素用push，而这里我们用add 12vm.add(4);console.log(vm);//Set(4) &#123;1, 2, 3, 4&#125; 同样如果我们加了一个重复的。根据去重性，最终也不会有两个一样的元素 12vm.add(3);console.log(vm);//Set(3) &#123;1, 2, 3&#125; 下面是删，当我们想删一个时就用delete,全都想删就用clear 1234vm.delete(3);console.log(vm);//Set(2) &#123;1, 2&#125;vm.clear();console.log(vm);//Set(0) &#123;&#125; 接着是查，我们用has,有就返回true，没有就返回false 1console.log(vm.has(3));//true 再就是讲讲遍历 一种用的是for of 123for(let value of vm)&#123; console.log(value);&#125; 另一种是forEach 1vm.forEach(value=&gt;console.log(value)); 然后就是访问长度，在数组用的是length，这里我们用size 1console.log(vm.size); WeakSet我们看一下可以把他拆分成，weak和set，也就是说可以把他理解成弱的set，那么之前说了这个数据结构是用来放对象的，那与set比他弱在哪呢，下面我们来看看 假如我们用同样的方法来声明WeakSet 1let vm = new WeakSet(&#123;a:1,b:2&#125;); 我们会看到他会报错，那这就是他弱的地方，他不能直接把对象放进去，而是要add进去 1234567let vm = new WeakSet();let obj = &#123; a:1, b:2&#125;vm.add(obj);console.log(vm); 再就是注意一下去重这里有点问题 123456789101112let vm = new WeakSet();let obj = &#123; a:1, b:2&#125;let obj1 = &#123; a:1, b:2&#125;vm.add(obj);vm.add(obj1);console.log(vm); 在这个时候他还是会把两个一摸一样的都输出，因为这两个对象的内存不一样的 而下面这种赋值，内存一样，才认为是内容一样，才会去重 123456789let vm = new WeakSet();let obj = &#123; a:1, b:2&#125;let obj1 = obj;vm.add(obj);vm.add(obj1);console.log(vm);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Symbol在对象中作用]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[symbol是ES6中新添加的一种数据类型，他属于原始数据类型，也就是存放在栈中，是按值传递。 首先来看看他的声明方式 1let vm = Symbol(); 我们来看看他的打印，与将他转换成字符串相比，我们可以看到symbol类型的输出的是红体字 123let vm = Symbol('lalala');console.log(vm);console.log(vm.toString); 我们来看看在对象中他用于key值构建的地方,以及在对象中的打印方法 123456let vm = Symbol();let obj = &#123; [vm] ：'liu'&#125;console.log(obj[vm]);//注意这里改变了之前用点方式调用的方式obj[vm] = 'lin';//改变值同样也用中括号 symbol还有一个用处就是他有对数据进行保护的作用 比如，我们用常规的方法来打印对象，我们可以看到对象中每一个元素都被打印出来了 1234let obj = &#123;a:1,b:2&#125;;for(let item in obj)&#123; console.log(obj[item]);&#125; 而如果我们不希望b被打印出来，这个时候就是symbol上场的时候了 1234567891011let obj = &#123;a:1&#125;;let b = Symbol();obj[b] = 2;for(let item in obj)&#123; console.log(obj[item]);&#125;//这个时候b就不被打印出来了//如果我们想打印出来bconsole.log(obj[b]);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象赋值在ES5，如果我们在对象外声明变量，想让他作为对象里的值，我们需要些xx:xx,但在ES6中我们可以直接放进去 1234let a = 1;let b = 2;let ob = &#123;a,b&#125;;console.log(ob); 对象key值构建当key是后台定义的，而不是前台确定的，那当我们使用时只需要一个中括号就可以解决 12345let key = 'a';let ob = &#123; [key]:1&#125;console.log(ob.a); //1 自定义对象方法1234567let ob = &#123; //匿名函数 add:function(a,b)&#123; return a+b; &#125;&#125;console.log(ob.add(1,2)); is比较方法之前比较对象的元素是否相等我们用===，ES6引进了is方法，两者是有区别的，前者是同值相等后者是完全相等 12345678let ob1 = &#123;a:NaN&#125;;let ob2 = &#123;b:NaN&#125;;let ob3 = &#123;c:0&#125;;let ob4 = &#123;d:-0&#125;;console.log(ob1.a===ob2.b);//falseconsole.log(ob3.c===ob4.d);//trueconsole.log(Object.is(ob1.a,ob2.b));//trueconsole.log(Object.is(ob3.c,ob4.d));//true 对象的连接123456let ob1 = &#123;a:NaN&#125;;let ob2 = &#123;b:NaN&#125;;let ob3 = &#123;c:0&#125;;let ob4 = &#123;d:-0&#125;;let ob5 = Object.assign(ob1,ob2,ob3,ob4);console.log(ob5);//&#123;a: NaN, b: NaN, c: 0, d: -0&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数和数组补漏]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84%E8%A1%A5%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[对象的函数解构当后端传来的数据时json对象格式，当我们想要让他作为函数的参数来调用时就可以用到，具体如下所示 123456let json = &#123; a:1, b:2&#125;let func = (&#123;a,b=3&#125;)=&gt;a+b;console.log(func(json));//3 数组的函数解构123let arr =[1,2,3];let func = (a,b,c)=&gt;console.log(a,b,c);func(...arr); //1 2 3 inin的用处主要在于判断对象或数组里是否有元素，先来看看对象 12345let json = &#123; a:1, a:2&#125;console.log('a' in json);//true 关于数组，并不能确定有没有某个元素，但能确定某索引位置是否有元素，而在ES5我们知道，当我们用.length来查看是否有元素时，如果是空就会返回0，这显然是错误的，下面我们来看看ES6 12let arr = ['','',''];console.log(0 in arr);//true 数组循环方法 forEach 这种方法会自动忽略掉空的情况，因此有的时候会出错 12let arr = ['1','2','3'];arr.forEach((val,index)=&gt;console.log(index,val)); //注意顺序不能颠倒了 filter 12let arr = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];arr.filter(x=&gt;console.log(x));//1 2 3 some 12let arr = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];arr.some(x=&gt;console.log(x));//1 2 3 map map是一种转换方法，详细的以后再说 12let arr = ['1','2','3'];console.log(arr.map(x=&gt;'4')); //4 4 4 将数组转换成字符串首先是toString(),他只能将数组各个元素用逗号隔开 12let arr = ['1','2','3'];console.log(arr.toString()); //1,2,3 如果我们想用其他字符隔开各个元素，就可以使用join() 12let arr = ['1','2','3'];console.log(arr.join('|'));//1|2|3]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[箭头函数和扩展]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[默认值在ES6中给我们提供了可以在函数参数中使用默认值的操作，在学习箭头函数之前就先用ES5方法写函数 1234function func(a,b=0)&#123; return a+b;&#125;console.log(func(1)); //1 主动抛出错误只需要一行代码 throw new Error(‘’) 1234567function func(a,b=0)&#123; if(a==0)&#123; throw new Error('This is a error') &#125; return a+b;&#125;console.log(func(0)); //报错提示 This is a error 严谨模式与ES5不同，ES6中严谨模式的代码不需要必须写在最前面，而是可以写在函数体内，但是需要注意的是当函数参数有默认值时是会报错的，下面我就来举个错误实例，然后给出报错信息，我们可以很清楚的看出是因为默认值 12345function func(a,b=0)&#123; 'use strict' return a+b;&#125;console.log(func(1)); ; 获得参数个数当我们需要知道参数个数是，很简单，直接用length就可以知道，但是需要注意的是得到的只是必须传递的参数个数，带默认值的不包括在内 1234function func(a,b=0)&#123; return a+b;&#125;console.log(func.length); //1 箭头函数箭头函数需要注意的就是如果你只想返回(return)一个值，就不需要用花括号，直接用箭头指向那个值即可，但是当代码不止一行时就需要用花括号来包住函数体，下面举个只返回个值得来看看箭头函数长什么样.还有就是箭头函数不能有new ,也就是说不能用在构造函数上 12let func = (a,b)=&gt;a+b;console.log(func(1,1)); //2]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组知识]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%95%B0%E7%BB%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[在ES6中新增了一些数组方法来简化代码量。ES6把所有对数组的操作都归结与Array. json数组格式转换首先来看看json格式，要注意与普通的json不一样的是必须后面要跟一个length 123456let json = &#123; '0' : 'aaa', '1' : 'bbb', '2' : 'ccc', length: 3&#125; 下面我们只需一步就可以把它打印成数组形式，那就是调用from方法 12let arr = Array.from(json);console.log(arr); // ["aaa", "bbb", "ccc"] Array.of()of方法可以用于将一堆变量或字符串转化成数组的情况下。 12let arr = Array.of('1','2','3');console.log(arr); //["1", "2", "3"] find 实例方法find(function(value,index,arr){})三个参数缺一不可，用于寻找元素，比如 1234let arr = [1,2,3,4,5,6,7];console.log(arr.find(function(value,index,arr)&#123; return value&gt;4; //5&#125;)) 函数里的函数体根据需要写,当然不仅是数字，也可用来查找字符串。 fill实例方法fill方法是用来替换数组中元素的，他有三个参数，分别是替换值，起始位置(包括)，末位置(不包括)，栗子如下(实例方法由实例调用而不是Array.) 12let arr = [1,2,3,4,5,6,7];console.log(arr.fill(0,0,4)); //0000567 数组遍历在ES5中遍历数组我们采用的形式低效，ES6给我提供了高效的方式，如下所示 1234let arr = [1,2,3,4,5,6];for(let value of arr)&#123; console.log(value);&#125; 当我们想得到索引时可以这样 1234let arr = [1,2,3,4,5,6];for(let index of arr.keys())&#123; console.log(index);&#125; 当我们需要索引和元素一起打印时可以这样 1234let arr = [1,2,3,4,5,6];for(let [index,value] of arr.entries())&#123; console.log(index+':'+value);&#125; entries()实例方法当我们想要数组里的元素不按常规形式输出，而是想要像输出一个元素就来个一行样式 123let arr = [1,2,3,4,5,6];let list = arr.entries();console.log(list); //Iterator &#123;&#125; 这样我们就得到了Iterator {}，然后就可以用next手动循环 123456console.log(list.next().value);console.log('----------------');console.log(list.next().value);console.log('################');console.log(list.next().value);console.log('----------------');]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数字的操作]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E5%AD%97%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[ES6中将数字的方法都用Number.来开始，因为这样随着以后的完善可以扩展出很多但是又都归结于Number.下面先回顾下二进制，八进制，再介绍些可以直接用的很方便的方法 二进制(binary)的声明，在js中二进制都是以0B(0b)开头的. 12let binary = 0B010101;console.log(binary); //21 八进制(Octal)的声明，在js中八进制都是以0o(0O)开头的 12let octal = 0o666;console.log(octal); //438 判断是否为数字类型 12let vm = 23;console.log(Number.isFinite(vm)); //true 判断是否为整数 12let vm = 23;console.log(Number.isIneger(vm)); //true 转化为整型 12let vm = 23;console.log(Number.parseInt(vm)); //true 转化为浮点型 12let vm = 23;console.log(Number.parseFloat(vm)); //false 最大安全整数 1console.log(Number.MAX_SAFE_INTEGER); //9007199254740991 最小安全整数 1console.log(Number.MINI_SAFE_INTEGER); //-9007199254740991 判断是否超过安全范围 12let vm = Math.pow(2,53)-1; //最大安全整数console.log(Number.isSafeInteger(vm)); //true]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串操作]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符串的操作是很重要的，但ES5的方法容易出错还比较麻烦，ES6的字符串模板，字符串查找，字符串复制就很好的解决了这些问题。 字符串模板 简单的拼接，在ES5中我们想将几个字符串拼接起来就要用到+运算符和单引号，很容易因为哪块漏写单引号，加好位置不对出错，ES6中就引进了 1`$&#123;&#125;` 来简化拼接过程，中间不再需要单引号进来搅和，只需要把要被拼接的内容放在花括号里即可，具体看下面的栗子 123let vm1 = 'ES6';let vm2 = `发现$&#123;vm1&#125;很好学`;console.log(vm2); 支持数字计算,如下面的栗子，因为我没有把1,2用单引号包起来，ES6就会把他们当数字处理，就不会输出12，而是3。而在ES5中就要注意了，不能简单地用加号连接两个变量来得到和。 1234let vm1 =1;let vm2 = 2;let vm3 = `$&#123;vm1+vm2&#125;`console.log(vm3); 字符串查找在ES5中我们想判断字符串里有没有我们想要的东西要先用indexOf找一下再用大于零或者小于零才能得到true还是false，很麻烦，而ES6中很简单的就能得到,而且支持中文 123let v = '大连'let vm = "welcome to 大连";console.log(vm.includes(v)); 这里说一下，要先定义一个要查找的变量，而不是想当然的直接就能vm.includes(大连) 字符串复制当需要重复写很多东西时应用ES6就可以简简单单的代码完成这个任务,栗子如下 1document.write('大连|'.repeat(5));]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[扩展运算符和rest运算符]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[扩展运算符和rest运算符都是三个点…,可以当做没什么区别，但各有各的用处。 扩展运算符 第一个用处就是在定义函数时不知道有几个参数，这个时候扩展运算符就可以登场了,下面的arg只是表示参数的意思，可以改成其他字符 1234567function func(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);&#125;func(1,2,3); 输出的结果是1,2,3,undefined。 看看转换成的ES5语法，真的为我们简化了很多东西 1234567function func() &#123; console.log(arguments.length &lt;= 0 ? undefined : arguments[0]); console.log(arguments.length &lt;= 1 ? undefined : arguments[1]); console.log(arguments.length &lt;= 2 ? undefined : arguments[2]); console.log(arguments.length &lt;= 3 ? undefined : arguments[3]);&#125;func(1, 2, 3); 而且我们可以看到他考虑到了undefned，就不会引起报错，如果我们用常规的ES5写，像下面这样，就会引发报错 1234567function func(a, b, c) &#123; console.log(a); console.log(b); console.log(c); console.log(d);&#125;func(1, 2, 3); 第二个用处就是在赋值数组的时候，其实在ES5中我们以为的赋值数组并不是赋值，他没有分配新的内存空间，可以理解为C++中的引用，当我们改变被赋值的数组，实际上我们不希望原来的数组也被改变，但是他会被改变，而用了ES6的对象扩展运算符就能很好的解决这个问题。 12345let arr1 = [1,2,3];let arr2 = [...arr1];arr2.push(4);console.log(arr2);console.log(arr1); 这时打印结果就是我们想看到的。而如果用ES5的方法(arr2 = arr1),arr1也会被改变，因此使用扩展运算符避免了很多麻烦，不报错的逻辑问题才是最可怕的。 rest运算符rest是剩下的意思，那他的用途跟扩展运算符不太一样的就是当参数你已知前面的几个后面不知道的时候就是rest上场的时候 1234567function func(first,...arg)&#123; console.log(arg.length); for(let val of arg)&#123; console.log(val); &#125;&#125;func(1,2,3,4,5); 这样我就能得到我除了已知的剩下的有几个参数，分别是什么。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[解构赋值就是把变量（数组，对象，字符串中的元素拿出来）-&gt;解构，再赋值，应用很多，还在初学阶段就只是把它结构出来打印下来还不会应用 数组解构赋值数组解构两边格式要对应，举个栗子 我们来看看正确的范例 12let [a,[b,c],d] = [1,[2,3],4];console.log(b); 下面是转换出来的ES5代码，看上去很和谐，打印出来的是我们想要的结果-&gt;2 123456var a = 1, b = 2, c = 3, d = 4;console.log(b); 下面是错误范例 12let [a,[b,c],d] = [1,2,3,4];console.log(b); 下面是转换好的ES5代码，我们可以看到相当的不和谐 12345678var _ref = [1, 2, 3, 4], a = _ref[0], _ref$ = _slicedToArray(_ref[1], 2), b = _ref$[0], c = _ref$[1], d = _ref[2];console.log(b); 下面再来看看赋默认值，这里着重讲一下undefined和null，当你赋值成undefined就是什么都没有的意思，并没有覆盖掉默认值，而你赋值成null则返回的就是空null，他会覆盖掉你的默认值，再就是当你又没给默认值又没赋值时输出的是undefined 12let [a,b=2] = [1,null];console.log(b); 打印出来的是null 12let [a,b=2] = [1,undefined];console.log(b); 打印出来的是2 对象解构赋值对象的解构赋值与数组的不同就在于他不是顺序的，必须要前后名字一样才能对应上，数组后面我们知道是没有名字的，栗子如下 12let &#123;a,b&#125; = &#123;a:1,b:2&#125;;console.log(b); 输出的结果是2 12let &#123;a,c&#125; = &#123;a:1,b:2&#125;;console.log(b); 这时将报b is undefined的错 接下来是一个容易出错的地方，就是如果你是先定义了变量后来才对他解构赋值，那对于这个报错，一个括号就可以解决 123let a;(&#123;a&#125;=&#123;a:1&#125;);console.log(a); 结果如你所愿会打印出1 字符串解构赋值字符串解构赋值并不常用但存在就有他存在的道理，这里简单的写个栗子 12let [a,b,c] = 'xue';console.log(a); 结果也是如愿的x，这里说一下能用单引就用单引，可以减少解析时的负担。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[声明方式]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在ES5中声明变量只有var一种形式，是局部啊还是全局啊很麻烦去区别。ES6就将声明方式升级了那么一下子，全局用var，局部用let,常量用const 一· const先来说说这个const,因为我想把let和var放在一起来讲。const嘛，C++里也有，大家都知道这是声明常量的，就是有一个量你不想动他，但是可能时间长了你忘了我之前想的是不能动他，这个时候如果当初你早早的就把他用const方式声明他就不怕犯错啦。一动就报错，下面举个栗子看看 123const a = 1;var a = 2;console.log(a); 我们可以看到我先把a给用const形式声明了，接下来我用全局var方式要把a给改了，这个时候我打印a，人家我npm run build都不给我转换成功了，报错如下 这样就规避了很多麻烦，报错比不报错好多了。 二· let与var接下来就是let和var这两个方式了，这两种方式各有各的好处，但是推荐去尝试多用用let，因为这样在一些函数体里呀，循环里呀，你用了局部的形式不至于找不到错误找好久，因为你用局部的了，后面你做错事了他会给你报错。有报错信息，找错误就方便很多。在这里我就不证明var是全局的,let是局部的了。我写一个栗子。像在C++里我再循环里声明了一个i，他是局部的，我拿出来就不能用了，这个循环之后我还可以声明一个i，但是不影响我之前那个循环里的i，我不污染数据。想想在js里，我要是用var，好多循环，我都用i，然后循环外部我有把i改来改去是不是就乱套了。 1234for(let i=0;i&lt;10;i++)&#123;console.log(i);&#125;console.log(i); 我们看到找不到i,这就是用let的好处,局部就是局部，谁也动不了。下面再看看npm run build后也给我们人性化的区分了一下。 1234for (var _i = 0; _i &lt; 10; _i++) &#123; console.log(_i);&#125;console.log(i);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[环境搭建]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ES6有很多新特性简化了一些东西，但是因为还是有浏览器不兼容他，因此环境搭建就包括了将ES6转换成ES5以及简化转换命令 首先看看初始的文件目录 src下的index.js使我们写ES6代码的地方 dist是用来存放转换好的es5代码的地方 index.html是入口文件，要引入的是src目录下的js文件 1&lt;script src="dist/index.js/"&gt;&lt;/script&gt; 初始化项目 1npm init -y -y是直接生成项目的操作，就不用你一步步确认来修改项目，在执行完该命令后会生成一个package.json，可以自行改一下author,discription这两项 基本配置 全局安装babel-cli 1npm install -g babel-cli 本地安装babel-preset-es2015 和 babel-cli 1npm install --save-dev babel-preset-es2015 babel-cli 在根目录下新建.babelrc 123456&#123; "presets":[ "es2015" ], "plugins":[]&#125; 这时就可以用命令来讲我们写好的ES6转换成ES5 1babel src/index.js -o dist/index.js 到目前为止，我们的目的已经达到了，但是我想不要每次都输那么长的命令来转换，我们可以讲package.json中的&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;修改为&quot;build&quot;:&quot;babel src/index.js -o dist/index.js&quot; 以后就可以直接用npm run build来转换]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[actions]]></title>
    <url>%2F2019%2F06%2F03%2Factions%2F</url>
    <content type="text"><![CDATA[actions虽然功能上和mutations一样都是修改状态的，但mutations是同步的，actions是异步修改状态，那什么是异步，就好像你在网上购物付完款了你就什么不用管了，想做什么做什么，而你买的东西则会被卖家按部就班的操作最后运输到你面前，而同步就好像是你在商场买电器，必须等店员去仓库取货然后跟着你回家，你才能做其他事。在编程中，同步就是你必须执行完我这个步骤你才能往下走，就像mutations的操作，而actions是我调了之后会像是在另一个支路去完成我要的这个任务，而我本来的这个支路就可以接着往下走 1import &#123;mapState, mapMutations,mapActions&#125; from 'vuex' 1234methods: &#123; ...mapMutations(['add', 'reduce']), ...mapActions(['addAction','reduceAction']) &#125;, 12&lt;button @click="addAction"&gt;+&lt;/button&gt; &lt;button @click="reduceAction"&gt;-&lt;/button&gt; 123456789101112const actions = &#123; addAction(context)&#123; context.commit('add',10); setTimeout(()=&gt;&#123;context.commit('reduce',1)&#125;,3000); console.log("我比reduce先执行"); &#125;, reduceAction(&#123;commit&#125;)&#123; commit('reduce',1) &#125;&#125;//context：上下文对象，这里你可以理解称store本身。//&#123;commit&#125;：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。 需要注意的是这里我们加了个验证异步，你可以看到就算没执行setTimeout，控制台还是马上输出了]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[getters]]></title>
    <url>%2F2019%2F06%2F03%2Fgetters%2F</url>
    <content type="text"><![CDATA[getters实际上就是对数据进行的一种提前处理加工过滤，就像之前那加减按钮那个例子，我就可以用getters让她每次进行加减之前先加12 12345678910const getters = &#123; count:function(state)&#123; return state.count+=12; &#125;&#125;export default new Vuex.Store(&#123; state, mutations, getters&#125;) 1import &#123;mapState, mapMutations, mapGetters&#125; from 'vuex' 12345computed: &#123; ...mapState(['count']), ...mapGetters(['count']) &#125;, 注意这里用到的…是es6语法，为了避免前面的被后面的覆盖掉,而且我直接用的mapGetters这个简写方法了]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mutations修改状态]]></title>
    <url>%2F2019%2F06%2F03%2Fmutations%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[首先说一下传值 12345678const mutations = &#123; add(state,num)&#123; state.count+=num &#125;, reduce(state,num)&#123; state.count-=num &#125;&#125; 12&lt;button @click="$store.commit('add',2)"&gt;+&lt;/button&gt;&lt;button @click="$store.commit('reduce',3)"&gt;-&lt;/button&gt; 然后跟上篇一样在调用的时候写法太烦，类似的我们用mapMutations 12 import &#123;mapState,mapMutations&#125; from'vuex'methods:mapMutations(['add','reduce']), 12&lt;button @click="add(1)"&gt;+&lt;/button&gt;&lt;button @click="reduce(1)"&gt;-&lt;/button&gt;]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[state访问状态对象]]></title>
    <url>%2F2019%2F06%2F02%2Fstate%E8%AE%BF%E9%97%AE%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在之前的小栗子里虽然已经可以实现功能，但是在接受数据时，那么一大长串很烦，下面就用三种方法可以直接写花括号就能访问，其中第三种是最常用的 第一种 123456computed:&#123; //这是es6语法，就是个函数 count()&#123; return this.$store.state.count &#125; &#125; 第二种 先引入mapState 12import &#123;mapState&#125; from 'vuex'//注意一定不能忘了花括号 12345//对象&#123;&#125;computed:mapState(&#123; //es6中的箭头函数 count:state=&gt;state.count &#125;) 第三种,采用数组形式[]，同样也要先引入mapState 1computed:mapState(['count'])]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex入门]]></title>
    <url>%2F2019%2F06%2F02%2Fvuex%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[vuex是专门为vue服务的管理状态的一个东西，也可以说是管理data中需要共用的属性，下面这个小栗子就是个入门，里面的很多东西具体的意思会在后面补充，也许这个栗子做完之后会觉得比以前做的麻烦，但是我们主要是想用一个公共的思想他可以被任意一个component调用 怎么安装vuex就不说了，首先在src下建一个vuex文件夹，在它下面建一个store.js来做仓库，以后我们主要就在这个下面引入vuex的操作，剑豪之后首先引入vue和vuex 12import Vue from 'vue';import Vuex from 'vuex'; 再加一行代码就可以使用vuex了 1Vue.use(Vuex); 在仓库中放共用的数据，state也可以说是状态 123const state = &#123; count:1&#125; 加两个方法，这里就放在可修改的mutations里 12345678const mutations = &#123; add(state)&#123; state.count++ &#125;, reduce(state)&#123; state.count-- &#125;&#125; 暴露出去 1234export default new Vuex.Store(&#123; state, mutations&#125;) 要注意mutations是固定写法 下面就要在想应用vuex的组件里动手了 123456789&lt;div&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;hr /&gt; &lt;p&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/P&gt; &lt;button @click="$store.commit('add')"&gt;+&lt;/button&gt; &lt;button @click="$store.commit //注意必须写单引号才行 ('reduce')"&gt;-&lt;/button&gt;&lt;/div&gt; 注意调用的写法 1234567891011121314&lt;script&gt; import store from '@/vuex/store' //注意是写在暴露前面的 export default&#123; name:'Hi1', data()&#123; return&#123; message:'Hello Vuex!' &#125; &#125;, store //在data后 &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vuex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程式导航]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[编程式导航就是取代router-link方法来写导航，他是运用javascript逻辑来写，这里常用的就是前进后退到某一页 123&lt;button @click="goForward"&gt;前进&lt;/button&gt;&lt;button @click="goBack"&gt;后退&lt;/button&gt;&lt;button @click="goHome"&gt;回首页&lt;/button&gt; 123456789101112methods:&#123; goForward:function()&#123; this.$router.go(1); &#125;, goBack:function()&#123; this.$router.go(-1); &#125;, goHome:function()&#123; this.$router.push('/'); //注意这里是push不是go了，然后里面写什么路径就能跳到哪了 &#125; &#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由中的钩子函数]]></title>
    <url>%2F2019%2F05%2F28%2F%E8%B7%AF%E7%94%B1%E4%B8%AD%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[路由中的钩子函数我们一般只用两种，他们可以写在index.js中，也可写在模板，但是写在index.js中只能写beforeEnter不能写离开的钩子函数，而且在模板里能写两个都要在中间加一个Route,无论哪种书写方式，都要注意是使用三个参数的箭头函数，一定要写next(),它相当于一个开关，有了他才能接着跳转 index.js 12345beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125; Hi.vue 12345678910beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125;, beforeRouteLeave:(to,from,next)=&gt;&#123; console.log(to); console.log(from); next(); &#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mode设置和404处理]]></title>
    <url>%2F2019%2F05%2F28%2Fmode%E8%AE%BE%E7%BD%AE%E5%92%8C404%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先此mode非彼mode，这里的mode 是指在用户浏览器你上url形式的,如果喜欢简洁的就用history,如果要有井号的就用hash全品个人喜好，那就在index.js下引入mode 1mode:'history'//或hash 404处理就是在用户输错地址或者你自己随便写个to到标签是错的，为了更好的用户体验而设置的 index.js 1234&#123; path:'*',//*就表示404页面 component:Error//写这步就意味着要建个Error.vue和import一下&#125; Error.vue 12345678910111213141516&lt;template&gt;&lt;div&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;h2&gt;找不到此页面&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'Error', data:function()&#123; return&#123; message:'Error:404' &#125; &#125; &#125;&lt;/script&gt; App.vue 1&lt;router-link to="/sdfgsadh"&gt;我是瞎写的&lt;/router-link&gt;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由过渡动画]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%B7%AF%E7%94%B1%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[路由过渡动画就是在切换路由的时候加点动画效果，这里就是把router-view用transition包起来，然后给他个name叫fade， 然后fade有四个类名，就通过这四个类名给路由加动画即可，更酷炫的效果需要有css和js功底，当然也可以用插件，然后还有个mode属性,他只有两个值，一个是in-out一个是out-in顾名思义就知道什么意思了，这里我们用out-in更好看一点 123&lt;transition name="fade" mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 12345678910111213.fade-enter &#123; opacity:0;&#125;.fade-leave&#123; opacity:1;&#125;.fade-enter-active&#123; transition:opacity 0.5s;&#125;.fade-leave-active&#123; opacity:0; transition:opacity 0.5s;&#125;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[alias别名]]></title>
    <url>%2F2019%2F05%2F27%2Falias%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[alias别名的作用与redirect的重定向差不多，只不过alias更友好一点，他不会在用户那边地址栏上把url改了 index.js 123456&#123; path: '/Hi1', name: 'Hi1', component:Hi1, alias:'/liu'&#125; App.vue 12&lt;router-link to="/Hi1"&gt;Hi1&lt;/router-link&gt;&lt;router-link to="/liu"&gt;goHi1&lt;/router-link&gt; 还有一个坑要说一下，就是不要再根目录(path:’/‘)下用别名，会出错]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重定向]]></title>
    <url>%2F2019%2F05%2F27%2F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[重定向实质上就是在路径不同的情况下我想跳转到同一页面的需求，下面将展示传参数和不穿参数的两种重定向，操作很简单,在index.js中就是把想要定位的路径复制到redirect里 index.js 1234567 &#123; path: '/gohome', redirect:'/' &#125;,&#123; path: '/gohi/:newsId(\\d+)/:newsTitle', redirect:'/Hi/:newsId(\\d+)/:newsTitle'&#125; 尤其要注意的是千万不要多写个name App.vue 12&lt;router-link to="/gohome"&gt;回首页&lt;/router-link&gt;&lt;router-link to="/gohi/34/aaaam"&gt;Hi&lt;/router-link&gt;]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL传值]]></title>
    <url>%2F2019%2F05%2F27%2FURL%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[虽然现在前后端分离，之间的数据传递用接口，但是url传值方法还是很常用的 第一步：在index.js文件的路径中添加想传的值 12345&#123; path: '/Hi/:newsId(\\d+)/:newsTitle', name: 'Hi', component:Hi&#125; 可以看到我只需要在path后加:/就好，同时还用()方式在里面加了个正则表达式，规定只允许传递过来的是数字，当非数字时就不显示 第二步：在App.vue中通过router-link传递值 1&lt;router-link to="/Hi/12/hhhhhh"&gt;Hi&lt;/router-link&gt; 注意到，我的id传的是数字才行 第三步：在Hi.vue中接收值 12&lt;p&gt;&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; $route.params.newsTitle &#125;&#125;&lt;/p&gt; 特别要注意的是，只能是params，别写成Hi了，因为在vue中params就是用来传参数的量]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单页面多路由]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%A4%9A%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue提供的路由非常方便我们把页面分开成几个部分分别操作，下面就动手简单做一个第一步：在App.vue中加两个路由，为了方便看效果，简单分别给他们写个内联样式 123&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name = "right" style="background-color:red;width:50%;height:100px;float:right"&gt;&lt;/router-view&gt;&lt;router-view name = "left" style="background-color:black;width:50%;height:100px;float:left"&gt;&lt;/router-view&gt; 注意只能有一个路由不写name，他是默认值defaut 第二步：在index.js配置路由，import就不多说了，只要加路由必须写import才能生效 123456789&#123; path: '/', name: 'HelloWorld', components: &#123; default:HelloWorld, right:Hi1, left:Hi2 &#125; &#125; 注意这里的坑，要把component改成components,conponents对象里的都没有引号 至此，单页面多路由我们就做出来了，但是再深化一下，我们再加个导航，实现让两个路由调换一下位置，这主要是之前的知识，直接放一下代码 index.js 12345678&#123; path: '/Hi', name: 'Hi', components: &#123; default:Hi, right:Hi2, left:Hi1 &#125; App.vue 1234&lt;div&gt; &lt;router-link to="/"&gt;首页&lt;/router-link&gt;| &lt;router-link to="/Hi"&gt;Hi&lt;/router-link&gt;&lt;/div&gt; 结果图：]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[参数传递]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[vue-router中提供了两种传参方式，一种是name传递法，另一种是绑定to的传递方法。第一种不常用,因为第一种的name实际上用在第二种的参数上 name传值法 第一步：完善name 在上个博客我们配置了index.js，他是这样的 123456789101112131415161718export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', name:'Hi', component:Hi, children:[ &#123;path:'/',component:Hi&#125;, &#123;path:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 现在我们要把它写成这样的 1234567891011121314151617export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', component:Hi, children:[ &#123;path:'/',name:'Hi',component:Hi&#125;, &#123;path:'Hi1',name:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',name:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 因为如果我们不把这个name给完善了会报错，首先Hi1,Hi2没有name更别说传值了，其次在vue中，当一个路由有了子路由，并且子路由中有一个是自己本身，那么这个路由写的name将不起作用，所以应在子路由里写上他的name 第二步：在App.vue上插值来接收值 1&lt;p&gt;&#123;&#123;$route.name&#125;&#125;&lt;/p&gt; 绑定to传值 第一步：在App.js上动手 1&lt;router-link :to="&#123;name:'Hi1',params:&#123;username:'liuxue'&#125;&#125;"&gt;Hi1页面&lt;/router-link&gt; 注意看这里才是name真正的用武之地啊。还有vue中统一用params来传递参数，他是一个对象形式 第二步：在Hi.vue上接收值 1&lt;p&gt;&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt; 多一嘴，一定要记得在.vue里面写的都是大的套小的形式，一定要放在个div里才行 现在来看看综合商量个博客实际的效果，就拿Hi1来分析分析一下 可见vue的父子关系多么清晰，一定是先入口文件再父文件再子文件]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[子路由]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%AD%90%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[子路由的应用可以说还是很广的，也就是说当我给某个组件设置了子路由，那么每当我点击这个子路由，这个组件都会显示，就好像淘宝里的推荐，当我选中一类时他会给你推荐相似的，而我这一类会一直留在界面上，只是在下面展示我的各个子路由，下面就来操作一下子路由的配置方法 第一步： 还是新建新的组件，就不多说了第二步：去到要配置子路由的组件123456&lt;template&gt; &lt;div class="Hi"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 一定一定要注意我们引入路由机制的这个标签位置很重要，他必须写在一个有内容的的大标签里（这里是div），不然你一写这个标签就会疯狂报错 第三步：去index.js配置123456789101112131415161718192021222324252627import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Hi from '@/components/Hi'import Hi1 from '@/components/Hi1'import Hi2 from '@/components/Hi2'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path:'/Hi', name:'Hi', component:Hi, children:[ &#123;path:'/',component:Hi&#125;, &#123;path:'Hi1',component:Hi1&#125;, &#123;path:'Hi2',component:Hi2&#125; ] &#125; ]&#125;) 首先：一定要import 然后就去写子路由器配置了，他是写在指定的那个component底下，他也是个数组，根据每个路由都是一个对象相应的去写，因为现在还用不上name，所以这里先省略了name，特别要注意的是，path的写法，后两个是没有/的 第四步：去入口文件App.vue改写模板123456&lt;div&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/Hi&quot;&gt;Hi页面&lt;/router-link&gt; &lt;router-link to=&quot;/Hi/Hi1&quot;&gt;Hi1页面&lt;/router-link&gt; &lt;router-link to=&quot;/Hi/Hi2&quot;&gt;Hi2页面&lt;/router-link&gt; &lt;/div&gt; 实际上就是加了后两行]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F05%2F26%2Fvue-router%2F</url>
    <content type="text"><![CDATA[vue-router是vue的很重要的一部分，他不是物理的那种路由器啊啥的，可以把他理解为像a标签，但是因为vue-cli开发出来的实际上是单页面应用，所以用a标签是不够用的，因此vue帮我们配置了这么一个功能，首先就先了解一下要用到的几个重要文件 配置文件讲解 components这是vue的公共组件他的格式是: 123456789101112131415&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: '', data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/*scoped代表只给这个页面设的css样式,否则将应用到所有页面*/&lt;/style&gt; App.vue这是页面的入口文件，也就是主页面，你引入东西都得放进去才能显示，也就是前面提到的单页面应用的那个单页面 123456789101112131415161718192021222324&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 说明引入路由机制，在印后的配置子路由时会用到也就是说把它加在哪个页面，哪个页面就可以使用路由机制 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; index.js是router下的文件也就是配置路由的文件 12345678910111213141516import Vue from 'vue' //引入Vueimport Router from 'vue-router'//引入bue-routerimport HelloWorld from '@/components/HelloWorld'//引入根目录下的HelloWorld.vue组件Vue.use(Router)//Vue全局使用Routerexport default new Router(&#123; routes: [//配置路由，这里是数组，每个链接都是一个对象 &#123; path: '/',//链接路径 name: 'HelloWorld',//路由名称 component: HelloWorld//对应组件模板 &#125; ]&#125;) 下面进入正题，我们自己来写路由，也就可以写个导航啦，下面一起来看看三步走 第一步：新建新的组件在components下新建个Hi.vue，里面内容直接复制稍微改下，因为我们就是想学学这个，所以就把msg改改，class，name改改就好了。至此，第一步就走完了 第二步：配置index.js路由12345678910111213141516171819202122import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Hi from '@/components/Hi'// 直接复制上面的改改就行了Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; // 说白了就是新建个对象，剩下的改改就行了 path:'/Hi', name:'Hi', component:Hi &#125; ]&#125;) 第三步：在App.vue引入我们新写的组件12345678910&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;div&gt; &lt;router-link to="/"&gt;首页&lt;/router-link&gt; &lt;router-link to="/Hi"&gt;Hi页面&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 注意两个点，第一个：应该用div包着这两个，因为这样既起了换行作用，又符合vue的大的包小的原则；第二个：这里面有陌生的标签，这个标签可以把他理解成a标签，这就是vue给我们准备好的，尤其注意to里面的路径必须和index.js中写的path一样]]></content>
      <categories>
        <category>vue-router</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义组件]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;liuxue&gt; &lt;!-- 用 key value形式传递数据 --&gt; &lt;p slot="url"&gt;&#123;&#123;liuxueData.url&#125;&#125;&lt;/p&gt; &lt;p slot="name"&gt;&#123;&#123;liuxueData.name&#125;&#125;&lt;/p&gt; &lt;p slot="skill"&gt;&#123;&#123;liuxueData.skill&#125;&#125;&lt;/p&gt; &lt;/liuxue&gt; &lt;/div&gt; &lt;template id="liu"&gt; &lt;!-- Vue2.0规定必须用大的包个小的 --&gt; &lt;div&gt; &lt;!-- 接收数据 --&gt; &lt;p&gt;博客地址：&lt;slot name="url"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;slot name="name"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;技能：&lt;slot name="skill"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var liuxue = &#123; template:'#liu' &#125; var app = new Vue(&#123; el:'#app', data:&#123; liuxueData:&#123; url:'snowFlakeXue.github.io', name:'liuxue', skill:'前端' &#125; &#125;, components:&#123; 'liuxue':liuxue &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实例事件]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在构造器外添加事件$on 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;button @click="add"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;button onclick="reduce()"&gt;reduce&lt;/button&gt;&lt;/p&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++ &#125; &#125; &#125;) app.$on('reduce',function()&#123; this.count--; console.log('构造器外方法被调用') &#125;) function reduce()&#123; app.$emit('reduce') &#125; //当按钮在作用域外用$emit调用 once事件$once 1&lt;p&gt;&lt;button onclick="reduceOnce()"&gt;reduceOnce&lt;/button&gt;&lt;/p&gt; 1234567app.$once('reduceOnce',function()&#123; this.count--; console.log('只执行一次的方法被调用') &#125;) function reduceOnce()&#123; app.$emit('reduceOnce') &#125; off事件$off 1&lt;p&gt;&lt;button onclick="off()"&gt;off&lt;/button&gt;&lt;/p&gt; 123function off()&#123; app.$off('reduceOnce') &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实例方法]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;button onclick="destroy()"&gt;销毁&lt;/button&gt; &lt;button onclick="reload()"&gt;更新&lt;/button&gt; &lt;button onclick="tick()"&gt;修改&lt;/button&gt; &lt;script&gt; var app = Vue.extend(&#123; template:`&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`, data: function()&#123; return &#123; message:'hello world' &#125; &#125;, mounted:function()&#123; console.log('我被挂载了') &#125;, destroyed:function()&#123; console.log('我被销毁了') &#125;, updated:function()&#123; console.log('我被更新了') &#125; &#125;) //挂载方法 var vm = new app().$mount('#app'); //销毁方法 function destroy()&#123; vm.$destroy(); &#125; //更新方法 function reload()&#123; vm.$forceUpdate(); &#125; //修改方法 function tick()&#123; vm.message = 'hello Vue', vm.$nextTick(function()&#123; console.log('我被修改了') &#125;) &#125; &lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[实例入门]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[实例就是在构造器外部操作构造器内部的属性和方法，他让Vue可以和其他框架一起使用和jQuary一起使用 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message:'hello world' &#125;, mounted:function()&#123; $('#app').html('hello Vue') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 实例调用自定义方法 1app.add();]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[delimiters选项]]></title>
    <url>%2F2019%2F05%2F25%2Fdelimiters%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[delimiters是用在当我们想修改一些东西比如我不想用花括号来绑定值时使用,他一般在数组里有两个元素，第一个是改变后的前面的，另一个是改变后后面的部分 123456789101112131415161718&lt;div id="app"&gt; &lt;p&gt;$&#123;count&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, delimiters:['$&#123;','&#125;'] &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[extends选项]]></title>
    <url>%2F2019%2F05%2F25%2Fextends%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[extends方法和mixins差不多，是个扩展选项，只是在构造器里写的时候他是个对象（只能有一个对象），而mixins可以写一个数组 123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var addLog = &#123; updated:function()&#123; console.log('我是扩展出来的') &#125;, methods:&#123; add:function()&#123; this.count++; console.log('我是扩展出来的方法') &#125; &#125; &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, updated:function()&#123; console.log('原生') &#125;, extends:addLog &#125;) &lt;/script&gt; 需要注意的是，扩展出来的方法并没有执行，这个是与mixins一样，因为他与构造器内的方法重名了因而不能执行]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mixins选项]]></title>
    <url>%2F2019%2F05%2F25%2Fmixins%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[mixins是混入选项操作，一般用于在你写完构造器后想加些东西却不想污染构造器时使用，一种是当很多地方需要用时作为全局的使用，随时可以调用，同时下面的栗子中构造器原生的updated和构造器内的和全局的还有顺序规则，需要注意的是如果构造器内的mixin的名和构造器内方法的名字重了，就不存mixin了 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //全局的 Vue.mixin(&#123; updated:function()&#123; console.log('全局mixin') &#125; &#125;) var addLog = &#123; updated:function()&#123; console.log('mixin') &#125; &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, //原生 updated:function()&#123; console.log('原生') &#125;, //构造器内 mixins:[addLog] &#125;) &lt;/script&gt; 顺序：全局 构造器内 原生]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[watch选项]]></title>
    <url>%2F2019%2F05%2F25%2Fwatch%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[watch选项用于监控数据变化，一种是直接在构造器内用watch选项，一种是为了避免耦合度在构造器外使用 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &lt;p&gt;今日温度是：&#123;&#123;temperature&#125;&#125;℃&lt;/p&gt; &lt;p&gt;今日穿衣建议是：&#123;&#123;clothingAdvice&#125;&#125;&lt;/p&gt; &lt;button @click="raiseTemperature"&gt;升高温度&lt;/button&gt; &lt;button @click="reduceTemperature"&gt;降低温度&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var clothingAdvice=['T恤','夹克','棉服'] //在实际开发中一般是采用这种数组写法直接从数据库调 var app = new Vue(&#123; el:'#app', data:&#123; temperature:14, clothingAdvice:'夹克' &#125;, methods:&#123; raiseTemperature:function()&#123; this.temperature+=5; &#125;, reduceTemperature:function()&#123; this.temperature-=5; &#125; &#125;, watch:&#123; //注意watch这里需要两个参数，一个是新的值(newVal),一个是旧的值(oldVal) temperature:function(newVal,oldVal)&#123; if(this.temperature&gt;=20)&#123; this.clothingAdvice=clothingAdvice[0]; &#125; else if(this.temperature&gt;=0&amp;&amp;this.temperature&lt;20)&#123; this.clothingAdvice=clothingAdvice[1]; &#125; else this.clothingAdvice=clothingAdvice[2]; &#125; &#125; &#125;) &lt;/script&gt; 12345678910//要写在构造器下面，因为用到实例化appapp.$watch('temperature',function(newVal,oldVal)&#123; if(this.temperature&gt;=20)&#123; this.clothingAdvice=clothingAdvice[0]; &#125; else if(this.temperature&gt;=0&amp;&amp;this.temperature&lt;20)&#123; this.clothingAdvice=clothingAdvice[1]; &#125; else this.clothingAdvice=clothingAdvice[2]; &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[methods选项]]></title>
    <url>%2F2019%2F05%2F24%2Fmethods%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[methods方法一般跟@click这样的绑定，下面有三个栗子，分别是简单的传值绑定，组件绑定，实例外绑定 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add(2)"&gt;add&lt;/button&gt; &lt;!-- .native的意思实质上就是调用原生的js方法，这个技巧很常用 --&gt; &lt;btn @click.native="add(3)"&gt;&lt;/btn&gt; &lt;/div&gt; &lt;button onclick="app.add(4)"&gt;实例化外&lt;/button&gt; &lt;script&gt; var btn=&#123; template:`&lt;button&gt;add组件&lt;/button&gt;` &#125; var app = new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, components:&#123; 'btn':btn &#125;, methods:&#123; add:function(num)&#123; if(num !='')&#123; this.count+=num &#125; else this.num++ &#125; &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[computed选项]]></title>
    <url>%2F2019%2F05%2F24%2Fcomputed%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[computed选项一般用来改变原来的值得形式，使data选项里的值尽量的整洁简单，因此我们一般用computed选项来给绑定的值进行改变大小写啊，添加修饰啊。下面就举一个将新闻日期倒过来的小栗子，因为数据输入时是旧时间到新时间，而我们想要的是先看到新时间的新闻，所以在computed中使用computed就很有必要 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;newMessage&#125;&#125;&lt;/p&gt; &lt;ul&gt; &lt;li v-for="item in reverseNews"&gt;&#123;&#123;item.title&#125;&#125;-&#123;&#123;item.date&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message:100, news:[&#123;title:'新闻1', date:'2019/01/24'&#125;, &#123;title:'新闻2', date:'2019/01/25'&#125;, &#123;title:'新闻3', date:'2019/01/26'&#125;, &#123;title:'新闻4', date:'2019/01/27'&#125;] &#125;, computed:&#123; newMessage:function()&#123; return this.message='￥'+this.message+'元'; &#125;, reverseNews:function()&#123; return this.news.reverse(); &#125; &#125; &#125;) ; &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[propsData]]></title>
    <url>%2F2019%2F05%2F24%2FpropsData%2F</url>
    <content type="text"><![CDATA[实际上propsData他不是挂载个属性，它是一个选项，甚至说这很不常用，完全可以用组件实现，但是要认识他，他是个传递数据的选项 1234567891011121314&lt;div id="summer"&gt;&lt;/div&gt; &lt;script&gt; var summer = Vue.extend(&#123; template:`&lt;h2&gt;&#123;&#123;message&#125;&#125;-&#123;&#123;food&#125;&#125;&lt;/h2&gt;`, data:function()&#123; return&#123; message:'summer' &#125; &#125;, props:['food'] &#125;) new summer(&#123;propsData:&#123;food:'iceCream'&#125;&#125;).$mount('#summer') //注意写法sss &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[keyframes]]></title>
    <url>%2F2019%2F05%2F23%2Fkeyframes%2F</url>
    <content type="text"><![CDATA[与transition不同，这个可以在一开始就进行动画演示，无需操作，这在CSS动画中是很重要的部分，他可以让你任意调动，说白了，这个关键帧动画实际上就是多个补间动画,另外还有一种逐帧动画，它是一种特殊的关键帧动画，只不过他没有补间动画是一帧一帧的，但是他资源使用大，因此除了另两个动画搞不定的情况下尽量不要使用，因为他包含于keyframes里，因此说CSS设置动画实质上就两种transition和keyframes 12345678910111213141516171819202122232425&lt;style&gt; .container&#123; width:50px; height:50px; background-color: red; animation: run 1s ; &#125; @keyframes run&#123; 0%&#123; width:100px; &#125; 10%&#123; width: 20px; &#125; 50%&#123; width: 200px; &#125; 100%&#123; width:300px; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; 栗子中的run是动画名要与下面的@keyframes后的对应好了 当然transition里可以用的这里也可以用，比如说可以加上像linear这样的 1animation: run 1s linear ; 当只有前后两个节点时一般会写成from to来代替0% 100% 12345678@keyframes run&#123; from&#123; width:100px; &#125; to&#123; width:300px; &#125; &#125; 还有一些有意思的animation属性 设置动画倒着开始 1animation-direction: reverse; 设置动画不要回来了 1animation-fill-mode: forwards; 设置动画循环次数，这里的infinite是无数次 1animation-iteration-count: infinite; 设置动画停止 1animation-play-state: paused; 逐帧动画 123456789101112131415161718192021222324&lt;style&gt; .container&#123; width:100px; height:100px; border: 1px solid red; background:url("http://images2015.cnblogs.com/blog/733006/201611/733006-20161103171828065-1874183143.png") no-repeat; animation: run 1s ; animation-timing-function: steps(1); &#125; @keyframes run&#123; 0%&#123; background-position:0px 0px; &#125; 50%&#123; background-position:0px -80px; &#125; 100%&#123; background-position:0px 0px; &#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; 其实就是加个 12animation-timing-function: steps(1);/* 只能是1 */]]></content>
      <categories>
        <category>CSS动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[transition]]></title>
    <url>%2F2019%2F05%2F23%2Ftransition%2F</url>
    <content type="text"><![CDATA[transition(过渡)是用来设置补间动画的即自动填补两个画面中间的部分，但必须有前后变化，比如下面的栗子中，就得有个hover 123456789101112131415161718&lt;style&gt; .container&#123; width:50px; height:50px; background-color: red; transition: width 1s,background-color 1s; transition-delay: 2s; transition-timing-function: ease-in-out; &#125; .container:hover&#123; width:300px; height:50px; background-color: green; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt; transition-property和transition-duration一般一起用，第一个表示做动画的属性，第二个表示动画进行时间，当多个属性同时使用动画时就用逗号隔开,也可以写成all 1s 1transition: width 1s,background-color 1s; transition-delay 只有一个时间参数使用来设置延迟的 transition-timing-function是用来定义动画进行方式，就是先快后慢啊还是匀速啊啥的，常见方式如下 具体实例如下 ease-in-out: linear: ease-in ease-out 一个需要翻墙的工具，用来自制动画方式]]></content>
      <categories>
        <category>CSS动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件标签]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[组件标签就是&lt;component&gt;&lt;/component&gt;,是vue自己定义的，可以用这个实现动态选择组件，详情看下面的小栗子 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt; &lt;component :is="ok"&gt;&lt;/component&gt; &lt;!-- vue中用v-bind:is实现动态组件 --&gt; &lt;button @click="changeComponent"&gt;changeComponent&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var componentA = &#123; template:`&lt;h2 style="color:red"&gt;A&lt;/h2&gt;` &#125; var componentB = &#123; template:`&lt;h2 style="color:green"&gt;B&lt;/h2&gt;` &#125; var componentC= &#123; template:`&lt;h2 style="color:pink"&gt;C&lt;/h2&gt;` &#125; var app = new Vue(&#123; el:'#app', data:&#123; ok:'componentA' &#125;, components:&#123; 'componentA':componentA, 'componentB':componentB, 'componentC':componentC &#125;, methods:&#123; changeComponent:function()&#123; if(this.ok==componentA)&#123; this.ok=componentB &#125; else if(this.ok==componentB)&#123; this.ok=componentC &#125; else this.ok = componentA &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[父子组件关系]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[下面我将举个小栗子来说明父子组件关系123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;panda&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; //子组件对象，必须写在父组件对象上面否则说他没定义 //在构造器外定义局部注册组件 var city = &#123; template: `&lt;h2&gt;四川是中国的城市&lt;/h2&gt;` &#125; //父组件对象 var panda = &#123; template: ` &lt;div&gt; &lt;h2&gt;熊猫来自四川&lt;/h2&gt; &lt;city&gt;&lt;/city&gt; &lt;/div&gt; `, components:&#123; 'city':city //注意写法 &#125; &#125; var app = new Vue(&#123; el:'#app', components:&#123; 'panda':panda//注意写法 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件属性设置]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[组件属性(props)的设置有两个坑，第一个坑是组件属性命名一定不能有-只能化成驼峰式，第二个坑是props是数组，不能写成对象形式而且他是写在template底下的； 组件属性设置有两种，一种是直接属性，一种是绑定data 直接设置属性 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;panda here="China"&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', components:&#123; 'panda':&#123; template:`&lt;h2&gt;我来自&#123;&#123;here&#125;&#125;&lt;/h2&gt;`, props:['here'] &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 绑定data 12345678910111213141516171819&lt;body&gt; &lt;div id="app"&gt; &lt;panda :here="message"&gt;&lt;/panda&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data:&#123; message:'China' &#125;, components:&#123; 'panda':&#123; template:`&lt;h2&gt;我来自&#123;&#123;here&#125;&#125;&lt;/h2&gt;`, props:['here'] &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识组件]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%88%9D%E8%AF%86%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件实际上就是创建html不存在的标签，非常常用 注册全局组件123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app"&gt; &lt;are&gt;&lt;/are&gt;&lt;!--只能在vue实例化里用--&gt; &lt;/div&gt; &lt;div id="pp"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;script&gt; Vue.component('are',&#123; template:`&lt;h2&gt;我们&lt;/h2&gt;` &#125;) //不论构造器里有没有数据都要写这样才算实例化成功 var app = new Vue(&#123; el:'#app', data:&#123; &#125; &#125;) var pp = new Vue(&#123; el:'#pp', data:&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：都能用组件 注册局部组件1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id="app"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;div id="pp"&gt; &lt;are&gt;&lt;/are&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; &#125;, components:&#123; //注意引号 'are':&#123; template:`&lt;h2&gt;hello&lt;/h2&gt;` &#125; &#125; &#125;) var pp = new Vue(&#123; el:'#pp', data:&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：只有第一个才能用组件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[制作模板]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%88%B6%E4%BD%9C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Vue的模板(template)有三种创建方式 在Vue构造器内，这种情况只在template中语句少的时候适用，注意模板将会代替message1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`&lt;h2&gt;我是一个标签模板&lt;/h2&gt;` //注意是Tab键上面那个，为了避免和单引双引冲突 &#125;) &lt;/script&gt;&lt;/body&gt;``` ---### 在html里```html&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;!-- 注意不是放在实例化里 --&gt; &lt;template id="app2"&gt; &lt;h2&gt;我是一个模板&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`#app2`//设置响应 &#125;) &lt;/script&gt;&lt;/body&gt; 在js里,可从外部引用，在script标签后加一个src即可1234567891011121314151617&lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script type="x-template" id="app3"&gt; &lt;h2&gt;我是模板&lt;/h2&gt; &lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; message: 'hello world' &#125;, template:`#app3` &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生命周期]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期又叫钩子函数，就是在某个节点进行某个操作，这里讲的是构造器里的生命周期，总共有十个，有两个需结合组件学习(activated,deactivated)，所以先学八个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click="add"&gt;增加&lt;/button&gt; &lt;/div&gt; &lt;!-- 注意是onclick不是@click --&gt; &lt;button onclick="app.$destroy()"&gt;销毁&lt;/button&gt; &lt;script&gt; var app=new Vue(&#123; el:'#app', data:&#123; count:1 &#125;, methods:&#123; add:function()&#123; this.count++; &#125; &#125;, //注意要写在构造器里 beforeCreate:function()&#123; console.log('1-beforeCreat') &#125;, created:function()&#123; console.log('2- created') &#125;, beforeMount:function()&#123; console.log('3-beforeMount') &#125;, mounted:function()&#123; console.log('4-mounted') &#125;, beforeUpdate:function()&#123; console.log('5-beforeUpdate') &#125;, updated:function()&#123; console.log('6-updated') &#125;, beforeDestroy:function()&#123; console.log('7-beforeDestroy') &#125;, destroyed:function()&#123; console.log('8-destroyed') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.set]]></title>
    <url>%2F2019%2F05%2F18%2FVue-set%2F</url>
    <content type="text"><![CDATA[先举个调用构造器外数据的小栗子 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;button onclick="add()"&gt;add&lt;/button&gt; &lt;!-- 因为按钮在vue实例外，所以采用原声js方法onclick --&gt; &lt;script&gt; var outData = &#123; count: 1, goods: 'car' &#125; //注意这个数据放在vue构造器外 function add()&#123; // Vue.set(outData,'count',2) 且该方法只能让他变成2 //app.count++ outData.count++ &#125; var app = new Vue(&#123; el: '#app', data:outData//构造器外数据 &#125;) &lt;/script&gt;&lt;/body&gt; 由上述代码可见，想要调用构造器外数据由三种方法可行，那么为什么vue.set还有他存在的意义而且在开发中还很常用呢？看下面栗子 123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app" &gt; &#123;&#123;count&#125;&#125; &lt;ul&gt; &lt;li v-for="item in arr"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;button onclick="add()"&gt;add&lt;/button&gt; &lt;script&gt; var outData = &#123; count: 1, arr: ["aaa","bbb","ccc"] &#125; function add()&#123; // outData.count++, //outData.arr[1]="b" Vue.set(outData.arr,1,'b')//注意中间1的写法 &#125; var app = new Vue(&#123; el: '#app', data:outData &#125;) &lt;/script&gt;&lt;/body&gt; 解析：当不用Vue.set时，如果不设置改变count值，因为js本身限制，vue也就检测不到数组的改变包括数组长度或数组内元素变化，这个时候vue.set的存在就显得很必要，不用设置count变化,vue也能检测到数组变化，因此在上面代码的注释都取消，不用vue.set也行，但显然当我们不想引入count时，vue.set是最好的选择]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day4]]></title>
    <url>%2F2019%2F05%2F17%2Fday4%2F</url>
    <content type="text"><![CDATA[将二进制转换为小数，同样是各位乘以位权 计算机运算出错原因： 因此不是所有的十进制小数都可以用二进制表示，而计算机底层使用的都是二进制数，由此看来当计算一些不能直接化成二进制小数的将会像10/3一样，无限循环而不准确 为了避免这种出错可以把小数化成一定倍数好计算]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.extend]]></title>
    <url>%2F2019%2F05%2F17%2FVue-extend%2F</url>
    <content type="text"><![CDATA[因为还没学组件所以下面的将是一个简单的扩展实例构造器的小栗子，一般情况下扩展实例构造器是要和组件一起使用的1234567891011121314151617&lt;body&gt;&lt;!-- 最好写id形式，不要直接用标签 --&gt; &lt;div id="author"&gt;&lt;/div&gt; &lt;script&gt; //定义扩展构造器 var authorUrl = Vue.extend(&#123; template:'&lt;p&gt;&lt;a :href="authorUrl"&gt;&#123;&#123;authorName&#125;&#125;&lt;/a&gt;&lt;/p&gt;', data:function()&#123;//在Vue.extend里的data必须是函数 return&#123; authorName: 'liuxue', authorUrl:'https://snowFlakeXue.github.io' &#125; &#125; &#125;); //挂载（.$mount）到一个元素上 new authorUrl().$mount('#author'); &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义指令]]></title>
    <url>%2F2019%2F05%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[先举个小栗子要注意的是，vue提供的Vue-directive来自定义值令方法时要把这段代码写在vue实例化之前否则会报错，同时指令命名不能用驼峰法否则也会报错，V大写！ 代码里一些不熟悉的将在下面详细的讲讲 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="app"&gt; &lt;div v-change_color="color"&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;button @click="add"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.directive('change_color',function(el,binding,vnode)&#123; el.style='color:'+binding.value; &#125;); new Vue(&#123; el:'#app', data: &#123; num: 1, color:'red' &#125;, methods:&#123; add:function()&#123; this.num++; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 钩子函数（也叫生命周期） bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted:被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新 conponentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用 钩子函数的参数el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 binding的属性：(只包括了常用的，剩下的去官网找) name：指令名，不包括 v- 前缀。 expression：字符串形式的指令表达式 value：指令的绑定值 123456//注意引号 Vue.directive('change_color',function(el,binding,vnode)&#123; console.log(binding.value); console.log(binding.name); console.log(binding.expression); &#125;); vnode: Vue编译生成的虚拟节点。 上面小栗子的改写12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="app"&gt; &lt;div v-change_color="color"&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;button @click="add"&gt;add&lt;/button&gt; &lt;/div&gt; /*注意这个销毁应在app外，点销毁之后app就不运行了点add也不加一了 注意下面这个app是js中vue的app*/ &lt;button onclick="app.$destroy()"&gt;销毁&lt;/button&gt; &lt;script&gt; Vue.directive('change_color',&#123; bind:function(el,binding,vnode)&#123; console.log('1-bind'); el.style='color:'+binding.value; &#125;, inserted:function()&#123; console.log('2-inserted'); &#125;, update:function()&#123; console.log('3-update'); &#125;, componentUpdated:function()&#123; console.log('4-componentUpdated'); &#125;, unbind:function()&#123; console.log('5-unbind'); &#125; &#125; ); var app = new Vue(&#123; el:'#app', data: &#123; num: 1, color:'red' &#125;, methods:&#123; add:function()&#123; this.num++; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[其他指令]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-pre v-cloak v-once 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- v-pre 原样输出，不渲染--&gt; &lt;p v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;!-- v-cloak 页面加载完才显示，一般速度很快看不出来变化 --&gt; &lt;p v-cloak&gt;页面加载完显示&lt;/p&gt; &lt;!-- v-once 只渲染一次 --&gt; &lt;p v-once&gt;&#123;&#123;mes&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="mes" /&gt; &lt;p&gt;&#123;&#123;mes&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data: &#123; message:'hello', mes:'hello'//这个值决定了初始的值是什么 &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vbind]]></title>
    <url>%2F2019%2F05%2F16%2Fvbind%2F</url>
    <content type="text"><![CDATA[v-bind用于绑定属性，样式，很重要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 绑定标签属性 --&gt; &lt;a :href="url" target="_blank"&gt;链接&lt;/a&gt; &lt;br /&gt; &lt;!-- 直接绑定class样式 --&gt; &lt;p :class="className"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定class样式并判断 --&gt; &lt;p :class="&#123;classA:isOk&#125;"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定class数组 --&gt; &lt;p :class="[class1,class2]"&gt;a good girl&lt;/p&gt; &lt;!-- 用三元运算符绑定class样式 --&gt; &lt;p :class="isOk?class1:class2"&gt;a good girl&lt;/p&gt; &lt;!-- 绑定style,注意fontSize的写法，vue中不支持-这种写法，不能写成font-size --&gt; &lt;p :style="&#123;color:col,fontSize:size&#125;"&gt;a good girl&lt;/p&gt; &lt;!-- 用对象绑定style --&gt; &lt;p :style="styleObject"&gt;a good girl&lt;/p&gt; &lt;/div&gt; &lt;style&gt; .classA&#123; color:red; &#125; .classB&#123; font-size:20px; &#125; &lt;/style&gt; &lt;script&gt; new Vue(&#123; el:'#app', data: &#123; url: 'http://baidu.com', className: 'classA', isOk: false, class1:'classA', class2:'classB',//注意这里必须再声明一下否则没有反应 col:'red', size: 18+'px', styleObject:&#123; color:'green', fontSize:'30px'//注意fontSize &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vmodel]]></title>
    <url>%2F2019%2F05%2F16%2Fvmodel%2F</url>
    <content type="text"><![CDATA[v-model是实现双向绑定的方法，是vue的核心1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 简单的双向数据绑定 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="message" /&gt; &lt;!-- 延迟响应 ，鼠标离开或enter才响应--&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message1&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.lazy="message1" /&gt; &lt;!-- 只响应数字,若现输入字母则无效 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message2&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.number="message2" /&gt; &lt;!-- 自动去掉前后空格 --&gt; &lt;p&gt;您输入的内容是：&#123;&#123;message3&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model.trim="message3" /&gt; &lt;br /&gt; &lt;!-- 多选按钮绑定一个值 --&gt; &lt;input type="checkbox" id="isTrue" v-model="isTrue" /&gt; &lt;label for="isTrue"&gt;&#123;&#123;isTrue&#125;&#125;&lt;/label&gt; &lt;br /&gt; &lt;!-- 多选按钮绑定数组 --&gt; &lt;input type="checkbox" id="linguoqiang" value="linguoqiang" v-model="name" /&gt; &lt;label for="linguoqiang"&gt;linguoqiang&lt;/label&gt; &lt;input type="checkbox" id="liuxue" value="liuxue" v-model="name" /&gt; &lt;label for="liuxue"&gt;liuxue&lt;/label&gt; &lt;input type="checkbox" id="chenqianqian" value="chenqianqian" v-model="name" /&gt; &lt;label for="chenqianqian"&gt;chenqianqian&lt;/label&gt; &lt;input type="checkbox" id="guomengyu" value="guomengyu" v-model="name" /&gt; &lt;label for="guomengyu"&gt;guomengyu&lt;/label&gt; &lt;p&gt;您选中的是&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;!-- 单项按钮绑定 --&gt; &lt;input type="radio" value="男" id="man" v-model="sex" /&gt; &lt;label for="man"&gt;男&lt;/label&gt; &lt;input type="radio" value="女" id="woman" v-model="sex" /&gt; &lt;label for="woman"&gt;女&lt;/label&gt; &lt;p&gt;&#123;&#123;sex&#125;&#125;&lt;/p&gt; &lt;!-- 绑定文本域 --&gt; &lt;textarea v-model="text"&gt;&lt;/textarea&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; message: '', message1: '', message2: '', message3: '', isTrue: true, name: [], sex: '男', text: '' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[von]]></title>
    <url>%2F2019%2F05%2F16%2Fvon%2F</url>
    <content type="text"><![CDATA[v-on是事件绑定，他的缩写是@123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;您的的得分是：&#123;&#123;score&#125;&#125;&lt;/p&gt; &lt;!-- 更多事件去看js中的事件 --&gt; &lt;input type="button" @click="add" value="add" /&gt; &lt;input type="button" @click="reduce" value="reduce" /&gt; &lt;input type="text" v-on:keyup.enter="onEnter" v-model="number" /&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data:&#123; score: 0, number:'' &#125;, methods:&#123; //注意下面所有的this的使用，且不能写return,记成事件(v-on)和方法(methods)绑定 add:function()&#123; this.score++; &#125;, reduce:function()&#123; this.score--; &#125;, onEnter:function()&#123; this.score=this.score+parseInt(this.number) //注意转换否则变成字符串连接 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多keycode]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vhtml]]></title>
    <url>%2F2019%2F05%2F16%2Fvhtml%2F</url>
    <content type="text"><![CDATA[注意这种方法在你无法保证绝对安全时不要使用，否则会造成SSR攻击 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;span v-html="h2"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; h2:'&lt;h2&gt;hello world&lt;/h2&gt;' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[vtext]]></title>
    <url>%2F2019%2F05%2F16%2Fvtext%2F</url>
    <content type="text"><![CDATA[这种写法的作用和花括号法一样，但在网速慢加载不出来时不会输出花括号降低用户体验1234567891011&lt;div id="app"&gt; &lt;span v-text="h2"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; h2:'hello world' &#125; &#125;)&lt;/script&gt; 结果：hello world]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vfor]]></title>
    <url>%2F2019%2F05%2F16%2Fvfor%2F</url>
    <content type="text"><![CDATA[一个简单排序,注意这里面sort方法容易掉的坑，不仅是vue所有的js都有这个bug，因此这种解决方式很常用 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in sortItems"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; //注意这里的sortItems别写成items了！ &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:"#app", data:&#123; items:[1,4,3,78,45] &#125;, computed:&#123; sortItems://注意在vue中为了保护data这里必须重新命名不能用items function()&#123; return this.items.sort(sortNum) //若不再定义一个sortNum,将出现收字符排序完了再排下一个，如1,23,4,5,67 &#125; &#125; &#125;); //注意这个函数写的位置，应写在vue后 function sortNum(a,b)&#123; return a-b; &#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果： 对象数组排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(student,index) in sortStudents"&gt;&#123;&#123;index+1&#125;&#125;:&#123;&#123;student.name&#125;&#125;-&#123;&#123;student.age&#125;&#125;&lt;/li&gt; &lt;!-- 注意这里的索引的用法 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:"#app", data:&#123; students: [ &#123;name:'linguoqiang',age:21&#125;, &#123;name:'liuxue',age:21&#125;, &#123;name:'chenhong',age:20&#125;, &#123;name:'chenqianqian',age:19&#125;, &#123;name:'guomengyu',age:18&#125;, ] &#125;, computed:&#123; sortStudents: //千万注意不要画蛇添足在这里加花括号，否则会出错 function()&#123; return sortByKey(this.students,'age') &#125; &#125; &#125;); //对象数组排序方法，在网上搜直接拿过来用就好 function sortByKey(array,key)&#123; return array.sort(function(a,b)&#123; var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); &#125;);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针：指针是储存地址的变量，他也有自己的地址，他通过自己储存的地址指向内存单元 指针的声明：数据类型 *指针变量名；1int *p; 注意：因为当不赋初值时，系统将随意给他个地址，很容易出错，所以一般用NULL给他赋个初值 取地址： &amp;变量名（&amp;为地址运算符） 使用指针储存地址： 数据类型 *指针变量名 = 取地址12int a = 3;int *p = &amp;a; 特别注意的是指针的数据类型应和所指向的变量的数据类型相同 一种数据类型的指针变量可指向任意一个跟他同数据类型的变量1234int a = 10;int *p = &amp;a;int b =2;p = &amp;b; 使用*访问指向的数据 12int * a = 1;cout&lt;&lt;*a;//1 指向不同变量类型的指针长度相同，具体长度取决于编译器，32位编译器就是4个字节，64位编译器就是16个字节 123double a = 3.45;double b = &amp;a;cout&lt;&lt;sizeof(b);//4或8 动态内存分配：解决未知长度内存空间的问题，虽然也定义了长度但在delete时会将不用的销毁，若不用delete就会造成内存泄漏(即内存被占用却没发挥作用，而其他元素可使用元素减少，造成程序运行效率降低) 1234int a = new int;//要指明类型，这是给一个元素分配内存delete a;//对应的deleteint b = new int[10];//这是给多个元素分配内存的形式delete []b;//对应的delete 举一个为字符串分配内存的例子1234string name;cin&gt;&gt;name;//注意要调用string库调用cstring库报错char *n = new char[name.length()+1];//注意不是strlen(),这个用于char,至于+1则是考虑到c++中对最后一个终止字符的风格delete []n;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2019%2F05%2F09%2FBOM%2F</url>
    <content type="text"><![CDATA[BOM:浏览器对象模型，是实现与浏览器交流的window window.document（可省略window）(document就是表示这个文档，我理解成跟this差不多) window.innerHeight（浏览器内部高度，除去菜单栏，工具栏啥的）window.innerWidth（浏览器内部宽度）(Internet Explorer、Chrome、Firefox、Opera 以及 Safari支持) document.body.clientHeight/document.body.clientWidth(Internet Explorer 8、7、6、5支持) window.outerHeight（浏览器完整高度)window.outerWidth(浏览器完整宽度) 一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 screenscreen.availHeight/screen.availWidth屏幕可用高宽4.更多：用的时候查文档，一定要注意浏览器兼容问题，不是所有浏览器都支持 historyhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 navigatornavigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 注意：来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：navigator 数据可被浏览器使用者更改,浏览器无法报告晚于浏览器发布的新操作系统 js消息框 警告框：alert(“文本”) 确认框：confirm(“文本”) 提示框：prompt(“文本”)//提示用户输入js计时事件 setTimeOut(js代码，毫秒)[用于使事件在一定事件后再执行] 1234567&lt;button type=&quot;button&quot; onclick=&quot;func()&quot;&gt;点击&lt;/button&gt; &lt;script&gt; function func()&#123; setTimeout(&apos;alert(&quot;jhk&quot;)&apos;,5000); &#125; &lt;/script&gt; clearTimeOut(对应的setTimeOut)和无穷循环计数的使用 123456789101112131415161718&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;Start count!&quot; onClick=&quot;timeCount()&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Stop count!&quot; onClick=&quot;stopCount()&quot;&gt; &lt;/form&gt; &lt;script&gt; var c = 0; var t;//注意这个一定要全局声明，否则在第二个函数体内无法引用 function timeCount()&#123; document.getElementById(&quot;txt&quot;).value = c;//给它赋初值，把value和文本框绑起来 c+=1; t = setTimeout(&quot;timeCount()&quot;,1000); &#125; function stopCount()&#123; clearTimeout(t);//注意t的对应关系 &#125; &lt;/script&gt; cookie cookie是用来存放信息，有保质期，常用于自动登录，记住用户名，注意中要的数据不能存放在cookie中，因为用户可以自己修改 cookie的特性： 注意若不搭建服务器，只有火狐支持本地的cookie测试 同一网站中所有页面共享一套cookie 数量，大小有限 有限时间，即若不设置过期时间就在当次浏览器关闭时销毁cookie cookie的使用 ①设置cookie: 格式：名字=值123document.cookie = &quot;user=blue&quot;;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); //当把前两行注释后再打开浏览器仍然保留着他俩的值，但因为没有设期限（experis）在把浏览器关掉后再打开就没有这两个cookie了 不会被第二个甚至更多个cookie值覆盖 结果： ②给cookie设置时间期限12345var dat = new Date();dat.setDate(dat.getDate()+30);//加三十天document.cookie = &quot;user=blue; expires=&quot;+dat;document.cookie = &quot;pwd = 123&quot;;alert(document.cookie); 结果： ③上面的方法不常用，尝试封装成函数的方法新增cookie1234567function setCookie(name,value,i)&#123; var dat = new Date(); dat.setDate(dat.getDate()+i); document.cookie = name+&apos;=&apos;+value+(expires==null?&apos;&apos;:&apos;;expires=&apos;+dat);//判断截止时间是否为空 &#125; setCookie(&quot;Username&quot;,&quot;dfg&quot;,20); alert(document.cookie); 结果： ④提取cookie12345678910111213function getCookie(name)&#123; var arr1 = document.cookie.split(&quot;;&quot;); for(var i = 0;i&lt;arr1.length;i++)&#123; var arr2 = arr1[i].split(&quot;=&quot;);//将cookie拆分开，因为cookie实质上就是字符串 if(arr2[0]==name)&#123;//注意== return arr2[1]; &#125; return &quot;&quot;; &#125; &#125; setCookie(&quot;password&quot;,&quot;asd&quot;,20); alert(getCookie(&quot;password&quot;));//注意写引号 结果： ⑤删除cookie123function removeCookie(name)&#123; setCookie(name,1,-1);//写成-1浏览器以为是昨天的就自动删了 &#125;]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML_DOM]]></title>
    <url>%2F2019%2F05%2F08%2FHTML-DOM%2F</url>
    <content type="text"><![CDATA[什么是DOM：DOM是文档对象模型，他分xhtml,html,核心dom三种，所以html dom就是可以对html文本中任何元素进行修改删除等操作 DOM节点 在html中任何元素都是节点，比如说整个文档是文档节点，每个html元素是元素节点，每个元素的文本是文本节点，属性是属性节点，注释是注释节点 各节点间有父(parent)，子(child)，同胞关系(sibling);根元素没有父元素，其他元素都有父元素 DOM属性· 这里只说innerhtml,这个属性是获取元素的文本内容12//.innerHTML是获取指定的元素文本内容//.innerhTML = &quot;&quot;是修改制定元素的文本 DOM方法 document对象，他是html文档的根节点，在满足两个条件下他会覆盖原来的 HTML文档，一个是在函数中用document.write,一个是按钮响应这个函数;在下面的我们直接用document.即可1234567&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;button onclick = func()&gt;点击覆盖&lt;/button&gt; &lt;script&gt; function func()&#123; document.write(23333); &#125; &lt;/script&gt; 点击前： 点击后： 访问节点①.getElementById(“”) ②.getElementByTargeName(“”)//标签，如p ③.getElementByClassName(“”)//不推荐使用，因为IE5,6,7,8不支持 改变HTML内容1234&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).innerHTML = &quot;hello world!&quot;; &lt;/script&gt; 结果：hello world! 改变CSS样式（通过.style.属性名访问CSS样式）12345&lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &lt;/script&gt; 结果： 创建新元素 步骤一：创建新元素步骤二：若元素内需要有内容，需创建文本节点步骤三：将文本节点追加给新元素步骤四：将这个新元素追加给已有元素即父元素（必须有父元素）1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;sdsjkd&quot;); para.appendChild(tex); document.getElementById(&quot;div1&quot;).appendChild(para); &lt;/script&gt; 结果：123hellosdsjkd 1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var a = document.createElement(&quot;a&quot;); a.href=&quot;http://baidu.com&quot;; a.innerHTML=&quot;百度&quot;; document.getElementById(&quot;div1&quot;).appendChild(a); &lt;/script&gt; 结果： 删除已有元素1234567891011&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var child=document.getElementById(&quot;p1&quot;);//获取子元素 child.parentNode.removeChild(child);//通过parentNode找到父元素 &lt;/script&gt; 结果: he 替换元素12345678910111213&lt;div id=div1&gt; &lt;p id=&quot;p1&quot;&gt;hello&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;he&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var tex = document.createTextNode(&quot;snkslm&quot;); para.appendChild(tex); var parent = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p2&quot;); parent.replaceChild(para,child); &lt;/script&gt; 结果：123hellosnkslm 触发事件举个例子,也推荐这种形式，尽量不要写成内联1234567&lt;p id=&quot;p1&quot;&gt;点击我变颜色&lt;/p&gt; &lt;script&gt; document.getElementById(&quot;p1&quot;).onclick = func;//注意不能写func() function func()&#123; document.getElementById(&quot;p1&quot;).style.color = &quot;red&quot;; &#125; &lt;/script&gt; 特别注意在触发事件时调用的函数不能写括号，因为写括号就直接在页面加载完成就立刻执行，不加括号才是在触发事件时响应]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在js中函数也是对象，因此可以把它赋给一个变量，一个数组元素，甚至作为参数传给另一个函数调用函数的定义 声明式的静态方式(所有浏览器都支持） function 函数名(形参列表){函数体}//注意没有var否则报错,且function必须小写 ①这种方式最常用，他只需定义一次，在程序的完整过程中，他一直被存在内存中，只在页面打开时解析一次，不论是什么调用它，返回的都是函数体处理完的结果 ②要设定返回值，他可以有0个到多个return,一般多个return 都用在需要判断条件时，即满足这个条件就不往下执行函数体内容 ③参数方面注意传参形式，一种是传值，一种是传地址，简单点说就是传值不改变实参，传地址改变实参12345678910function change(str1,arr) &#123; str1 = "hello javascript!"; arr[arr.length] = "three";&#125;var str = "hello world!";var arr1 = ["one","two"];change(str,arr1);document.write(arr1);//传地址，改变document.write("&lt;br /&gt;");document.write(str);//传值，不变 结果：12one,two,threehello world! 匿名函数(没有函数名，又叫动态函数，较新的浏览器支持)var hd = new Function(&quot;参数1&quot;，&quot;参数2&quot;，&quot;函数结构体&quot;)//F必须大写，必须是new 匿名函数是用一次定义一次，直接赋给变量 这种方式不常用，但是在只有运行时才能确定函数成立条件时，创建动态函数就很有必要123456789var func = prompt("请输入函数体");var x = parseInt(prompt("请输入x"));var y = parseInt(prompt("请输入y"));//注意promt返回的是字符串若不转换结果就是23var op = new Function("x","y",func);var result = op(x,y);document.write("function is "+func+"&lt;br /&gt;");document.write("x is"+x+"&lt;br /&gt;");document.write("y is"+y+"&lt;br /&gt;");document.write("result is"+result); 结果：1234function is return x+yx is2y is3result is5 函数直接量（即赋给变量或作为另一函数的参数，新的浏览器支持7）①var func = (参数列表){函数体}//兼具了匿名函数和声明函数 ②var func = 函数名(参数列表){函数体} ③1234function fan(x,y,z)&#123; document.write((z(x,y)));&#125;fan(1,2,function(x,y)&#123;return x+y&#125;);//函数作为参数 结果：3 回调函数回调函数可以理解成，将回调函数作为参数放在一个新函数里，然后执行过程就是先执行新函数再反过来执行回调函数123456789//定义回调函数function fun1(value)&#123; document.write(value);&#125;//定义新函数并把回调函数作为参数function fun2(fun,value)&#123; fun(value);&#125;fun2(fun1,"hi js!") 结果：hi js! 函数对象123456789function func()&#123; //arguments.length返回参数个数 for(var i=0;i&lt;arguments.length;i++)&#123; document.write(arguments[i]); //arguments[i]输出对应参数，arguments和length是作为对象的函数的属性 &#125;&#125;func(1,2,3); 结果：123]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day3]]></title>
    <url>%2F2019%2F05%2F06%2Fday3%2F</url>
    <content type="text"><![CDATA[1.为什么程序底层要用二进制数：因为cpu和内存其实是IC的一种,而IC它两端有引角，引角只能输入5或0伏电压，这与二进制只有0和1对应，因此，每个引脚对应二进制的一位 计算机处理信息的基本单位一般是8位，因此二进制的位数一般都是8的倍数，而8位就是1个字节所以，计算机处理信息的基本单位是字节 位权：oo的xx次方，二进制oo就是2，十进制oo就是10，以此类推]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js对象]]></title>
    <url>%2F2019%2F05%2F06%2Fjs%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[四种对象 javascript内置对象 浏览器对象模型中的对象(BOM) 文档对象模型中的对象 用户自定义的对象 下面总结的都是第一种，javascript的内置对象js对象中都有自己的属性和方法，也可以通过new来新建一个对象，有的对象要注意对象和函数的区分，比如Number对象和Number()和Number对象的实例化 Boolean对象 必须注意创建Boolean对象实例的方法必须是与new结合的构造函数 1var boo = new Boolean(true); 在Boolean对象被实例化后，可通过Object的方法toValue来访问它所封装的基本值if(boo.toValue())···; 也可直接访问if(boo) Number对象 要注意在js中他对数值得辨识度并不高，它不论是整数还是指数还是浮点数，一律处理成64位的浮点型，也就是说在js中只有浮点型 Number对象的实例化，可以用new也可以直接用Number(),但是用Number的话是number型，不是对象 Number对象的属性，注意是对象不是对象的实例化 ①MAX_VALUE 指js可接受的最大值 ②MIN_VALUE 指js可接受的最小值 ③NEGATIVE_INFINITY 指js中定义的负无穷值 ④POSITIVE_INFINITY 指js中定义的正无穷值12345678document.write(Number.MAX_VALUE);document.write(Number.MIN_VALUE);document.write(Number.NEGATIVE_INFINITY);document.write(Number.POSITIVE_INFINITY);/*若写成以下形式会报错,因为只能是Number对象的var num = new Number(4)document.write(num.MAX_VALUE); */ 结果：1.7976931348623157e+3085e-324-InfinityInfinity Number对象的方法 ①toString() 有一个形参，是一个2到36的整数，默认为10，是将对象的实例化按进制输出123var num = new Number(&quot;100&quot;);document.write(num.toString(2));//若是用Number()实例化的，也不慌，会将他转换成对象在用这个函数，在转回变量 ②toLocalString() 无形参，作用是转化为本地格式的字符串12var num = new Number(1876653);document.write(num.toLocaleString()); 结果：1,876,653 ③toFixed() 有一个形参代表要有的小数位数，范围是0到20，包括0,20，不写默认为0,注意这个会四舍五入，要是不够会用零补上12var num = new Number(187.6653);document.write(num.toFixed()); 结果：18812var num = new Number(23.56);document.write(num.toFixed(10)); 结果：23.5600000000 ④toPrecision() 有一个参数,代表有效数位，会四舍五入，参数取值范围是1到21包括1,21；若不写参数，就会调用toString()12var num = new Number(23.56);document.write(num.toPrecision(3)); 结果：23.612var num = new Number(23.56);document.write(num.toPrecision()); 结果：23.56 ⑤toExponential() 将数值表示成指数型，有一个形参，代表保留小数位,若省略参数将显示尽可能多的小数位12var num = new Number(23.56356789);document.write(num.toExponential(3)); 结果：2.356e+1 String对象 String对象属性：length,代表字符串字符数，注意这里不像c++要在最后再加一 String对象有些格式化html方法，如anchor()[设置html锚点]；link()[生成链接]；big()[放大字体]；blink()[生成闪动字体]；bold()[加粗字体]；italics()[设置斜体]；sub()[设置下角标]；sup()[设置上角标]；small()[缩小字体]；strike()[加一条删除线]; 值得注意的是，这种html格式化方法并不是所有浏览器都兼容，比如blink()他在ie就不兼容，所以我们要尽可能的避免使用这种html格式化方法，但是anchor()和link()除外，这两个还是可以用用的 1234var str = &quot;Hello world!&quot;str.anchor(&quot;myAnchor&quot;);//参数为锚点名alert(str.anchor(&quot;myAnchor&quot;)); 结果：12var str=&quot;baidu&quot;;document.write(str.link(&quot;http://www.baidu.com&quot;)); 结果： charAt()返回索引处字符，参数则为索引12var str=&quot;baidu&quot;;document.write(str.charAt(2)); 结果：i charCodeAt()返回指定位置的字符的unicode编码12var str=&quot;baidu&quot;;document.write(str.charCodeAt(3)); 结果：100 js中有三种截取字符串片段的方法，我首推slice(start,end)，其次subString(start,stop),不能推荐subStr，因为es6没有规范他，就不用他,而slice()和subString()唯一不同就是前者接受负数后者不接受 123var str=&quot;Hello happy world!&quot;document.write(str.slice(4,7))// 只包括不包括结尾即其实是截取了str[4]到str[6],若无第二个参数表示后面的都要，若这两个参数为负则用负数加长度 indexOf()和lastIndexOf() 返回子串最开始出现的索引和最后一次出现的索引，注意该函数对大小写十分敏感，若不存在返回-1 1234var str = &quot;Hello world&quot;;document.write(str.indexOf(&apos;w&apos;));document.write(str.indexOf(&apos;W&apos;));document.write(str.lastIndexOf(&apos;l&apos;)); 结果：6-19 split() 有两个参数，第一个参数是分割标志(写成字符串)，第二个参数可选，限定个数，这个其实就是拆分字符串,整成一个数组；需要说的是，splirt()也可直接用在变量后 document.&quot;sdh\nfbdkv\ffd&quot;.split(&quot;\&quot;,1) 结果:sdh12var str = &quot;Hello world&quot;;document.write(str.split(&quot; &quot;,1)); 结果：Hello toUpperCase()和toLowerCase()将字符串都变成大写和小写1234var str = &quot;hjfkdflk&quot;;document.write(str.toUpperCase());var str1 = &quot;DKFENDFLOR&quot;;document.write(str1.toLowerCase()); 结果：HJFKDFLKdkfendflor formCharCode()这是一个静态方法所谓静态方法就是只能是对象调用不能对象的实例化调用，这个方法是将unicode编码实例化成一个字符串 1document.write(String.fromCharCode(72,69,76,76,79)); 结果:HELLO Date对象实例化：var time = new Date(); Date对象方法 当所用的是例如网上商店下订单这种孤立的行为，使用用户本地的就行，若是像评论博客这种国际化的全体的行为，就设UTC Date()直接返回用户电脑的时间1document.write(Date()); 结果：Mon May 06 2019 15:49:35 GMT+0800 (中国标准时间) Math对象 Math对象的属性 Math对象的方法，注意这些都是静态方法，不需实例化javascript数组 在js中数组也是对象 数组对象的属性，length 数组对象的实例化方式可new可不new,定义数组后就可以用索引了，比如a[i] ①var arr = [&quot;apple&quot;,&quot;banana&quot;] ; ②var arr = new Array(3,4,5,6,2) ③12345var arr = new Array(3);arr[0]=(1,3);arr[1]=(3,5);arr[2]=(5,4);//二维及以上数组定义方法，再创数组对象 splice()[修改原来数组]实现对数组中元素的添加,删除，修改（每种前两个参数都是固定的，第一个是开始操作的索引，第二个是删除的数量），返回的是删除后组成的数组，即documentarr返回的是修改后的，documentarr.splice返回的删除的组成的数组1234//添加元素，注意不能写成document.write(arr.splice(0,0,&quot;people&quot;))因为返回的是删除的数组var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,0,&quot;people&quot;)document.write(arr); 结果：people,apple,banana,pear,pen1234//删除元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1)document.write(arr); 结果：banana,pear,pen1234//替换元素var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);arr.splice(0,1,&quot;people&quot;)document.write(arr); 结果：people,banana,pear,pen slice()[不改变原来数组]，即documentarr返回的是原来的数组，documentarr.slice返回的是修改后的数组，作用是返回截取的元素，两个参数，第一个参数是其实的索引(包括)，第二个参数是结束的索引(不包括)12var arr = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr.slice(0,3)); 结果：apple,banana,pear concat()[不改变原来数组]即documentarr返回的是原来的数组，documentarr.concat返回的是修改后的数组，作用是连接数组123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);var arr2 = new Array(&quot;story&quot;);var arr3 = new Array(&quot;fish&quot;)var arr4 = [3,4,5];document.write(arr1.concat(arr2));//连接两个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr1.concat(arr2,arr3));//连接三个数组document.write(&apos;&lt;br /&gt;&apos;);document.write(arr4.concat(6,7));//连接参数 结果：123apple,banana,pear,pen,storyapple,banana,pear,pen,story,fish3,4,5,6,7 join() 将数组中对象用自己定义的分隔符输出12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.join(&apos;|&apos;)); 结果：apple|banana|pear|pen reverse() 颠倒数组顺序12var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.reverse()); 结果：pen,pear,banana,apple push()和pop() 组合使用实现先进后出栈 push()实现在数组的最后面依次加元素,返回新长度；pop()实现删去数组最后一个元素，返回被删除的元素；123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.push(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.pop());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346apple,banana,pear,pen,people,girlgirlapple,banana,pear,pen,people unshift()[ie不支持]和shift() 前者可以有多个参数，作用是加在数组最前面，第一个参数为a[0]以此类推，返回的是新长度，后者是删除最前面的元素，返回被删除的元素即原数组的首元素123456789var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);document.write(arr1.unshift(&quot;people&quot;,&quot;girl&quot;));// 可有多个参数document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1);document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1.shift());document.write(&quot;&lt;br /&gt;&quot;);document.write(arr1); 结果：12346people,girl,apple,banana,pear,penpeoplegirl,apple,banana,pear,pen 遍历数组 12345var arr1 = new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;pear&quot;,&quot;pen&quot;);for(var x in arr1)&#123; document.write(arr1[x]); document.write(&quot;&lt;br /&gt;&quot;);&#125; 结果：1234applebananapearpen 数组的深复制 先举个浅复制的例子 12345678var num1=[];for(var i=0;i&lt;10;i++)&#123; num1[i]=i+1;&#125;var num2=[];num2=num1;num1[0]=400;document.write(num2[0]); 输出结果是400 这种就是浅复制，是按引用传值，新数组还是指向旧数组，旧数组变他就变，要解决这个问题就要用到深复制这个概念 12345678910111213var num1=[];for(var i=0;i&lt;10;i++)&#123; num1[i]=i+1;&#125;function copy(arr1,arr2)&#123; for(var i=0;i&lt;arr1.length;i++)&#123; arr2[i]=arr1[i]; &#125;&#125;var num2=[];copy(num1,num2);num1[0]=400;document.write(num2[0]); 输出结果是1 因此深复制就是讲新数组与旧数组一个个复制得到 更推荐使用[]操作符来创建数组，而不是new Array() 在js中，是数组长度可伸长，可超过定义好的长度 数组排序： 若数组元素是字符串，直接用sort()方法 若数组元素是数字需要另外加一个compare函数 123456var num=[1,233,21,34,32];function compare(num1,num2)&#123; return num1-num2;&#125;num.sort(compare);document.write(num); 不返回新数组的迭代器方法 迭代器方法就是让数组里每一个元素应用一个函数 forEach() 接受一个函数作为参数，让数组每个元素执行一遍函数 every() 接受一个返回值为布尔值的函数作为参数，如果数组中每一个元素执行完函数返回的都是true则这个返回true some() 同样是接受一个返回值为布尔值的函数作为参数，但这个是只要数组中有元素返回的是true,这个就是true reduce() 接受一个函数为参数，返回一个数，这个一般用与数组累加求和，或者将数组中元素拼接为字符串。执行顺序为一个个累加值，直到最后一个值 reduceRight() 和reduce()类似，只不过这个是从右向左拼接字符串 返回数组的迭代器方法 map() 与forEach()类似，只不过这个返回每个元素执行完函数返回的值组成的数组 filter() 与every()类似，但这个返回的是执行完函数返回true的元素组成的数组]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day2]]></title>
    <url>%2F2019%2F05%2F05%2Fday2%2F</url>
    <content type="text"><![CDATA[程序运行时，程序计数器指向一个地址值，然后顺序结构的话，每进行一条指令，程序计数器上的值加一 其实cpu处理程序很有意思，像是比较累加寄存器和通用寄存器中的值，他实际上会进行减法运算，通过正负零来判断谁大谁小 运算结果存放在标志寄存器，无论结果是什么都会存放进去，同时标志寄存器还负责存放溢出和奇偶判断 分支结构是用的跳转指令，即运行时程序计数器不是单纯的一条指令加一 函数调用，实际上是先把调用处以下的指令先存放在栈，然后进行call到函数体进行，处理完函数体后，再return回到调用处的下一指令指向的地址，把栈上存放的指令读入到程序计数器上，再接着往下 说到划分内存，实际上要用到基址寄存器和变址寄存器，我们所说的实际地址值就是基址寄存器的值加上变址寄存器的值，而变址寄存器实际上就是我们所熟悉的数组的索引 正，0，负实际上存在32位的标志寄存器上的前三位]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运算符和语句]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[js语句的格式 要养成每条语句后都写分号的习惯 在js代码中，空白没意义，为了让代码更直观更易于维护，可尝试养成在等号前后，加号等前后写空格的习惯赋值语句 由左边变量，赋值变量和右边被赋给的值组成 右边的表达式可以是直接量值var vm = 35;一个变量和直接量再加上运算符的组合var value = vm + 27;函数的调用var nvalue = escape();一行可以包含多个赋值语句var a = b = c = 23; 二元运算符 二元运算符有加(+)减(-)乘(*)除(/)取余(%)注意在js中除法保存的是浮点数而不是截取的整数 这里重点说一下加法运算符，在字符串那里要特别注意，当两个运算数中有字符串时会优先将+解析为连接运算符12var vm = "3.99" + 2.7;document.write(vm); 结果：3.992.7 而对于其他的二元运算符，只要两个操作数中的字符串内只有数字就可以计算12var vm = "3" * 2;document.write(vm); 结果：6 为了在用加号时规避这种错误，最好采用parseInt或者parseFloat函数显式地转化一下字符串12var vm = parseInt('3') + 3;document.write(vm); 结果：6 一元运算符 一元运算符有负值运算符，自增运算符，自减运算符12345var vm = 2;var value = -vm;document.write(value);var nvalue = ++value;document.write(nvalue); 结果：-2-1 注意自增自减都有前置后置之分，前置是先自己变值在赋值，后置是先赋值在自己变值逻辑运算符，三元运算符，各种语句需要注意的因为有了c++基础就不多说什么事if循环啊啥的，记一点容易犯错的 注意短值运算，就是与的话当第一个表达式返回0，就不往下看了，这个直接就是假；是或的话当第一个表达式返回1，直接就是真，考虑到cpu等内存占用，应该把重要的依据放在前面 注意===和==区别，前面的是等同，现在已经广泛应用，因为当时字符串和数值比较，会先隐式地把字符串转化为数值型，用等同则返回false,用等于则返回true switch语句，注意写break,default;当多种情况是同一入口时，最好用如下形式： 1234case a:case b:case c:document.write("hhhhh"); 注意if语句的条件里千万不能写等于号，最次也得写个== 当想至少进行一次循环时，选do···while而不用while 注意一下for循环中的for in型，在后面会用到比如遍历数组啥的，以后再说，先简单举个栗子1234object("a":b,"c":d)for(x in object)&#123; txt += object[x] ;&#125; 结果：cd]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day1]]></title>
    <url>%2F2019%2F05%2F04%2Fday1%2F</url>
    <content type="text"><![CDATA[CPU和内存是由很多的晶体管组成，他俩合称IC（集成电路） CPU由寄存器，运算器，控制器和时钟组成 程序运行过程：首先由程序员用高级语言写出程序，然后把程序编译成机器语言（即exe文件），然后将这个exe文件在内存上存一个副本，然后再在CPU上解析运行 将CPU的解析和运行过程放大来讲，是时钟先发出时钟信号，cpu开始工作啦，他先让寄存器去抓内存上的数据，然后运算器进行运算，然后控制器通过运算结果来控制整个计算机，其实也就是控制输入输出什么的 实际上，对于程序员来说可以把CPU简单的理解为是很多很多寄存器的集合体，寄存器有很多种，不仅是他们存储的类型上，比如有的是存数值这种数据的，有的他是存地址这样的数据 汇编语言是由助记符组成的（比如将addition写成add），他和机器语言实际上是一一对应的，每一个机器语言实际上都有对应的汇编语言。因而，我们把将汇编语言转换成机器语言成为汇编过程，把机器语言转换为汇编语言称为反汇编过程 其实，编译器汇编器这种的并不是我们所想的一种组件什么的，他其实就是一个程序 我们可以简单地把程序运行的过程就当成是各种寄存器之间的处理，因此我们只要知道CPU是寄存器的集合体就好 内存，我们叫主储存器，现在一般都是DRAM（动态随机存储器），就是储存数据啊啥的，1个字节是8位，每个都有地址]]></content>
      <categories>
        <category>睡前小读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型与变量]]></title>
    <url>%2F2019%2F05%2F04%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[标识符 标识符只能由数字，字母，$符和下划线表示 首字符必须是字母或$符或下划线，切记不能是数字 在所使用的的作用域内，每个变量的标识符是唯一的 可在变量标识符中使用Unicode的字母和数字，官网链接 可使用转义序列 区分大小写 不得使用js关键字，ECMA 262规范的保留字，浏览器中典型的保留字，具体如下图 js关键字 ECMA 262规范的保留字 浏览器中典型的保留字 尽量使用有意义的，提高可维护性 一些小规范：①项目的集合名称应用复数②对象名首字母大写③函数和变量以小写字母开始并使用驼峰法,也可每个单词间用下划线作用域 局部变量：在一个函数内定义，初始化，函数结束时变量不存在 全局变量：在所有地方都可访问，包括引入的js库 要养成写var的习惯，因为当你想要定义一个局部变量但没有写var就会被当做全局变量，也就是说全局变量可不写var但最好也要写字符串型 单引号和双引号作用一样，不做区别；但是当需要嵌套时不能同型套同型，只能是单引号套双引号或双引号套单引号 字符串中可包括转义序列，例如 \n \\ \&#39; \&quot; 可使用escape函数和unescape函数进行编码和解码，但需要注意的是这两个函数不能处理非ASCII码字符，这是可使用encodeURI和decodeURI函数，下面是使用escape函数和unescape函数的示例12document.write(escape("sbadkf65488$%^"));document.write(unescape("sbadkf65488%24%25%5E")); 结果：sbadkf65488%24%25%5Esbadkf65488$%^ 空字符串是一种特殊情形，一般用来初始化 字符串连接:12var year=2019;document.write("今年是"+year+"年"); 结果：今年是2019年 toString函数，将其他类型转换为字符串类型123document.write(boo.toString());//显示数据类型document.write(typeof boo.toString()); 布尔型 只有true和false两种，不能用引号包起来 Boolean函数,将其他类型转化为布尔型。需要注意的是没有toBoolean函数了，是Boolean函数！！！！还有强调一下有管字符串转成布尔型，当是空字符串时返回false，当是一个及以上空格时返回true,具体实践如下1234var s=Boolean("");document.write(s);var r=Boolean(" ");document.write(r); 结果：falsetrue 数值型 js中数字是浮点型，需要注意的是，js的计算能力不是很强，所以在数字方面一般不是很精确 可取数范围是-2e31到2e31;js中规定正无穷用Infinity表示，负无穷用-Infinity表示；当某函数出现溢出时则会返回一个Infinity（正无穷） parseFloat()和parseInt(),这两个函数都可用于在字符串中提取出数字，但需要注意的是只能提取出第一个字符就是数字的字符串否则报错，其次，parseInt()只取整数部分，注意事项截取而不是四舍五入;这两个函数还可将八进制或十六进制数转化为十进制，只需在后面加一个参数默认为10，具体例子如下1234var str1=parseInt("0x5F",16);document.write(str1);var str2=parseFloat("171.8cm");document.write(str2); 结果：95171.8 isFinite函数，用来判断无穷大，当值是无穷大或NaN时返回false,否则返回true Number函数，将其他数据类型转换为数值型,注意字符串类型，只有在字符串内全部是数字时才有用，否则返回NaN12var str2=Number("171.8cm");document.write(str2); 结果：NaN 常量const 变量名 = 值； 只定义一次 null与undefinedjavaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺 javaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 null值则是表示空对象指针 其实，null就给他理解成一个空对象，暂时赋给一个变量，而undefined就是当访问为初始化的变量时返回undefined]]></content>
      <categories>
        <category>javascript学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[myBlog]]></title>
    <url>%2F2019%2F05%2F04%2FmyBlog%2F</url>
    <content type="text"><![CDATA[嘻嘻嘻。 吼吼吼。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
